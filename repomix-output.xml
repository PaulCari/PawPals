This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/__init__.py
backend/main.py
backend/models.py
backend/package.json
backend/README.md
backend/routers/__init__.py
backend/routers/admin/pedidos.py
backend/routers/admin/platos.py
backend/routers/admin/repartidores.py
backend/routers/admin/subscripciones.py
backend/routers/auth.py
backend/routers/cliente/carrito.py
backend/routers/cliente/cliente.py
backend/routers/cliente/favoritos.py
backend/routers/cliente/mascota.py
backend/routers/cliente/pago.py
backend/routers/cliente/pedido.py
backend/routers/cliente/perfil.py
backend/routers/cliente/platos_mascotas.py
backend/routers/cliente/subscripciones.py
backend/routers/nutricionista.py
backend/routers/repartidor.py
backend/seed_data.py
backend/static/imagenes/bebidas/Bebida1.png
backend/static/imagenes/bebidas/Bebida2.png
backend/static/imagenes/bebidas/Bebida3.png
backend/static/imagenes/cliente/gato.png
backend/static/imagenes/cliente/perro.png
backend/static/imagenes/cliente/user.png
backend/static/imagenes/cliente/user2.png
backend/static/imagenes/plato/barf_pato_gato.png
backend/static/imagenes/plato/barf_pollo.png
backend/static/imagenes/plato/barf_ternera.png
backend/static/imagenes/plato/imagen1.png
backend/static/imagenes/plato/imagen10.png
backend/static/imagenes/plato/imagen11.png
backend/static/imagenes/plato/imagen12.png
backend/static/imagenes/plato/imagen13.png
backend/static/imagenes/plato/imagen14.png
backend/static/imagenes/plato/imagen15.png
backend/static/imagenes/plato/imagen16.png
backend/static/imagenes/plato/imagen17.png
backend/static/imagenes/plato/imagen18.png
backend/static/imagenes/plato/imagen19.png
backend/static/imagenes/plato/imagen2.png
backend/static/imagenes/plato/imagen3.png
backend/static/imagenes/plato/imagen4.png
backend/static/imagenes/plato/imagen5.png
backend/static/imagenes/plato/imagen6.png
backend/static/imagenes/plato/imagen7.png
backend/static/imagenes/plato/imagen8.png
backend/static/imagenes/plato/imagen9.png
backend/static/imagenes/qr/imagen1.png
backend/static/imagenes/qr/imagen2.png
backend/utils/__init__.py
backend/utils/db.py
backend/utils/globals.py
backend/utils/keygen.py
backend/utils/security.py
backend/utils/token_manager.py
frontend/App.js
frontend/app.json
frontend/AppNavigator.js
frontend/assets/adaptive-icon.png
frontend/assets/background.jpg
frontend/assets/bone.png
frontend/assets/elipse-oscuro.png
frontend/assets/ellipse.png
frontend/assets/favicon.png
frontend/assets/fondo.jpg
frontend/assets/FONDOA.png
frontend/assets/gato.png
frontend/assets/icon.png
frontend/assets/logo_amarillo.png
frontend/assets/logo.png
frontend/assets/mixto1.png
frontend/assets/mixto2.png
frontend/assets/paw.png
frontend/assets/perro.png
frontend/assets/placeholder.png
frontend/assets/qr/imagen1.png
frontend/assets/qr/imagen2.png
frontend/assets/user.png
frontend/components/AuthContainer.js
frontend/components/CartBadge.js
frontend/components/ProductCard.js
frontend/index.js
frontend/package.json
frontend/README.md
frontend/screens/AddAddressScreen.js
frontend/screens/AddPetScreen.js
frontend/screens/CartScreen.js
frontend/screens/CheckoutScreen.js
frontend/screens/FavoritesScreen.js
frontend/screens/HomeScreen.js
frontend/screens/LoginScreen.js
frontend/screens/OrderSuccessScreen.js
frontend/screens/PaymentScreen.js
frontend/screens/PetProfileScreen.js
frontend/screens/ProductDetailScreen.js
frontend/screens/RegisterScreen.js
frontend/screens/SplashScreen.js
frontend/screens/SuccessScreen.js
frontend/screens/UploadProofScreen.js
frontend/screens/UserProfileScreen.js
frontend/screens/WelcomeScreen.js
frontend/services/addressService.js
frontend/services/api.js
frontend/services/authService.js
frontend/services/cartService.js
frontend/services/favoriteService.js
frontend/services/paymentService.js
frontend/services/petService.js
frontend/services/productService.js
frontend/styles/addAddressScreenStyles.js
frontend/styles/addPetScreenStyles.js
frontend/styles/cartScreenStyles.js
frontend/styles/checkoutScreenStyles.js
frontend/styles/favoritesScreenStyles.js
frontend/styles/homeScreenStyles.js
frontend/styles/loginScreenStyles.js
frontend/styles/orderSuccessScreenStyles.js
frontend/styles/paymentScreenStyles.js
frontend/styles/petProfileScreenStyles.js
frontend/styles/productCardStyles.js
frontend/styles/productDetailScreenStyles.js
frontend/styles/registerScreenStyles.js
frontend/styles/splashScreenStyles.js
frontend/styles/successScreenStyles.js
frontend/styles/userProfileScreenStyles.js
frontend/styles/welcomeScreenStyles.js
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# ===========================
#        GLOBAL
# ===========================
# Archivos de sistema y claves secretas
.DS_Store
Thumbs.db
.env
.env*.local
*.pem

# Dependencias (Ignora node_modules en frontend y backend)
node_modules/

# ===========================
#   FRONTEND (React Native)
# ===========================
# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native (Carpetas generadas automáticamente)
# Quitamos la barra del inicio '/' para que las detecte dentro de 'frontend/'
ios/
android/

# Archivos nativos y claves
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro & Debug
.metro-health-check*
npm-debug.*
yarn-debug.*
yarn-error.*

# TypeScript
*.tsbuildinfo

# ===========================
#     BACKEND (Python)
# ===========================
# Archivos compilados y caché (CRUCIAL para Python)
__pycache__/
*.py[cod]
*$py.class

# Entornos virtuales
venv/
env/
.venv/

# Bases de datos locales (si usas SQLite)
*.sqlite3
*.db
</file>

<file path="backend/main.py">
# backend/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from utils.db import engine
from routers.cliente import pago as cliente_pago

# Routers generales
from routers import (
    auth,
    nutricionista,
    repartidor,
)

# Routers cliente
from routers.cliente import (
    cliente,
    mascota,
    pedido,
    perfil,
    platos_mascotas,
    subscripciones as cliente_subscripciones,
    favoritos,
    carrito as cliente_carrito,
)

# Routers admin
from routers.admin import (
    pedidos as admin_pedidos,
    platos as admin_platos,
    repartidores as admin_repartidores,
    subscripciones as admin_subscripciones,
)

from models import Base

print("--- Intentando crear tablas en la base de datos 'mascotas'... ---")
Base.metadata.create_all(bind=engine)
print("--- Proceso de creación de tablas finalizado. ---")

app = FastAPI(title="API Mascota")

# ✅ CONFIGURACIÓN CRÍTICA DE CORS - DEBE IR ANTES DE CUALQUIER ROUTER
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ← Acepta cualquier origen (desarrollo)
    allow_credentials=True,
    allow_methods=["*"],  # ← GET, POST, PUT, DELETE, OPTIONS
    allow_headers=["*"],  # ← Todos los headers
    expose_headers=["*"]  # ← Expone todos los headers
)

# Servir archivos estáticos
app.mount("/static", StaticFiles(directory="static"), name="static")

# Incluir routers
app.include_router(auth.router)
app.include_router(nutricionista.router)
app.include_router(repartidor.router)
app.include_router(platos_mascotas.router)
app.include_router(cliente.router)
app.include_router(mascota.router)
app.include_router(pedido.router)
app.include_router(perfil.router)
app.include_router(cliente_subscripciones.router)
app.include_router(favoritos.router)
app.include_router(admin_pedidos.router)
app.include_router(admin_platos.router)
app.include_router(admin_repartidores.router)
app.include_router(admin_subscripciones.router)
app.include_router(cliente_carrito.router)
app.include_router(cliente_pago.router)

@app.get("/")
def root():
    return {"status": "ok", "message": "Backend Mascota iniciado correctamente"}
</file>

<file path="backend/models.py">
from typing import Optional
import datetime
import decimal

from sqlalchemy import CHAR, DECIMAL, Date, DateTime, ForeignKeyConstraint, Index, Integer, String, Text
from sqlalchemy.dialects.mysql import BIGINT, TINYINT
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

class Base(DeclarativeBase):
    pass


class Categoria(Base):
    __tablename__ = 'categoria'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(Text)

    plato_combinado: Mapped[list['PlatoCombinado']] = relationship('PlatoCombinado', back_populates='categoria')

class CuentaUsuario(Base):
    __tablename__ = 'cuenta_usuario'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    correo_electronico: Mapped[str] = mapped_column(String(80), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    nombre_usuario: Mapped[Optional[str]] = mapped_column(String(40))
    contrasena: Mapped[Optional[str]] = mapped_column(String(255))
    ultimo_acceso: Mapped[Optional[datetime.datetime]] = mapped_column(DateTime)

    cliente: Mapped[list['Cliente']] = relationship('Cliente', back_populates='cuenta_usuario')
    nutricionista: Mapped[list['Nutricionista']] = relationship('Nutricionista', back_populates='cuenta_usuario')
    repartidor: Mapped[list['Repartidor']] = relationship('Repartidor', back_populates='cuenta_usuario')
    usuario_rol: Mapped[list['UsuarioRol']] = relationship('UsuarioRol', back_populates='cuenta_usuario')


class Especie(Base):
    __tablename__ = 'especie'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(Text)

    alergia_especie: Mapped[list['AlergiaEspecie']] = relationship('AlergiaEspecie', back_populates='especie')
    plato_combinado: Mapped[list['PlatoCombinado']] = relationship('PlatoCombinado', back_populates='especie')
    registro_mascota: Mapped[list['RegistroMascota']] = relationship('RegistroMascota', back_populates='especie')


class Etiqueta(Base):
    __tablename__ = 'etiqueta'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)

    etiqueta_plato: Mapped[list['EtiquetaPlato']] = relationship('EtiquetaPlato', back_populates='etiqueta')


class MembresiaSubscripcion(Base):
    __tablename__ = 'membresia_subscripcion'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)
    duracion: Mapped[int] = mapped_column(Integer, nullable=False)
    precio: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(String(100))
    beneficios: Mapped[Optional[str]] = mapped_column(Text)

    cliente: Mapped[list['Cliente']] = relationship('Cliente', back_populates='membresia_subscripcion')


class PasarelaPago(Base):
    __tablename__ = 'pasarela_pago'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(String(100))
    imagen_qr: Mapped[Optional[str]] = mapped_column(Text)

    pago: Mapped[list['Pago']] = relationship('Pago', back_populates='pasarela_pago')


class Rol(Base):
    __tablename__ = 'rol'

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(20), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(String(100))

    usuario_rol: Mapped[list['UsuarioRol']] = relationship('UsuarioRol', back_populates='rol')


class AlergiaEspecie(Base):
    __tablename__ = 'alergia_especie'
    __table_args__ = (
        ForeignKeyConstraint(['especie_id'], ['especie.id'], ondelete='CASCADE', name='alergia_especie_ibfk_1'),
        Index('especie_id', 'especie_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    especie_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(Text)

    especie: Mapped['Especie'] = relationship('Especie', back_populates='alergia_especie')
    alergia_mascota: Mapped[list['AlergiaMascota']] = relationship('AlergiaMascota', back_populates='alergia_especie')


class Cliente(Base):
    __tablename__ = 'cliente'
    __table_args__ = (
        ForeignKeyConstraint(['cuenta_usuario_id'], ['cuenta_usuario.id'], ondelete='CASCADE', name='cliente_ibfk_1'),
        ForeignKeyConstraint(['membresia_subscripcion_id'], ['membresia_subscripcion.id'], name='cliente_ibfk_2'),
        Index('cuenta_usuario_id', 'cuenta_usuario_id', unique=True),
        Index('membresia_subscripcion_id', 'membresia_subscripcion_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cuenta_usuario_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    telefono: Mapped[Optional[str]] = mapped_column(String(11))
    foto: Mapped[Optional[str]] = mapped_column(Text)
    membresia_subscripcion_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    cuenta_usuario: Mapped['CuentaUsuario'] = relationship('CuentaUsuario', back_populates='cliente')
    membresia_subscripcion: Mapped[Optional['MembresiaSubscripcion']] = relationship('MembresiaSubscripcion', back_populates='cliente')
    direccion: Mapped[list['Direccion']] = relationship('Direccion', back_populates='cliente')
    registro_mascota: Mapped[list['RegistroMascota']] = relationship('RegistroMascota', back_populates='cliente')
    pedido: Mapped[list['Pedido']] = relationship('Pedido', back_populates='cliente')
    plato_favorito: Mapped[list['PlatoFavorito']] = relationship('PlatoFavorito', back_populates='cliente')


class Nutricionista(Base):
    __tablename__ = 'nutricionista'
    __table_args__ = (
        ForeignKeyConstraint(['cuenta_usuario_id'], ['cuenta_usuario.id'], ondelete='CASCADE', name='nutricionista_ibfk_1'),
        Index('cuenta_usuario_id', 'cuenta_usuario_id', unique=True)
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cuenta_usuario_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    telefono: Mapped[str] = mapped_column(String(15), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    especialidad: Mapped[Optional[str]] = mapped_column(String(60))
    colegio_veterinario: Mapped[Optional[str]] = mapped_column(String(40))

    cuenta_usuario: Mapped['CuentaUsuario'] = relationship('CuentaUsuario', back_populates='nutricionista')
    consulta: Mapped[list['Consulta']] = relationship('Consulta', back_populates='nutricionista')


class PlatoCombinado(Base):
    __tablename__ = 'plato_combinado'
    __table_args__ = (
        ForeignKeyConstraint(['categoria_id'], ['categoria.id'], ondelete='SET NULL', name='plato_combinado_ibfk_1'),
        ForeignKeyConstraint(['especie_id'], ['especie.id'], ondelete='SET NULL', name='plato_combinado_ibfk_2'),
        Index('categoria_id', 'categoria_id'),
        Index('especie_id', 'especie_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    precio: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    incluye_plato: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    es_crudo: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    publicado: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    creado_nutricionista: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    categoria_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    especie_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    descripcion: Mapped[Optional[str]] = mapped_column(Text)
    imagen: Mapped[Optional[str]] = mapped_column(Text)

    categoria: Mapped[Optional['Categoria']] = relationship('Categoria', back_populates='plato_combinado')
    especie: Mapped[Optional['Especie']] = relationship('Especie', back_populates='plato_combinado')
    etiqueta_plato: Mapped[list['EtiquetaPlato']] = relationship('EtiquetaPlato', back_populates='plato_combinado')
    plato_personal: Mapped[list['PlatoPersonal']] = relationship('PlatoPersonal', back_populates='plato_combinado')
    detalle_pedido: Mapped[list['DetallePedido']] = relationship('DetallePedido', back_populates='plato_combinado')
    detalle_dieta: Mapped[list['DetalleDieta']] = relationship('DetalleDieta', back_populates='plato_combinado')
    plato_favorito: Mapped[list['PlatoFavorito']] = relationship('PlatoFavorito', back_populates='plato_combinado')


class Repartidor(Base):
    __tablename__ = 'repartidor'
    __table_args__ = (
        ForeignKeyConstraint(['cuenta_usuario_id'], ['cuenta_usuario.id'], ondelete='CASCADE', name='repartidor_ibfk_1'),
        Index('cuenta_usuario_id', 'cuenta_usuario_id', unique=True)
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cuenta_usuario_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    telefono: Mapped[str] = mapped_column(String(15), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)

    cuenta_usuario: Mapped['CuentaUsuario'] = relationship('CuentaUsuario', back_populates='repartidor')
    control_entrega: Mapped[list['ControlEntrega']] = relationship('ControlEntrega', back_populates='repartidor')


class UsuarioRol(Base):
    __tablename__ = 'usuario_rol'
    __table_args__ = (
        ForeignKeyConstraint(['cuenta_usuario_id'], ['cuenta_usuario.id'], ondelete='CASCADE', name='usuario_rol_ibfk_1'),
        ForeignKeyConstraint(['rol_id'], ['rol.id'], ondelete='SET NULL', name='usuario_rol_ibfk_2'),
        Index('cuenta_usuario_id', 'cuenta_usuario_id', unique=True),
        Index('rol_id', 'rol_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cuenta_usuario_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False) 
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    rol_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    

    cuenta_usuario: Mapped['CuentaUsuario'] = relationship('CuentaUsuario', back_populates='usuario_rol')
    rol: Mapped[Optional['Rol']] = relationship('Rol', back_populates='usuario_rol')


class Direccion(Base):
    __tablename__ = 'direccion'
    __table_args__ = (
        ForeignKeyConstraint(['cliente_id'], ['cliente.id'], name='direccion_ibfk_1'),
        Index('cliente_id', 'cliente_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cliente_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    latitud: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    longitud: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    es_principal: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    referencia: Mapped[Optional[str]] = mapped_column(String(100))

    cliente: Mapped['Cliente'] = relationship('Cliente', back_populates='direccion')
    pedido: Mapped[list['Pedido']] = relationship('Pedido', back_populates='direccion')


class EtiquetaPlato(Base):
    __tablename__ = 'etiqueta_plato'
    __table_args__ = (
        ForeignKeyConstraint(['etiqueta_id'], ['etiqueta.id'], ondelete='CASCADE', name='etiqueta_plato_ibfk_2'),
        ForeignKeyConstraint(['plato_combinado_id'], ['plato_combinado.id'], ondelete='CASCADE', name='etiqueta_plato_ibfk_1'),
        Index('etiqueta_id', 'etiqueta_id'),
        Index('plato_combinado_id', 'plato_combinado_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    plato_combinado_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    etiqueta_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)

    etiqueta: Mapped['Etiqueta'] = relationship('Etiqueta', back_populates='etiqueta_plato')
    plato_combinado: Mapped['PlatoCombinado'] = relationship('PlatoCombinado', back_populates='etiqueta_plato')


class RegistroMascota(Base):
    __tablename__ = 'registro_mascota'
    __table_args__ = (
        ForeignKeyConstraint(['cliente_id'], ['cliente.id'], ondelete='CASCADE', name='registro_mascota_ibfk_1'),
        ForeignKeyConstraint(['especie_id'], ['especie.id'], name='registro_mascota_ibfk_2'),
        Index('cliente_id', 'cliente_id'),
        Index('especie_id', 'especie_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cliente_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(40), nullable=False)
    sexo: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    cambio_edad: Mapped[datetime.date] = mapped_column(Date, nullable=False)
    edad: Mapped[int] = mapped_column(Integer, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    especie_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    raza: Mapped[Optional[str]] = mapped_column(String(40))
    peso: Mapped[Optional[decimal.Decimal]] = mapped_column(DECIMAL(10, 2))
    foto: Mapped[Optional[str]] = mapped_column(Text)
    observaciones: Mapped[Optional[str]] = mapped_column(Text)

    cliente: Mapped['Cliente'] = relationship('Cliente', back_populates='registro_mascota')
    especie: Mapped[Optional['Especie']] = relationship('Especie', back_populates='registro_mascota')
    alergia_mascota: Mapped[list['AlergiaMascota']] = relationship('AlergiaMascota', back_populates='registro_mascota')
    condicion_salud: Mapped[list['CondicionSalud']] = relationship('CondicionSalud', back_populates='registro_mascota')
    consulta: Mapped[list['Consulta']] = relationship('Consulta', back_populates='registro_mascota')
    descripcion_alergias: Mapped[list['DescripcionAlergias']] = relationship('DescripcionAlergias', back_populates='registro_mascota')
    plato_personal: Mapped[list['PlatoPersonal']] = relationship('PlatoPersonal', back_populates='registro_mascota')
    preferencia_alimentaria: Mapped[list['PreferenciaAlimentaria']] = relationship('PreferenciaAlimentaria', back_populates='registro_mascota')
    pedido_especializado: Mapped[list['PedidoEspecializado']] = relationship('PedidoEspecializado', back_populates='registro_mascota')
    receta_medica: Mapped[list['RecetaMedica']] = relationship('RecetaMedica', back_populates='registro_mascota')


class AlergiaMascota(Base):
    __tablename__ = 'alergia_mascota'
    __table_args__ = (
        ForeignKeyConstraint(['alergia_especie_id'], ['alergia_especie.id'], name='alergia_mascota_ibfk_2'),
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='alergia_mascota_ibfk_1'),
        Index('alergia_especie_id', 'alergia_especie_id'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    severidad: Mapped[str] = mapped_column(String(20), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    alergia_especie_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    alergia_especie: Mapped[Optional['AlergiaEspecie']] = relationship('AlergiaEspecie', back_populates='alergia_mascota')
    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='alergia_mascota')


class CondicionSalud(Base):
    __tablename__ = 'condicion_salud'
    __table_args__ = (
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='condicion_salud_ibfk_1'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)

    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='condicion_salud')


class Consulta(Base):
    __tablename__ = 'consulta'
    __table_args__ = (
        ForeignKeyConstraint(['nutricionista_id'], ['nutricionista.id'], name='consulta_ibfk_2'),
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='consulta_ibfk_1'),
        Index('nutricionista_id', 'nutricionista_id'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    nutricionista_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    observaciones: Mapped[Optional[str]] = mapped_column(Text)
    recomendaciones: Mapped[Optional[str]] = mapped_column(Text)

    nutricionista: Mapped[Optional['Nutricionista']] = relationship('Nutricionista', back_populates='consulta')
    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='consulta')
    dieta: Mapped[list['Dieta']] = relationship('Dieta', back_populates='consulta')


class DescripcionAlergias(Base):
    __tablename__ = 'descripcion_alergias'
    __table_args__ = (
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='descripcion_alergias_ibfk_1'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    descripcion: Mapped[str] = mapped_column(Text, nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)

    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='descripcion_alergias')


class Pedido(Base):
    __tablename__ = 'pedido'
    __table_args__ = (
        ForeignKeyConstraint(['cliente_id'], ['cliente.id'], ondelete='CASCADE', name='pedido_ibfk_1'),
        ForeignKeyConstraint(['direccion_id'], ['direccion.id'], name='pedido_ibfk_2'),
        Index('cliente_id', 'cliente_id'),
        Index('direccion_id', 'direccion_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cliente_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    total: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    incluye_plato: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    estado: Mapped[str] = mapped_column(String(20), nullable=False)
    direccion_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    cliente: Mapped['Cliente'] = relationship('Cliente', back_populates='pedido')
    direccion: Mapped[Optional['Direccion']] = relationship('Direccion', back_populates='pedido')
    control_entrega: Mapped[list['ControlEntrega']] = relationship('ControlEntrega', back_populates='pedido')
    detalle_pedido: Mapped[list['DetallePedido']] = relationship('DetallePedido', back_populates='pedido')
    pago: Mapped[list['Pago']] = relationship('Pago', back_populates='pedido')
    pedido_especializado: Mapped[list['PedidoEspecializado']] = relationship('PedidoEspecializado', back_populates='pedido')


class PlatoPersonal(Base):
    __tablename__ = 'plato_personal'
    __table_args__ = (
        ForeignKeyConstraint(['plato_combinado_id'], ['plato_combinado.id'], name='plato_personal_ibfk_1'),
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='plato_personal_ibfk_2'),
        Index('plato_combinado_id', 'plato_combinado_id'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    plato_combinado_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)

    plato_combinado: Mapped['PlatoCombinado'] = relationship('PlatoCombinado', back_populates='plato_personal')
    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='plato_personal')


class PreferenciaAlimentaria(Base):
    __tablename__ = 'preferencia_alimentaria'
    __table_args__ = (
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='preferencia_alimentaria_ibfk_1'),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    descripcion: Mapped[Optional[str]] = mapped_column(Text)

    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='preferencia_alimentaria')


class ControlEntrega(Base):
    __tablename__ = 'control_entrega'
    __table_args__ = (
        ForeignKeyConstraint(['pedido_id'], ['pedido.id'], ondelete='CASCADE', name='control_entrega_ibfk_1'),
        ForeignKeyConstraint(['repartidor_id'], ['repartidor.id'], name='control_entrega_ibfk_2'),
        Index('pedido_id', 'pedido_id', unique=True),
        Index('repartidor_id', 'repartidor_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    pedido_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    fecha_entrega: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    confirmacion_entrega: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    repartidor_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    pedido: Mapped['Pedido'] = relationship('Pedido', back_populates='control_entrega')
    repartidor: Mapped[Optional['Repartidor']] = relationship('Repartidor', back_populates='control_entrega')


class DetallePedido(Base):
    __tablename__ = 'detalle_pedido'
    __table_args__ = (
        ForeignKeyConstraint(['pedido_id'], ['pedido.id'], ondelete='CASCADE', name='detalle_pedido_ibfk_1'),
        ForeignKeyConstraint(['plato_combinado_id'], ['plato_combinado.id'], name='detalle_pedido_ibfk_2'),
        Index('pedido_id', 'pedido_id'),
        Index('plato_combinado_id', 'plato_combinado_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    pedido_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    cantidad: Mapped[int] = mapped_column(Integer, nullable=False)
    subtotal: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    plato_combinado_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    pedido: Mapped['Pedido'] = relationship('Pedido', back_populates='detalle_pedido')
    plato_combinado: Mapped[Optional['PlatoCombinado']] = relationship('PlatoCombinado', back_populates='detalle_pedido')


class Dieta(Base):
    __tablename__ = 'dieta'
    __table_args__ = (
        ForeignKeyConstraint(['consulta_id'], ['consulta.id'], ondelete='CASCADE', name='dieta_ibfk_1'),
        Index('consulta_id', 'consulta_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    consulta_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    nombre: Mapped[str] = mapped_column(String(60), nullable=False)
    descripcion: Mapped[str] = mapped_column(Text, nullable=False)
    fecha_inicio: Mapped[datetime.date] = mapped_column(Date, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    fecha_fin: Mapped[Optional[datetime.date]] = mapped_column(Date)

    consulta: Mapped['Consulta'] = relationship('Consulta', back_populates='dieta')
    detalle_dieta: Mapped[list['DetalleDieta']] = relationship('DetalleDieta', back_populates='dieta')


class Pago(Base):
    __tablename__ = 'pago'
    __table_args__ = (
        ForeignKeyConstraint(['pasarela_pago_id'], ['pasarela_pago.id'], name='pago_ibfk_2'),
        ForeignKeyConstraint(['pedido_id'], ['pedido.id'], ondelete='CASCADE', name='pago_ibfk_1'),
        Index('pasarela_pago_id', 'pasarela_pago_id'),
        Index('pedido_id', 'pedido_id', unique=True)
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    pedido_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    monto: Mapped[decimal.Decimal] = mapped_column(DECIMAL(10, 2), nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    estado: Mapped[str] = mapped_column(String(20), nullable=False)
    pasarela_pago_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    referencia_pago: Mapped[Optional[str]] = mapped_column(String(60))

    pasarela_pago: Mapped[Optional['PasarelaPago']] = relationship('PasarelaPago', back_populates='pago')
    pedido: Mapped['Pedido'] = relationship('Pedido', back_populates='pago')


class PedidoEspecializado(Base):
    __tablename__ = 'pedido_especializado'
    __table_args__ = (
        ForeignKeyConstraint(['pedido_id'], ['pedido.id'], ondelete='CASCADE', name='pedido_especializado_ibfk_1'),
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], name='pedido_especializado_ibfk_2'),
        Index('pedido_id', 'pedido_id', unique=True),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    pedido_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    frecuencia_cantidad: Mapped[str] = mapped_column(Text, nullable=False)
    consulta_nutricionista: Mapped[int] = mapped_column(TINYINT(1), nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    registro_mascota_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    indicaciones_adicionales: Mapped[Optional[str]] = mapped_column(Text)
    objetivo_dieta: Mapped[Optional[str]] = mapped_column(Text)
    archivo_adicional: Mapped[Optional[str]] = mapped_column(Text)

    pedido: Mapped['Pedido'] = relationship('Pedido', back_populates='pedido_especializado')
    registro_mascota: Mapped[Optional['RegistroMascota']] = relationship('RegistroMascota', back_populates='pedido_especializado')
    receta_medica: Mapped[list['RecetaMedica']] = relationship('RecetaMedica', back_populates='pedido_especializado')


class DetalleDieta(Base):
    __tablename__ = 'detalle_dieta'
    __table_args__ = (
        ForeignKeyConstraint(['dieta_id'], ['dieta.id'], ondelete='CASCADE', name='detalle_dieta_ibfk_1'),
        ForeignKeyConstraint(['plato_combinado_id'], ['plato_combinado.id'], name='detalle_dieta_ibfk_2'),
        Index('dieta_id', 'dieta_id'),
        Index('plato_combinado_id', 'plato_combinado_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    dieta_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    instruccion: Mapped[str] = mapped_column(Text, nullable=False)
    frecuencia: Mapped[str] = mapped_column(String(40), nullable=False)
    plato_combinado_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))

    dieta: Mapped['Dieta'] = relationship('Dieta', back_populates='detalle_dieta')
    plato_combinado: Mapped[Optional['PlatoCombinado']] = relationship('PlatoCombinado', back_populates='detalle_dieta')


class RecetaMedica(Base):
    __tablename__ = 'receta_medica'
    __table_args__ = (
        ForeignKeyConstraint(['pedido_especializado_id'], ['pedido_especializado.id'], name='receta_medica_ibfk_2'),
        ForeignKeyConstraint(['registro_mascota_id'], ['registro_mascota.id'], ondelete='CASCADE', name='receta_medica_ibfk_1'),
        Index('pedido_especializado_id', 'pedido_especializado_id', unique=True),
        Index('registro_mascota_id', 'registro_mascota_id')
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    registro_mascota_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    fecha: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    estado_registro: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    pedido_especializado_id: Mapped[Optional[int]] = mapped_column(BIGINT(unsigned=True))
    archivo: Mapped[Optional[str]] = mapped_column(Text)

    pedido_especializado: Mapped[Optional['PedidoEspecializado']] = relationship('PedidoEspecializado', back_populates='receta_medica')
    registro_mascota: Mapped['RegistroMascota'] = relationship('RegistroMascota', back_populates='receta_medica')

class PlatoFavorito(Base):
    __tablename__ = 'plato_favorito'
    __table_args__ = (
        ForeignKeyConstraint(['cliente_id'], ['cliente.id'], ondelete='CASCADE', name='plato_favorito_ibfk_1'),
        ForeignKeyConstraint(['plato_combinado_id'], ['plato_combinado.id'], ondelete='CASCADE', name='plato_favorito_ibfk_2'),
        Index('cliente_id', 'cliente_id'),
        Index('plato_combinado_id', 'plato_combinado_id'),
        Index('cliente_plato_unique', 'cliente_id', 'plato_combinado_id', unique=True)
    )

    id: Mapped[int] = mapped_column(BIGINT(unsigned=True), primary_key=True)
    cliente_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    plato_combinado_id: Mapped[int] = mapped_column(BIGINT(unsigned=True), nullable=False)
    fecha_agregado: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)

    cliente: Mapped['Cliente'] = relationship('Cliente', back_populates='plato_favorito')
    plato_combinado: Mapped['PlatoCombinado'] = relationship('PlatoCombinado', back_populates='plato_favorito')
</file>

<file path="backend/package.json">
{
  "dependencies": {
    "react-native-safe-area-context": "^5.6.2"
  }
}
</file>

<file path="backend/README.md">
# PawPals Backend

Este proyecto es el backend de PawPals, construido con FastAPI.

## Requisitos
- Python 3.10+
- Instalar dependencias necesarias (FastAPI, SQLAlchemy, etc.)

## Instalación de dependencias

1. Abre una terminal en la carpeta `backend`.
2. Instala las dependencias necesarias:
   ```
   pip install fastapi uvicorn sqlalchemy
   ```
## Cómo correr el backend

1. Abre una terminal en la carpeta `backend`.
2. Ejecuta el servidor con:
   uvicorn main:app --host 0.0.0.0 --port 8000 --reload

3. El backend estará disponible en [http://localhost:8000](http://localhost:8000)

## Notas
- Los endpoints principales están definidos en los routers dentro de la carpeta `routers`.
- Los archivos estáticos se sirven desde `/static`.
- La base de datos se inicializa automáticamente al iniciar el backend.
</file>

<file path="backend/routers/admin/pedidos.py">
"""
RUTAS DEL ADMINISTRADOR – GESTIÓN DE PEDIDOS
----------------------------------------------
Permite al administrador consultar y controlar todos los pedidos registrados,
tanto normales como especializados.
Incluye:
- Listado general y filtrado por estado
- Consulta de detalles completos
- Cambio manual de estado del pedido
- Asignación y reasignación de pedidos a repartidores
- Revisión de historial y control de entregas
Notas:
- IDs en formato `str` (por BIGINT).
- Los estados válidos incluyen:
  ["pendiente", "en_preparacion", "asignado", 
   "en_camino", "entregado", "devuelto", "cancelado"]
  Descripción:
    pendiente: pedido recién creado, aún no procesado.
    en_preparacion: pedido confirmado y en proceso de preparación o empaquetado.
    asignado: pedido asignado a un repartidor (registro en control_entrega).
    en_camino: pedido en tránsito hacia el cliente.
    entregado: pedido recibido y confirmado por el cliente.
    devuelto: pedido regresado al almacén (no entregado o rechazado).
    cancelado: pedido anulado por el cliente o el administrador.
- El control de entrega se actualiza en la tabla `control_entrega`.
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from utils.db import get_db
from utils import keygen
from sqlalchemy.orm import joinedload, Session
from models import Pedido, ControlEntrega, Repartidor
router = APIRouter(prefix="/admin/pedidos", tags=["Pedidos (Administrador)"])

# ---------------------------------------------------------------------------
# GET /admin/pedidos
# ---------------------------------------------------------------------------
# Lista todos los pedidos registrados en el sistema.
# Permite aplicar filtros opcionales:
#   - estado: filtra por estado logístico del pedido.
#   - cliente_id: filtra los pedidos de un cliente específico.
#   - fecha_inicio / fecha_fin: acota el rango temporal de consulta.
# Retorna una lista de pedidos con id, cliente, fecha, total y estado.
@router.get("/")
def listar_pedidos_admin(
    estado: str | None = Query(None, description="Filtrar por estado del pedido"),
    cliente_id: str | None = Query(None, description="Filtrar por ID de cliente"),
    fecha_inicio: str | None = Query(None, description="Fecha inicial en formato YYYY-MM-DD"),
    fecha_fin: str | None = Query(None, description="Fecha final en formato YYYY-MM-DD"),
    db: Session = Depends(get_db),
):
    query = db.query(Pedido).options(joinedload(Pedido.cliente))
    if estado:
        query = query.filter(Pedido.estado == estado)
    if cliente_id:
        query = query.filter(Pedido.cliente_id == cliente_id)
    if fecha_inicio:
        try:
            fecha_inicio_dt = datetime.strptime(fecha_inicio, "%Y-%m-%d")
            query = query.filter(Pedido.fecha >= fecha_inicio_dt)
        except ValueError:
            raise HTTPException(status_code=400, detail="Formato inválido en fecha_inicio (usar YYYY-MM-DD)")
    if fecha_fin:
        try:
            fecha_fin_dt = datetime.strptime(fecha_fin, "%Y-%m-%d")
            query = query.filter(Pedido.fecha <= fecha_fin_dt)
        except ValueError:
            raise HTTPException(status_code=400, detail="Formato inválido en fecha_fin (usar YYYY-MM-DD)")
    pedidos = query.order_by(Pedido.fecha.desc()).all()
    if not pedidos:
        return {"mensaje": "No se encontraron pedidos con los filtros aplicados."}
    resultado = [
        {
            "id": str(p.id),
            "cliente": p.cliente.nombre if p.cliente else None,
            "fecha": p.fecha.isoformat(),
            "total": float(p.total),
            "estado": p.estado,
        }
        for p in pedidos
    ]
    return {"total": len(resultado), "pedidos": resultado}


# ---------------------------------------------------------------------------
# GET /admin/pedidos/{pedido_id}
# ---------------------------------------------------------------------------
# Devuelve los detalles completos de un pedido específico.
# Incluye:
# - Datos del cliente y su contacto
# - Dirección de entrega
# - Lista de platos con cantidades y subtotales
# - Total y estado del pedido
# - Información del pago (monto, fecha, estado, pasarela)
# Si el pedido no existe, retorna error 404.
@router.get("/{pedido_id}")
def obtener_detalle_pedido_admin(pedido_id: str, db: Session = Depends(get_db)):
    pedido = (
        db.query(Pedido)
        .options(
            joinedload(Pedido.cliente),
            joinedload(Pedido.direccion),
            joinedload(Pedido.detalle_pedido).joinedload(DetallePedido.plato_combinado),
            joinedload(Pedido.pago),
        )
        .filter(Pedido.id == pedido_id)
        .first()
    )
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    cliente_info = None
    if pedido.cliente:
        cliente_info = {
            "id": str(pedido.cliente.id),
            "nombre": pedido.cliente.nombre,
            "telefono": pedido.cliente.telefono,
        }
    direccion_info = None
    if pedido.direccion:
        direccion_info = {
            "id": str(pedido.direccion.id),
            "nombre": pedido.direccion.nombre,
            "referencia": pedido.direccion.referencia,
            "latitud": float(pedido.direccion.latitud),
            "longitud": float(pedido.direccion.longitud),
        }
    platos_info = []
    for det in pedido.detalle_pedido:
        platos_info.append({
            "id": str(det.id),
            "plato": det.plato_combinado.nombre if det.plato_combinado else None,
            "cantidad": det.cantidad,
            "subtotal": float(det.subtotal),
        })
    pago_info = None
    if pedido.pago and len(pedido.pago) > 0:
        p = pedido.pago[0]
        pago_info = {
            "id": str(p.id),
            "monto": float(p.monto),
            "fecha": p.fecha.isoformat(),
            "estado": p.estado,
            "referencia_pago": p.referencia_pago,
            "pasarela": p.pasarela_pago.nombre if p.pasarela_pago else None,
        }
    respuesta = {
        "pedido": {
            "id": str(pedido.id),
            "fecha": pedido.fecha.isoformat(),
            "total": float(pedido.total),
            "incluye_plato": bool(pedido.incluye_plato),
            "estado": pedido.estado,
        },
        "cliente": cliente_info,
        "direccion": direccion_info,
        "platos": platos_info,
        "pago": pago_info,
    }
    return respuesta

# ---------------------------------------------------------------------------
# PUT /admin/pedidos/{pedido_id}/estado
# ---------------------------------------------------------------------------
# Cambia manualmente el estado de un pedido.
# Valida que la transición sea coherente con el flujo logístico:
#   pendiente → en_preparacion / cancelado
#   en_preparacion → asignado / cancelado
#   asignado → en_camino / cancelado
#   en_camino → entregado / devuelto
#   devuelto → asignado / cancelado
# Los estados "entregado" y "cancelado" son finales (no admiten cambios).
@router.put("/{pedido_id}/estado")
def actualizar_estado_pedido(
    pedido_id: str,
    nuevo_estado: str,
    db: Session = Depends(get_db)
):
    """
    Cambia el estado de un pedido de forma manual.
    Solo se permiten transiciones válidas dentro del flujo logístico.
    """
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    estado_actual = pedido.estado
    transiciones_validas = {
        "pendiente": ["en_preparacion", "cancelado"],
        "en_preparacion": ["asignado", "cancelado"],
        "asignado": ["en_camino", "cancelado"],
        "en_camino": ["entregado", "devuelto"],
        "devuelto": ["asignado", "cancelado"],
        "entregado": [],
        "cancelado": [],
    }
    if estado_actual not in transiciones_validas:
        raise HTTPException(status_code=400, detail=f"Estado actual desconocido: {estado_actual}")

    if nuevo_estado not in transiciones_validas[estado_actual]:
        raise HTTPException(
            status_code=400,
            detail=f"No se puede cambiar de '{estado_actual}' a '{nuevo_estado}'."
        )
    pedido.estado = nuevo_estado
    db.commit()
    return {
        "mensaje": f"Estado del pedido actualizado correctamente de '{estado_actual}' a '{nuevo_estado}'.",
        "pedido": {
            "id": str(pedido.id),
            "estado_anterior": estado_actual,
            "estado_actual": nuevo_estado,
        },
    }

# ---------------------------------------------------------------------------
# PUT /admin/pedidos/{pedido_id}/asignar/{repartidor_id}
# ---------------------------------------------------------------------------
# Asigna o reasigna un pedido a un repartidor.
# - Si no existe registro previo en `control_entrega`, lo crea.
# - Si ya está asignado, actualiza el repartidor y la fecha de asignación.
# - Cambia el estado del pedido a "asignado" (si no lo estaba).
# - Marca la entrega como pendiente (`confirmacion_entrega = 0`).
@router.put("/{pedido_id}/asignar/{repartidor_id}")
def asignar_pedido_a_repartidor(
    pedido_id: str,
    repartidor_id: str,
    db: Session = Depends(get_db)
):
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    repartidor = db.query(Repartidor).filter(Repartidor.id == repartidor_id).first()
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    control = db.query(ControlEntrega).filter(ControlEntrega.pedido_id == pedido_id).first()
    if control:
        control.repartidor_id = repartidor_id
        control.fecha_entrega = datetime.now()  
        control.confirmacion_entrega = 0       
        mensaje = "Pedido reasignado a un nuevo repartidor."
    else:
        control = ControlEntrega(
            id=keygen.generate_uint64_key(),
            pedido_id=pedido_id,
            fecha_entrega=datetime.now(),
            confirmacion_entrega=0,
            repartidor_id=repartidor_id,
        )
        db.add(control)
        mensaje = "Pedido asignado correctamente."
    if pedido.estado not in ["asignado", "en_camino", "entregado"]:
        pedido.estado = "asignado"
    db.commit()
    return {
        "mensaje": mensaje,
        "pedido": {
            "id": str(pedido.id),
            "estado": pedido.estado,
        },
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
        },
    }

# ---------------------------------------------------------------------------
# GET /admin/pedidos/asignados
# ---------------------------------------------------------------------------
# Lista todos los pedidos con un repartidor asignado (registro en `control_entrega`).
# Muestra:
# - ID del pedido, fecha y estado
# - Repartidor asignado (id, nombre, teléfono)
# - Fecha de asignación
# - Confirmación de entrega (True / False)
# Retorna una lista consolidada de entregas en curso o finalizadas.
@router.get("/asignados")
def listar_pedidos_asignados(db: Session = Depends(get_db)):
    asignaciones = (
        db.query(ControlEntrega)
        .options(
            joinedload(ControlEntrega.pedido),
            joinedload(ControlEntrega.repartidor),
        )
        .all()
    )
    if not asignaciones:
        return {"mensaje": "No hay pedidos asignados actualmente."}
    resultado = []
    for ctrl in asignaciones:
        pedido = ctrl.pedido
        repartidor = ctrl.repartidor
        resultado.append({
            "pedido_id": str(pedido.id) if pedido else None,
            "fecha_pedido": pedido.fecha.isoformat() if pedido else None,
            "estado_pedido": pedido.estado if pedido else None,
            "total": float(pedido.total) if pedido else None,
            "repartidor": {
                "id": str(repartidor.id) if repartidor else None,
                "nombre": repartidor.nombre if repartidor else None,
                "telefono": repartidor.telefono if repartidor else None,
            },
            "fecha_asignacion": ctrl.fecha_entrega.isoformat(),
            "confirmacion_entrega": bool(ctrl.confirmacion_entrega),
        })
    return {"total": len(resultado), "asignaciones": resultado}


# ---------------------------------------------------------------------------
# GET /admin/pedidos/especializados
# ---------------------------------------------------------------------------
# Lista todos los pedidos especializados del sistema.
# Incluye:
# - ID, fecha y estado del pedido
# - Cliente asociado (nombre y contacto)
# - Mascota vinculada (nombre, especie)
# - Indicador de consulta con nutricionista
# - Frecuencia y estado del registro especializado
# Permite al administrador revisar qué pedidos están en evaluación o seguimiento nutricional.
@router.get("/especializados")
def listar_pedidos_especializados_admin(db: Session = Depends(get_db)):
    especializados = (
        db.query(PedidoEspecializado)
        .options(
            joinedload(PedidoEspecializado.pedido)
            .joinedload(Pedido.cliente),
            joinedload(PedidoEspecializado.registro_mascota),
        )
        .all()
    )
    if not especializados:
        return {"mensaje": "No se encontraron pedidos especializados."}
    resultado = []
    for esp in especializados:
        pedido = esp.pedido
        cliente = pedido.cliente if pedido else None
        mascota = esp.registro_mascota
        resultado.append({
            "pedido_id": str(pedido.id) if pedido else None,
            "fecha": pedido.fecha.isoformat() if pedido else None,
            "estado_pedido": pedido.estado if pedido else None,
            "cliente": {
                "id": str(cliente.id) if cliente else None,
                "nombre": cliente.nombre if cliente else None,
                "telefono": cliente.telefono if cliente else None,
            } if cliente else None,
            "mascota": {
                "id": str(mascota.id) if mascota else None,
                "nombre": mascota.nombre if mascota else None,
                "especie": mascota.especie.nombre if mascota.especie else None,
            } if mascota else None,
            "consulta_nutricionista": bool(esp.consulta_nutricionista),
            "frecuencia_cantidad": esp.frecuencia_cantidad,
            "estado_registro": esp.estado_registro,
        })
    return {"total": len(resultado), "pedidos_especializados": resultado}


# ---------------------------------------------------------------------------
# GET /admin/pedidos/{pedido_id}/entrega
# ---------------------------------------------------------------------------
# Muestra la información de control de entrega asociada a un pedido.
# Incluye:
# - ID, fecha y estado del pedido
# - Repartidor asignado (nombre, contacto)
# - Fecha de asignación de entrega
# - Confirmación de entrega (True / False)
# Si el pedido no tiene registro en `control_entrega`, devuelve error 404.
@router.get("/{pedido_id}/entrega")
def obtener_control_entrega(pedido_id: str, db: Session = Depends(get_db)):
    control = (
        db.query(ControlEntrega)
        .options(
            joinedload(ControlEntrega.repartidor),
            joinedload(ControlEntrega.pedido),
        )
        .filter(ControlEntrega.pedido_id == pedido_id)
        .first()
    )
    if not control:
        raise HTTPException(status_code=404, detail="No se encontró información de entrega para este pedido.")
    pedido = control.pedido
    repartidor = control.repartidor
    respuesta = {
        "pedido": {
            "id": str(pedido.id) if pedido else None,
            "fecha": pedido.fecha.isoformat() if pedido else None,
            "estado": pedido.estado if pedido else None,
        } if pedido else None,
        "repartidor": {
            "id": str(repartidor.id) if repartidor else None,
            "nombre": repartidor.nombre if repartidor else None,
            "telefono": repartidor.telefono if repartidor else None,
        } if repartidor else None,
        "control_entrega": {
            "id": str(control.id),
            "fecha_asignacion": control.fecha_entrega.isoformat(),
            "confirmacion_entrega": bool(control.confirmacion_entrega),
        },
    }
    return respuesta
</file>

<file path="backend/routers/admin/platos.py">
"""
RUTAS DEL ADMINISTRADOR – GESTIÓN DE PLATOS
--------------------------------------------
Permite al administrador crear, editar, publicar y eliminar platos combinados.

Incluye funcionalidades para:
- Crear y actualizar platos
- Cambiar su estado de publicación (activo/inactivo)
- Asociar platos a categorías y especies
- Asignar etiquetas (por ejemplo: “bajo en grasa”, “sin gluten”)

Notas:
- IDs como `str` (por BIGINT).
- Las imágenes se almacenan en utils.globals.PLATO.
- Si no se proporciona imagen, se usa PLATO/default.png.
- Solo los administradores pueden acceder a estas rutas.
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile
from utils import keygen, globals

router = APIRouter(prefix="/admin/platos", tags=["Platos (Administrador)"])


# ---------------------------------------------------------------------------
# POST /admin/platos
# ---------------------------------------------------------------------------
# Crea un nuevo plato combinado.
# Campos: nombre, precio, categoria_id, especie_id, descripcion, publicado, incluye_plato, es_crudo.
# Se puede subir imagen opcional.
@router.post("/")
def crear_plato(imagen: UploadFile = None):
    pass


# ---------------------------------------------------------------------------
# GET /admin/platos
# ---------------------------------------------------------------------------
# Lista todos los platos registrados (activos e inactivos).
# Incluye información de categoría, especie y estado.
@router.get("/")
def listar_platos_admin():
    pass


# ---------------------------------------------------------------------------
# GET /admin/platos/{plato_id}
# ---------------------------------------------------------------------------
# Devuelve los detalles completos de un plato específico.
@router.get("/{plato_id}")
def obtener_detalle_plato_admin(plato_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /admin/platos/{plato_id}
# ---------------------------------------------------------------------------
# Edita los datos de un plato existente.
# Permite cambiar nombre, descripción, imagen, categoría, especie, etc.
@router.put("/{plato_id}")
def editar_plato(plato_id: str, imagen: UploadFile = None):
    pass

# ---------------------------------------------------------------------------
# DELETE /admin/platos/{plato_id}
# ---------------------------------------------------------------------------
# Elimina (o marca como inactivo) un plato.
# Si tiene pedidos asociados, no se borra físicamente.
@router.delete("/{plato_id}")
def eliminar_plato(plato_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /admin/platos/{plato_id}/publicar
# ---------------------------------------------------------------------------
# Cambia el estado de publicación de un plato (visible/no visible al cliente).
@router.put("/{plato_id}/publicar")
def cambiar_estado_publicacion(plato_id: str):
    pass


# ---------------------------------------------------------------------------
# POST /admin/platos/{plato_id}/etiquetas
# ---------------------------------------------------------------------------
# Asigna una o más etiquetas a un plato.
# Campos: lista de id_etiqueta.
@router.post("/{plato_id}/etiquetas")
def asignar_etiquetas(plato_id: str):
    pass


# ---------------------------------------------------------------------------
# DELETE /admin/platos/{plato_id}/etiquetas
# ---------------------------------------------------------------------------
# Elimina etiquetas asociadas a un plato.
# Campos: lista de id_etiqueta.
@router.delete("/{plato_id}/etiquetas")
def eliminar_etiquetas(plato_id: str):
    pass
</file>

<file path="backend/routers/admin/repartidores.py">
"""
RUTAS DEL ADMINISTRADOR – GESTIÓN DE REPARTIDORES
---------------------------------------------------
Permite al administrador crear y administrar las cuentas de repartidores,
asignarles pedidos y controlar su estado de registro.
Incluye:
- Creación de cuentas de repartidor
- Consulta general de repartidores activos/inactivos
- Actualización de datos (nombre, teléfono, estado)
- Desactivación de cuentas
- Visualización de pedidos asignados a cada repartidor
Notas:
- IDs en formato `str` (por BIGINT).
- Claves generadas con utils.keygen.generate_uint64_key().
- Solo accesible por administradores.
"""

from fastapi import APIRouter, Depends, HTTPException, Query, Body
from sqlalchemy.orm import Session, joinedload
from utils import keygen
from utils.db import get_db
from models import CuentaUsuario, Repartidor, UsuarioRol, Rol
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

router = APIRouter(prefix="/admin/repartidores", tags=["Repartidores (Administrador)"])

# ---------------------------------------------------------------------------
# POST /admin/repartidores
# ---------------------------------------------------------------------------
# Crea una nueva cuenta de repartidor.
# Campos requeridos:
# - nombre (str): nombre completo del repartidor.
# - telefono (str): número de contacto.
# - correo (EmailStr): correo electrónico para su cuenta.
# - contrasena (str): contraseña inicial.
# Opcional:
# - estado_registro (str): estado del registro (A=Activo, I=Inactivo). Default: 'A'
# Operaciones realizadas:
# 1. Verifica que el correo no esté en uso.
# 2. Crea una cuenta en `cuenta_usuario`.
# 3. Crea el registro de `repartidor`.
# 4. Asigna el rol de repartidor en `usuario_rol`.
# Retorna:
# - ID del repartidor creado y resumen de su cuenta.
@router.post("/")
def crear_repartidor(
    nombre: str = Query(..., description="Nombre completo del repartidor"),
    telefono: str = Query(..., description="Número de contacto del repartidor"),
    correo: EmailStr = Query(..., description="Correo electrónico del repartidor"),
    contrasena: str = Query(..., description="Contraseña inicial del repartidor"),
    estado_registro: Optional[str] = Query("A", description="Estado del registro (A=Activo, I=Inactivo)"),
    db: Session = Depends(get_db),
):
    correo_existente = db.query(CuentaUsuario).filter(
        CuentaUsuario.correo_electronico == correo
    ).first()
    if correo_existente:
        raise HTTPException(status_code=400, detail="El correo electrónico ya está registrado.")
    cuenta_id = keygen.generate_uint64_key()
    cuenta = CuentaUsuario(
        id=cuenta_id,
        correo_electronico=correo,
        contrasena=contrasena,
        nombre_usuario=nombre,
        estado_registro=estado_registro,
        ultimo_acceso=None
    )
    db.add(cuenta)
    db.flush()  
    repartidor_id = keygen.generate_uint64_key()
    repartidor = Repartidor(
        id=repartidor_id,
        cuenta_usuario_id=cuenta_id,
        nombre=nombre,
        telefono=telefono,
        estado_registro=estado_registro
    )
    db.add(repartidor)
    rol_repartidor = db.query(Rol).filter(Rol.nombre == "repartidor").first()
    if not rol_repartidor:
        raise HTTPException(status_code=404, detail="Rol 'repartidor' no definido en la base de datos.")
    usuario_rol = UsuarioRol(
        id=keygen.generate_uint64_key(),
        cuenta_usuario_id=cuenta_id,
        rol_id=rol_repartidor.id,
        estado_registro="A"
    )
    db.add(usuario_rol)
    db.commit()
    return {
        "mensaje": "Repartidor creado exitosamente.",
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
            "estado_registro": repartidor.estado_registro,
        },
        "cuenta_usuario": {
            "id": str(cuenta.id),
            "correo": cuenta.correo_electronico,
            "nombre_usuario": cuenta.nombre_usuario,
        },
    }

# ---------------------------------------------------------------------------
# GET /admin/repartidores
# ---------------------------------------------------------------------------
# Lista todos los repartidores registrados (activos o inactivos).
# Permite filtrar por estado_registro (A/I) o nombre parcial.
# Ejemplo de uso:
#   /admin/repartidores?estado=A
#   /admin/repartidores?nombre=juan
# Retorna una lista con los repartidores y su información básica.
@router.get("/")
def listar_repartidores(
    estado: Optional[str] = Query(None, description="Filtrar por estado del registro (A=activo, I=inactivo)"),
    nombre: Optional[str] = Query(None, description="Filtrar por coincidencia parcial en nombre"),
    db: Session = Depends(get_db),
):
    query = (
        db.query(Repartidor)
        .join(Repartidor.cuenta_usuario)
        .options(
            joinedload(Repartidor.cuenta_usuario)
        )
    )
    if estado:
        if estado not in ["A", "I"]:
            raise HTTPException(status_code=400, detail="El estado debe ser 'A' (activo) o 'I' (inactivo).")
        query = query.filter(Repartidor.estado_registro == estado)
    if nombre:
        query = query.filter(Repartidor.nombre.ilike(f"%{nombre}%"))
    repartidores = query.order_by(Repartidor.nombre.asc()).all()
    if not repartidores:
        return {"mensaje": "No se encontraron repartidores con los filtros aplicados."}
    resultado = []
    for r in repartidores:
        cuenta = r.cuenta_usuario
        resultado.append({
            "id": str(r.id),
            "nombre": r.nombre,
            "telefono": r.telefono,
            "estado_registro": r.estado_registro,
            "correo": cuenta.correo_electronico if cuenta else None,
            "ultimo_acceso": cuenta.ultimo_acceso.isoformat() if cuenta and cuenta.ultimo_acceso else None,
        })
    return {"total": len(resultado), "repartidores": resultado}


# ---------------------------------------------------------------------------
# GET /admin/repartidores/{repartidor_id}
# ---------------------------------------------------------------------------
# Obtiene la información completa de un repartidor:
# - Datos personales (nombre, teléfono, estado)
# - Cuenta asociada (correo, último acceso)
# - Pedidos asignados (control_entrega)
# Si no existe el repartidor, retorna error 404.
from sqlalchemy.orm import joinedload
@router.get("/{repartidor_id}")
def obtener_detalle_repartidor(
    repartidor_id: str,
    db: Session = Depends(get_db),
):
    repartidor = (
        db.query(Repartidor)
        .options(
            joinedload(Repartidor.cuenta_usuario),
            joinedload(Repartidor.control_entrega)
            .joinedload(ControlEntrega.pedido)
            .joinedload(Pedido.cliente)
        )
        .filter(Repartidor.id == repartidor_id)
        .first()
    )
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    cuenta = repartidor.cuenta_usuario
    cuenta_info = None
    if cuenta:
        cuenta_info = {
            "id": str(cuenta.id),
            "correo": cuenta.correo_electronico,
            "ultimo_acceso": cuenta.ultimo_acceso.isoformat() if cuenta.ultimo_acceso else None,
            "estado_registro": cuenta.estado_registro,
        }
    pedidos_info = []
    for c in repartidor.control_entrega:
        pedido = c.pedido
        cliente = pedido.cliente if pedido else None
        pedidos_info.append({
            "pedido_id": str(pedido.id) if pedido else None,
            "fecha_pedido": pedido.fecha.isoformat() if pedido else None,
            "estado_pedido": pedido.estado if pedido else None,
            "confirmacion_entrega": bool(c.confirmacion_entrega),
            "cliente": {
                "id": str(cliente.id) if cliente else None,
                "nombre": cliente.nombre if cliente else None,
                "telefono": cliente.telefono if cliente else None,
            } if cliente else None,
        })
    respuesta = {
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
            "estado_registro": repartidor.estado_registro,
        },
        "cuenta_usuario": cuenta_info,
        "pedidos_asignados": pedidos_info,
        "total_pedidos_asignados": len(pedidos_info),
    }
    return respuesta


# ---------------------------------------------------------------------------
# PUT /admin/repartidores/{repartidor_id}
# ---------------------------------------------------------------------------
# Actualiza los datos de un repartidor:
# - nombre
# - teléfono
# - estado_registro (A=activo, I=inactivo)
# Si no se encuentra el repartidor, devuelve error 404.
# Si no se especifica ningún campo válido, devuelve error 400.
@router.put("/{repartidor_id}")
def actualizar_repartidor(
    repartidor_id: str,
    nombre: Optional[str] = Body(None, description="Nuevo nombre del repartidor"),
    telefono: Optional[str] = Body(None, description="Nuevo número de teléfono"),
    estado_registro: Optional[str] = Body(None, description="Nuevo estado del registro (A/I)"),
    db: Session = Depends(get_db),
):
    repartidor = (
        db.query(Repartidor)
        .options(joinedload(Repartidor.cuenta_usuario))
        .filter(Repartidor.id == repartidor_id)
        .first()
    )
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    if not any([nombre, telefono, estado_registro]):
        raise HTTPException(status_code=400, detail="Debe especificar al menos un campo para actualizar.")
    if estado_registro and estado_registro not in ["A", "I"]:
        raise HTTPException(status_code=400, detail="El estado_registro debe ser 'A' (activo) o 'I' (inactivo).")
    if nombre:
        repartidor.nombre = nombre
        if repartidor.cuenta_usuario:
            repartidor.cuenta_usuario.nombre_usuario = nombre  # sincroniza también en la cuenta
    if telefono:
        repartidor.telefono = telefono
    if estado_registro:
        repartidor.estado_registro = estado_registro
        if repartidor.cuenta_usuario:
            repartidor.cuenta_usuario.estado_registro = estado_registro

    db.commit()
    db.refresh(repartidor)
    return {
        "mensaje": "Datos del repartidor actualizados correctamente.",
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
            "estado_registro": repartidor.estado_registro,
        },
        "cuenta_usuario": {
            "id": str(repartidor.cuenta_usuario.id) if repartidor.cuenta_usuario else None,
            "correo": repartidor.cuenta_usuario.correo_electronico if repartidor.cuenta_usuario else None,
            "estado_registro": repartidor.cuenta_usuario.estado_registro if repartidor.cuenta_usuario else None,
        } if repartidor.cuenta_usuario else None,
    }

# ---------------------------------------------------------------------------
# PUT /admin/repartidores/{repartidor_id}/estado
# ---------------------------------------------------------------------------
# Activa o desactiva una cuenta de repartidor.
# Cambia el campo `estado_registro` (A = activo, I = inactivo)
# tanto en la tabla `repartidor` como en la `cuenta_usuario`.
@router.put("/{repartidor_id}/estado")
def cambiar_estado_repartidor(
    repartidor_id: str,
    nuevo_estado: str = Body(..., description="Nuevo estado del registro (A=activo, I=inactivo)"),
    db: Session = Depends(get_db),
):
    repartidor = (
        db.query(Repartidor)
        .options(joinedload(Repartidor.cuenta_usuario))
        .filter(Repartidor.id == repartidor_id)
        .first()
    )
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    if nuevo_estado not in ["A", "I"]:
        raise HTTPException(status_code=400, detail="El estado debe ser 'A' (activo) o 'I' (inactivo).")
    if repartidor.estado_registro == nuevo_estado:
        return {
            "mensaje": f"El repartidor ya se encuentra en estado '{nuevo_estado}'.",
            "repartidor": {
                "id": str(repartidor.id),
                "nombre": repartidor.nombre,
                "telefono": repartidor.telefono,
                "estado_registro": repartidor.estado_registro,
            },
        }
    repartidor.estado_registro = nuevo_estado
    if repartidor.cuenta_usuario:
        repartidor.cuenta_usuario.estado_registro = nuevo_estado
    db.commit()
    db.refresh(repartidor)
    estado_texto = "activado" if nuevo_estado == "A" else "desactivado"
    return {
        "mensaje": f"Repartidor {estado_texto} correctamente.",
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
            "estado_registro": repartidor.estado_registro,
        },
        "cuenta_usuario": {
            "id": str(repartidor.cuenta_usuario.id) if repartidor.cuenta_usuario else None,
            "correo": repartidor.cuenta_usuario.correo_electronico if repartidor.cuenta_usuario else None,
            "estado_registro": repartidor.cuenta_usuario.estado_registro if repartidor.cuenta_usuario else None,
        } if repartidor.cuenta_usuario else None,
    }

# ---------------------------------------------------------------------------
# GET /admin/repartidores/{repartidor_id}/pedidos
# ---------------------------------------------------------------------------
# Lista los pedidos asignados a un repartidor específico.
# Incluye:
# - ID del pedido
# - Fecha y estado del pedido
# - Total
# - Confirmación de entrega
# - Cliente asociado (nombre, teléfono)
# Si el repartidor no existe o no tiene pedidos asignados, retorna 404 o mensaje vacío.
from sqlalchemy.orm import joinedload
@router.get("/{repartidor_id}/pedidos")
def listar_pedidos_repartidor(
    repartidor_id: str,
    db: Session = Depends(get_db),
):
    repartidor = db.query(Repartidor).filter(Repartidor.id == repartidor_id).first()
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    entregas = (
        db.query(ControlEntrega)
        .options(
            joinedload(ControlEntrega.pedido).joinedload(Pedido.cliente)
        )
        .filter(ControlEntrega.repartidor_id == repartidor_id)
        .order_by(Pedido.fecha.desc())
        .all()
    )
    if not entregas:
        return {"mensaje": "El repartidor no tiene pedidos asignados actualmente."}
    resultado = []
    for ctrl in entregas:
        pedido = ctrl.pedido
        cliente = pedido.cliente if pedido else None
        resultado.append({
            "pedido_id": str(pedido.id) if pedido else None,
            "fecha_pedido": pedido.fecha.isoformat() if pedido else None,
            "estado_pedido": pedido.estado if pedido else None,
            "total": float(pedido.total) if pedido else None,
            "confirmacion_entrega": bool(ctrl.confirmacion_entrega),
            "cliente": {
                "id": str(cliente.id) if cliente else None,
                "nombre": cliente.nombre if cliente else None,
                "telefono": cliente.telefono if cliente else None,
            } if cliente else None,
        })
    return {
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
            "estado_registro": repartidor.estado_registro,
        },
        "total_pedidos": len(resultado),
        "pedidos": resultado,
    }
</file>

<file path="backend/routers/admin/subscripciones.py">
"""
RUTAS DEL ADMINISTRADOR – GESTIÓN DE SUBSCRIPCIONES
----------------------------------------------------
Permite al administrador administrar los planes de membresía o suscripción
que pueden adquirir los clientes.

Incluye:
- Creación de nuevos planes de suscripción
- Actualización de planes existentes
- Activación o desactivación de planes
- Consulta general o individual de planes

Notas:
- IDs en formato `str` (por BIGINT).
- Claves generadas con utils.keygen.generate_uint64_key().
- Campo `estado_registro`: "A" = activo, "I" = inactivo.
- Campos de modelo: nombre, duración (en días), precio, descripción, beneficios.
"""

from fastapi import APIRouter, Depends, HTTPException
from utils import keygen

router = APIRouter(prefix="/admin/subscripciones", tags=["Subscripciones (Administrador)"])


# ---------------------------------------------------------------------------
# POST /admin/subscripciones
# ---------------------------------------------------------------------------
# Crea un nuevo plan de suscripción.
# Campos requeridos:
#   - nombre
#   - duracion (días)
#   - precio
#   - descripcion (opcional)
#   - beneficios (opcional)
@router.post("/")
def crear_subscripcion():
    pass


# ---------------------------------------------------------------------------
# GET /admin/subscripciones
# ---------------------------------------------------------------------------
# Lista todas las suscripciones disponibles en el sistema.
# Puede filtrarse por estado (activas/inactivas).
@router.get("/")
def listar_subscripciones_admin(estado: str = None):
    pass


# ---------------------------------------------------------------------------
# GET /admin/subscripciones/{subscripcion_id}
# ---------------------------------------------------------------------------
# Obtiene los detalles de un plan de suscripción específico.
@router.get("/{subscripcion_id}")
def obtener_detalle_subscripcion(subscripcion_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /admin/subscripciones/{subscripcion_id}
# ---------------------------------------------------------------------------
# Actualiza los datos de un plan de suscripción.
# Permite modificar nombre, precio, duración, descripción, beneficios.
@router.put("/{subscripcion_id}")
def actualizar_subscripcion(subscripcion_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /admin/subscripciones/{subscripcion_id}/estado
# ---------------------------------------------------------------------------
# Activa o desactiva un plan de suscripción.
# Cambia el valor de `estado_registro` (A o I).
@router.put("/{subscripcion_id}/estado")
def cambiar_estado_subscripcion(subscripcion_id: str):
    pass
</file>

<file path="backend/routers/auth.py">
"""
RUTAS DE AUTENTICACIÓN Y GESTIÓN DE SESIONES
"""

from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from utils.db import get_db
from pydantic import BaseModel
from utils import keygen, security, token_manager
from models import CuentaUsuario, Cliente, UsuarioRol, Rol
from datetime import datetime

router = APIRouter(prefix="/auth", tags=["Autenticación"])

class RegisterRequest(BaseModel):
    nombre: str
    correo: str
    contrasena: str

class LoginRequest(BaseModel):
    correo: str
    contrasena: str

# ---------------------------------------------------------------------------
# POST /auth/register
# ---------------------------------------------------------------------------
@router.post("/register")
def register_user(data: RegisterRequest, db: Session = Depends(get_db)):
    """
    Registra un nuevo usuario con rol de cliente.
    """
    nombre = data.nombre
    correo = data.correo
    contrasena = data.contrasena

    print(f"🔥 Recibiendo registro: {nombre}, {correo}")

    # Verificar si el correo ya existe
    existe = db.query(CuentaUsuario).filter(
        CuentaUsuario.correo_electronico == correo
    ).first()
    
    if existe:
        print(f"❌ El correo {correo} ya está registrado")
        raise HTTPException(status_code=400, detail="El correo ya está registrado.")

    try:
        # Generar ID único
        user_id = keygen.generate_uint64_key()
        print(f"✅ ID generado: {user_id}")

        # Hashear contraseña
        hashed_pass = security.get_password_hash(contrasena)
        print(f"✅ Contraseña hasheada")

        # Crear cuenta de usuario
        nueva_cuenta = CuentaUsuario(
            id=user_id,
            correo_electronico=correo,
            nombre_usuario=nombre,
            contrasena=hashed_pass,
            estado_registro="A",
        )
        db.add(nueva_cuenta)
        db.flush()
        print(f"✅ Cuenta de usuario creada")

        # ✅ BUSCAR ROL DE CLIENTE (id = 2)
        rol_cliente = db.query(Rol).filter(Rol.id == 2).first()
        if not rol_cliente:
            print(f"❌ ERROR: No existe el rol con id=2 (cliente)")
            raise HTTPException(status_code=500, detail="Rol de cliente no configurado en el sistema.")

        # Asignar rol de cliente (id = 2)
        usuario_rol = UsuarioRol(
            id=keygen.generate_uint64_key(),
            cuenta_usuario_id=user_id,
            rol_id=2,
            estado_registro="A",
        )
        db.add(usuario_rol)
        print(f"✅ Rol asignado")

        # Crear perfil de cliente
        nuevo_cliente = Cliente(
            id=keygen.generate_uint64_key(),
            cuenta_usuario_id=user_id,
            nombre=nombre,
            estado_registro="A",
        )
        db.add(nuevo_cliente)
        print(f"✅ Perfil de cliente creado")

        # Guardar todo
        db.commit()
        print(f"✅ Registro completado exitosamente")

        # Generar token
        token = token_manager.generar_token(user_id, 2)

        return {
            "mensaje": "Cuenta creada exitosamente.",
            "token": token,
            "usuario": {
                "cuenta_id": str(user_id),
                "cliente_id": str(nuevo_cliente.id),
                "nombre": nombre,
                "correo": correo,
                "rol_id": 2,
            }
        }

    except Exception as e:
        db.rollback()
        print(f"❌ ERROR EN REGISTRO: {str(e)}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=500, 
            detail=f"Error al crear la cuenta: {str(e)}"
        )

# ---------------------------------------------------------------------------
# POST /auth/login
# ---------------------------------------------------------------------------
@router.post("/login")
def login_user(data: LoginRequest, db: Session = Depends(get_db)):
    correo = data.correo
    contrasena = data.contrasena

    usuario = db.query(CuentaUsuario).filter(
        CuentaUsuario.correo_electronico == correo
    ).first()
    
    if not usuario:
        raise HTTPException(status_code=404, detail="Correo no registrado.")
    
    if usuario.estado_registro != "A":
        raise HTTPException(status_code=403, detail="La cuenta no está activa.")
    
    if not security.verify_password(contrasena, usuario.contrasena):
        raise HTTPException(status_code=401, detail="Contraseña incorrecta.")

    usuario_rol = db.query(UsuarioRol).filter(
        UsuarioRol.cuenta_usuario_id == usuario.id
    ).first()
    
    if not usuario_rol or usuario_rol.rol_id is None:
        raise HTTPException(status_code=400, detail="No se ha asignado un rol al usuario.")

    rol_id = usuario_rol.rol_id
    token = token_manager.generar_token(usuario.id, rol_id)

    # Obtener el cliente_id si el rol es cliente (rol_id == 2)
    cliente_id = None
    if rol_id == 2:  # Si es cliente
        cliente = db.query(Cliente).filter(Cliente.cuenta_usuario_id == usuario.id).first()
        if cliente:
            cliente_id = str(cliente.id)

    usuario.ultimo_acceso = datetime.now()
    db.commit()

    return {
        "mensaje": "Inicio de sesión exitoso.",
        "token": token,
        "usuario": {
            "id": str(usuario.id),
            "nombre": usuario.nombre_usuario,
            "correo": usuario.correo_electronico,
            "rol_id": rol_id,
            "cliente_id": cliente_id, 
        },
    }

# ---------------------------------------------------------------------------
# POST /auth/logout
# ---------------------------------------------------------------------------
@router.post("/logout")
def logout_user(request: Request):
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Token no proporcionado.")
    
    token = auth_header.split(" ")[1]
    
    try:
        token_manager.decodificar_token(token)
    except Exception:
        raise HTTPException(status_code=401, detail="Token inválido o expirado.")
    
    return {"mensaje": "Sesión cerrada exitosamente."}
</file>

<file path="backend/routers/cliente/carrito.py">
# backend/routers/cliente/carrito.py
from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session, joinedload
from utils.db import get_db
from models import Cliente, Pedido, DetallePedido, PlatoCombinado
from utils import keygen
from datetime import datetime

router = APIRouter(prefix="/cliente/carrito", tags=["Carrito de Compras"])

def get_or_create_cart(cliente_id: str, db: Session) -> Pedido:
    """Busca un pedido en estado 'carrito' para el cliente. Si no existe, lo crea."""
    cart = db.query(Pedido).filter_by(cliente_id=cliente_id, estado="carrito").first()
    if not cart:
        cart = Pedido(
            id=keygen.generate_uint64_key(),
            cliente_id=cliente_id,
            fecha=datetime.utcnow(),
            total=0.0,
            estado="carrito",
            incluye_plato=True
        )
        db.add(cart)
        db.commit()
        db.refresh(cart)
    return cart

@router.post("/agregar")
def agregar_al_carrito(
    cliente_id: str = Body(...),
    plato_id: str = Body(...),
    cantidad: int = Body(1),
    db: Session = Depends(get_db)
):
    """Agrega un producto al carrito del cliente o actualiza su cantidad."""
    cart = get_or_create_cart(cliente_id, db)
    plato = db.query(PlatoCombinado).filter(PlatoCombinado.id == plato_id).first()
    if not plato:
        raise HTTPException(status_code=404, detail="Plato no encontrado")

    detalle_existente = db.query(DetallePedido).filter_by(pedido_id=cart.id, plato_combinado_id=plato_id).first()

    if detalle_existente:
        detalle_existente.cantidad += cantidad
    else:
        nuevo_detalle = DetallePedido(
            id=keygen.generate_uint64_key(),
            pedido_id=cart.id,
            plato_combinado_id=plato_id,
            cantidad=cantidad,
            subtotal=0 # El subtotal se recalcula siempre
        )
        db.add(nuevo_detalle)
    
    # Recalcular el total del carrito
    detalles = db.query(DetallePedido).options(joinedload(DetallePedido.plato_combinado)).filter_by(pedido_id=cart.id).all()
    cart.total = sum(d.plato_combinado.precio * d.cantidad for d in detalles)
    db.commit()
    
    return {"mensaje": "Producto agregado al carrito", "total_carrito": float(cart.total)}

@router.get("/{cliente_id}")
def ver_carrito(cliente_id: str, db: Session = Depends(get_db)):
    """Muestra el contenido del carrito actual de un cliente."""
    cart = db.query(Pedido).filter_by(cliente_id=cliente_id, estado="carrito").options(joinedload(Pedido.detalle_pedido).joinedload(DetallePedido.plato_combinado)).first()
    
    if not cart or not cart.detalle_pedido:
        return {"items": [], "total": 0.0}
        
    items = [{
        "detalle_id": str(d.id),
        "plato_id": str(d.plato_combinado.id),
        "nombre": d.plato_combinado.nombre,
        "cantidad": d.cantidad,
        "precio_unitario": float(d.plato_combinado.precio),
        "subtotal": float(d.plato_combinado.precio * d.cantidad),
        "imagen": d.plato_combinado.imagen, # Pasamos el nombre del archivo de imagen
    } for d in cart.detalle_pedido]
    
    return {"items": items, "total": float(cart.total)}

# (Más adelante se pueden añadir endpoints para eliminar items o vaciar el carrito)
</file>

<file path="backend/routers/cliente/cliente.py">
"""
RUTAS DEL CLIENTE – PERFIL Y DATOS PERSONALES
----------------------------------------------
Módulo que gestiona toda la información relacionada al cliente:
- Perfil personal y actualización de datos.
- Consulta de membresía activa (subscripción).
- Gestión de direcciones de entrega (CRUD).
- Manejo de imágenes de perfil.
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile, Form
from utils import keygen, globals
from sqlalchemy.orm import joinedload, Session
from utils.db import get_db
from models import Cliente, Direccion  # ✅ IMPORTAR Direccion
import os

router = APIRouter(prefix="/cliente", tags=["Cliente"])

# ---------------------------------------------------------------------------
# GET /cliente/id/{cliente_id}
# ---------------------------------------------------------------------------
@router.get("/id/{cliente_id}")
def obtener_perfil_cliente(cliente_id: str, db: Session = Depends(get_db)):
    cliente = (
        db.query(Cliente)
        .options(
            joinedload(Cliente.cuenta_usuario),
            joinedload(Cliente.membresia_subscripcion),
            joinedload(Cliente.direccion)
        )
        .filter(Cliente.id == cliente_id, Cliente.estado_registro == "A")
        .first()
    )

    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")

    cuenta = cliente.cuenta_usuario
    membresia = cliente.membresia_subscripcion
    foto_path = cliente.foto or os.path.join(globals.CLIENTE, "default.png")

    direcciones = [
        {
            "id": str(d.id),
            "nombre": d.nombre,
            "referencia": d.referencia,
            "latitud": float(d.latitud),
            "longitud": float(d.longitud),
            "es_principal": bool(d.es_principal),
        }
        for d in cliente.direccion if d.estado_registro == "A"
    ]

    return {
        "id": str(cliente.id),
        "nombre": cliente.nombre,
        "telefono": cliente.telefono,
        "correo": cuenta.correo_electronico if cuenta else None,
        "foto": foto_path,
        "membresia_activa": {
            "id": str(membresia.id),
            "nombre": membresia.nombre,
            "duracion": membresia.duracion,
            "precio": float(membresia.precio),
        } if membresia else None,
        "direcciones": direcciones,
    }

# ---------------------------------------------------------------------------
# PUT /cliente/{cliente_id}
# ---------------------------------------------------------------------------
@router.put("/{cliente_id}")
def actualizar_datos_cliente(
    cliente_id: str,
    nombre: str = Form(...),
    telefono: str = Form(...),
    correo: str = Form(None),
    foto: UploadFile | None = None,
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")

    cliente.nombre = nombre
    cliente.telefono = telefono

    if correo and cliente.cuenta_usuario:
        cliente.cuenta_usuario.correo_electronico = correo

    uploads_dir = globals.CLIENTE
    os.makedirs(uploads_dir, exist_ok=True)

    if foto:
        filename = f"cliente_{cliente_id}_{foto.filename}"
        file_path = os.path.join(uploads_dir, filename)
        with open(file_path, "wb") as f:
            f.write(foto.file.read())
        cliente.foto = file_path
    else:
        if not cliente.foto:
            cliente.foto = os.path.join(uploads_dir, "default.png")

    db.commit()
    db.refresh(cliente)

    return {
        "mensaje": "Datos del cliente actualizados correctamente.",
        "cliente": {
            "id": str(cliente.id),
            "nombre": cliente.nombre,
            "telefono": cliente.telefono,
            "correo": cliente.cuenta_usuario.correo_electronico if cliente.cuenta_usuario else None,
            "foto": cliente.foto,
        },
    }

# ---------------------------------------------------------------------------
# GET /cliente/{cliente_id}/membresia
# ---------------------------------------------------------------------------
@router.get("/{cliente_id}/membresia")
def obtener_membresia_cliente(cliente_id: str, db: Session = Depends(get_db)):
    cliente = (
        db.query(Cliente)
        .options(joinedload(Cliente.membresia_subscripcion))
        .filter(Cliente.id == cliente_id)
        .first()
    )
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")

    membresia = cliente.membresia_subscripcion
    if not membresia:
        return {"mensaje": "El cliente no tiene membresía activa."}

    return {
        "id": str(membresia.id),
        "nombre": membresia.nombre,
        "duracion_dias": membresia.duracion,
        "precio": float(membresia.precio),
        "descripcion": membresia.descripcion,
        "beneficios": membresia.beneficios,
    }

# ---------------------------------------------------------------------------
# POST /cliente/{cliente_id}/direccion - ✅ FUNCIÓN ÚNICA Y CORREGIDA
# ---------------------------------------------------------------------------
@router.post("/{cliente_id}/direccion")
def crear_direccion(
    cliente_id: str,
    nombre: str = Form(...),
    latitud: float = Form(...),
    longitud: float = Form(...),
    referencia: str = Form(None),
    es_principal: bool = Form(False),
    db: Session = Depends(get_db),
):
    try:
        print(f"📥 Recibiendo dirección para cliente {cliente_id}")
        print(f"   Nombre: {nombre}")
        print(f"   Lat/Lng: {latitud}, {longitud}")
        print(f"   Es principal: {es_principal}")
        
        # Verificar que el cliente existe
        cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
        if not cliente:
            raise HTTPException(status_code=404, detail="Cliente no encontrado.")
        
        print(f"✅ Cliente encontrado: {cliente.nombre}")
        
        # Si es principal, desmarcar todas las demás
        if es_principal:
            print("🔄 Desmarcando otras direcciones principales...")
            db.query(Direccion).filter(
                Direccion.cliente_id == cliente_id
            ).update({"es_principal": False})
            db.flush()
        
        # Crear nueva dirección
        direccion_id = keygen.generate_uint64_key()
        print(f"🆔 ID generado: {direccion_id}")
        
        direccion = Direccion(
            id=direccion_id,
            cliente_id=cliente_id,
            nombre=nombre,
            latitud=latitud,
            longitud=longitud,
            referencia=referencia if referencia else "",
            es_principal=es_principal,
            estado_registro="A",
        )
        
        print("💾 Agregando dirección a la sesión...")
        db.add(direccion)
        
        print("🔄 Haciendo flush...")
        db.flush()
        
        print("✅ Haciendo commit...")
        db.commit()
        
        print("🔄 Refrescando objeto...")
        db.refresh(direccion)
        
        print(f"✅ Dirección guardada exitosamente: {direccion.id}")
        
        # Devolver objeto completo
        return {
            "mensaje": "Dirección registrada correctamente.",
            "direccion": {
                "id": str(direccion.id),
                "nombre": direccion.nombre,
                "latitud": float(direccion.latitud),
                "longitud": float(direccion.longitud),
                "referencia": direccion.referencia,
                "es_principal": bool(direccion.es_principal),
            },
        }
    
    except HTTPException:
        # Re-lanzar excepciones HTTP
        raise
    
    except Exception as e:
        # Capturar cualquier otro error
        print(f"❌ ERROR al crear dirección: {str(e)}")
        import traceback
        traceback.print_exc()
        db.rollback()
        raise HTTPException(
            status_code=500, 
            detail=f"Error al guardar dirección: {str(e)}"
        )

# ---------------------------------------------------------------------------
# GET /cliente/{cliente_id}/direcciones
# ---------------------------------------------------------------------------
@router.get("/{cliente_id}/direcciones")
def listar_direcciones(
    cliente_id: str,
    db: Session = Depends(get_db),
):
    print(f"📍 Listando direcciones para cliente: {cliente_id}")
    
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    direcciones = (
        db.query(Direccion)
        .filter(Direccion.cliente_id == cliente_id, Direccion.estado_registro == "A")
        .order_by(Direccion.es_principal.desc())
        .all()
    )
    
    # Convertir a lista de dicts
    resultado = [
        {
            "id": str(d.id),
            "nombre": d.nombre,
            "latitud": float(d.latitud),
            "longitud": float(d.longitud),
            "referencia": d.referencia,
            "es_principal": bool(d.es_principal),
        }
        for d in direcciones
    ]
    
    print(f"📤 Direcciones encontradas: {len(resultado)}")
    
    # Siempre devolver un objeto con 'total' y 'direcciones'
    return {
        "total": len(resultado),
        "direcciones": resultado
    }

# ---------------------------------------------------------------------------
# PUT /cliente/direccion/{direccion_id}
# ---------------------------------------------------------------------------
@router.put("/direccion/{direccion_id}")
def actualizar_direccion(
    direccion_id: str,
    nombre: str = Form(None),
    latitud: float = Form(None),
    longitud: float = Form(None),
    referencia: str = Form(None),
    es_principal: bool = Form(None),
    db: Session = Depends(get_db),
):
    direccion = db.query(Direccion).filter(
        Direccion.id == direccion_id, 
        Direccion.estado_registro == "A"
    ).first()
    
    if not direccion:
        raise HTTPException(status_code=404, detail="Dirección no encontrada o inactiva.")
    
    if nombre:
        direccion.nombre = nombre
    if referencia is not None:  # ✅ Permitir cadena vacía
        direccion.referencia = referencia
    if latitud is not None:
        direccion.latitud = latitud
    if longitud is not None:
        direccion.longitud = longitud
    
    if es_principal is not None:
        if es_principal:
            # Desmarcar todas las demás del mismo cliente
            db.query(Direccion).filter(
                Direccion.cliente_id == direccion.cliente_id,
                Direccion.id != direccion_id
            ).update({"es_principal": False})
        direccion.es_principal = es_principal

    db.commit()
    db.refresh(direccion)
    
    return {
        "mensaje": "Dirección actualizada correctamente.",
        "direccion": {
            "id": str(direccion.id),
            "nombre": direccion.nombre,
            "latitud": float(direccion.latitud),
            "longitud": float(direccion.longitud),
            "referencia": direccion.referencia,
            "es_principal": bool(direccion.es_principal),
        },
    }

# ---------------------------------------------------------------------------
# DELETE /cliente/direccion/{direccion_id}
# ---------------------------------------------------------------------------
@router.delete("/direccion/{direccion_id}")
def eliminar_direccion(
    direccion_id: str,
    db: Session = Depends(get_db),
):
    direccion = db.query(Direccion).filter(
        Direccion.id == direccion_id, 
        Direccion.estado_registro == "A"
    ).first()
    
    if not direccion:
        raise HTTPException(status_code=404, detail="Dirección no encontrada o ya inactiva.")
    
    cliente_id = direccion.cliente_id
    era_principal = direccion.es_principal
    
    # Marcar como inactiva
    direccion.estado_registro = "I"
    direccion.es_principal = False
    db.commit()
    
    # Si era principal, asignar otra
    if era_principal:
        nueva_principal = (
            db.query(Direccion)
            .filter(Direccion.cliente_id == cliente_id, Direccion.estado_registro == "A")
            .order_by(Direccion.id.desc())
            .first()
        )
        
        if nueva_principal:
            nueva_principal.es_principal = True
            db.commit()
            
            return {
                "mensaje": "Dirección eliminada. Se ha reasignado una nueva dirección principal.",
                "nueva_principal": {
                    "id": str(nueva_principal.id),
                    "nombre": nueva_principal.nombre,
                    "referencia": nueva_principal.referencia,
                    "latitud": float(nueva_principal.latitud),
                    "longitud": float(nueva_principal.longitud),
                },
            }
    
    return {"mensaje": "Dirección eliminada correctamente."}
</file>

<file path="backend/routers/cliente/favoritos.py">
"""
RUTAS DEL CLIENTE – GESTIÓN DE FAVORITOS
----------------------------------------
Permite al cliente gestionar sus platos favoritos.

Incluye:
- Agregar un plato a favoritos
- Eliminar un plato de favoritos
- Listar todos los platos favoritos del cliente
- Verificar si un plato está en favoritos
"""

from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session, joinedload
from utils.db import get_db
from utils import keygen
from models import PlatoFavorito, Cliente, PlatoCombinado
from datetime import datetime

router = APIRouter(prefix="/cliente/favoritos", tags=["Favoritos del Cliente"])

# ---------------------------------------------------------------------------
# POST /cliente/favoritos/{cliente_id}/{plato_id}
# ---------------------------------------------------------------------------
@router.post("/{cliente_id}/{plato_id}")
def agregar_favorito(
    cliente_id: str,
    plato_id: str,
    db: Session = Depends(get_db),
):
    """
    Agrega un plato a la lista de favoritos del cliente.
    Si ya existe, retorna un mensaje indicándolo.
    """
    # Verificar que el cliente existe
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    # Verificar que el plato existe
    plato = db.query(PlatoCombinado).filter(PlatoCombinado.id == plato_id).first()
    if not plato:
        raise HTTPException(status_code=404, detail="Plato no encontrado.")
    
    # Verificar si ya está en favoritos
    favorito_existente = db.query(PlatoFavorito).filter(
        PlatoFavorito.cliente_id == cliente_id,
        PlatoFavorito.plato_combinado_id == plato_id
    ).first()
    
    if favorito_existente:
        return {
            "mensaje": "Este plato ya está en tus favoritos.",
            "ya_existe": True,
            "favorito_id": str(favorito_existente.id)
        }
    
    # Crear nuevo favorito
    nuevo_favorito = PlatoFavorito(
        id=keygen.generate_uint64_key(),
        cliente_id=cliente_id,
        plato_combinado_id=plato_id,
        fecha_agregado=datetime.now()
    )
    
    db.add(nuevo_favorito)
    db.commit()
    db.refresh(nuevo_favorito)
    
    return {
        "mensaje": "Plato agregado a favoritos correctamente.",
        "ya_existe": False,
        "favorito": {
            "id": str(nuevo_favorito.id),
            "plato_id": str(plato_id),
            "plato_nombre": plato.nombre,
            "fecha_agregado": nuevo_favorito.fecha_agregado.isoformat()
        }
    }

# ---------------------------------------------------------------------------
# DELETE /cliente/favoritos/{cliente_id}/{plato_id}
# ---------------------------------------------------------------------------
@router.delete("/{cliente_id}/{plato_id}")
def eliminar_favorito(
    cliente_id: str,
    plato_id: str,
    db: Session = Depends(get_db),
):
    """
    Elimina un plato de la lista de favoritos del cliente.
    """
    favorito = db.query(PlatoFavorito).filter(
        PlatoFavorito.cliente_id == cliente_id,
        PlatoFavorito.plato_combinado_id == plato_id
    ).first()
    
    if not favorito:
        raise HTTPException(
            status_code=404, 
            detail="Este plato no está en tus favoritos."
        )
    
    db.delete(favorito)
    db.commit()
    
    return {
        "mensaje": "Plato eliminado de favoritos correctamente.",
        "plato_id": str(plato_id)
    }

# ---------------------------------------------------------------------------
# GET /cliente/favoritos/{cliente_id}
# ---------------------------------------------------------------------------
@router.get("/{cliente_id}")
def listar_favoritos(
    cliente_id: str,
    request: Request,
    db: Session = Depends(get_db),
):
    """
    Lista todos los platos favoritos de un cliente.
    Incluye información completa del plato.
    """
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    favoritos = (
        db.query(PlatoFavorito)
        .options(
            joinedload(PlatoFavorito.plato_combinado)
            .joinedload(PlatoCombinado.categoria),
            joinedload(PlatoFavorito.plato_combinado)
            .joinedload(PlatoCombinado.especie),
            joinedload(PlatoFavorito.plato_combinado)
            .joinedload(PlatoCombinado.etiqueta_plato)
        )
        .filter(PlatoFavorito.cliente_id == cliente_id)
        .order_by(PlatoFavorito.fecha_agregado.desc())
        .all()
    )
    
    if not favoritos:
        return {
            "mensaje": "No tienes platos en favoritos aún.",
            "total": 0,
            "favoritos": []
        }
    
    # Construir URL base para imágenes
    base_url = str(request.base_url).rstrip("/")
    
    resultado = []
    for fav in favoritos:
        plato = fav.plato_combinado
        if plato:
            imagen_url = None
            if plato.imagen:
                imagen_url = f"{base_url}/static/imagenes/plato/{plato.imagen}"
            
            resultado.append({
                "favorito_id": str(fav.id),
                "fecha_agregado": fav.fecha_agregado.isoformat(),
                "plato": {
                    "id": str(plato.id),
                    "nombre": plato.nombre,
                    "descripcion": plato.descripcion,
                    "precio": float(plato.precio),
                    "imagen": imagen_url,
                    "categoria": plato.categoria.nombre if plato.categoria else None,
                    "especie": plato.especie.nombre if plato.especie else None,
                    "etiquetas": [ep.etiqueta.nombre for ep in plato.etiqueta_plato]
                }
            })
    
    return {
        "total": len(resultado),
        "favoritos": resultado
    }

# ---------------------------------------------------------------------------
# GET /cliente/favoritos/{cliente_id}/check/{plato_id}
# ---------------------------------------------------------------------------
@router.get("/{cliente_id}/check/{plato_id}")
def verificar_favorito(
    cliente_id: str,
    plato_id: str,
    db: Session = Depends(get_db),
):
    """
    Verifica si un plato específico está en la lista de favoritos del cliente.
    Útil para actualizar el estado del botón de favorito en el frontend.
    """
    favorito = db.query(PlatoFavorito).filter(
        PlatoFavorito.cliente_id == cliente_id,
        PlatoFavorito.plato_combinado_id == plato_id
    ).first()
    
    return {
        "es_favorito": favorito is not None,
        "favorito_id": str(favorito.id) if favorito else None
    }
</file>

<file path="backend/routers/cliente/mascota.py">
"""
RUTAS DEL CLIENTE – MASCOTAS
-----------------------------
Permite al cliente administrar el registro de sus mascotas y sus datos
vinculados: especie, alergias, condiciones de salud, recetas médicas, etc.
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile, Form
from utils import globals, keygen
from utils.db import get_db
from sqlalchemy.orm import Session, joinedload
from models import Cliente, Especie, RegistroMascota, PedidoEspecializado, AlergiaMascota, AlergiaEspecie, CondicionSalud, RecetaMedica
import os
from datetime import datetime

router = APIRouter(prefix="/cliente/mascotas", tags=["Mascotas del Cliente"])

# ---------------------------------------------------------------------------
# GET /cliente/mascotas/{cliente_id}
# ---------------------------------------------------------------------------
@router.get("/{cliente_id}")
def listar_mascotas_cliente(
    cliente_id: str,
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    mascotas = (
        db.query(RegistroMascota)
        .join(Especie)
        .filter(RegistroMascota.cliente_id == cliente_id, RegistroMascota.estado_registro == "A")
        .all()
    )
    
    if not mascotas:
        return {"mensaje": "El cliente no tiene mascotas registradas."}
    
    resultado = []
    for m in mascotas:
        especie_nombre = m.especie.nombre if m.especie else "Sin especie"
        if not m.foto:
            if "perro" in especie_nombre.lower():
                foto = os.path.join(globals.MASCOTA, "perro.png")
            elif "gato" in especie_nombre.lower():
                foto = os.path.join(globals.MASCOTA, "gato.png")
            else:
                foto = os.path.join(globals.MASCOTA, "default.png")
        else:
            foto = m.foto
        
        resultado.append({
            "id": str(m.id),
            "nombre": m.nombre,
            "especie": especie_nombre,
            "raza": m.raza,
            "edad": m.edad,
            "peso": float(m.peso) if m.peso else None,
            "foto": foto,
        })
    
    return {"total": len(resultado), "mascotas": resultado}

# ---------------------------------------------------------------------------
# POST /cliente/mascotas/{cliente_id}
# ---------------------------------------------------------------------------
@router.post("/{cliente_id}")
def registrar_mascota(
    cliente_id: str,
    nombre: str = Form(...),
    especie_id: str = Form(...),
    raza: str = Form(...),
    edad: int = Form(...),
    sexo: str = Form(..., description="Sexo de la mascota: M (macho) o H (hembra)"),
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    especie = db.query(Especie).filter(Especie.id == especie_id).first()
    if not especie:
        raise HTTPException(status_code=404, detail="Especie no encontrada.")
    
    # Validar sexo
    if sexo not in ['M', 'H']:
        raise HTTPException(status_code=400, detail="El sexo debe ser 'M' (macho) o 'H' (hembra).")
    
    mascota_id = keygen.generate_uint64_key()
    especie_nombre = especie.nombre.lower()
    
    # Asignar foto según especie
    if "perro" in especie_nombre:
        foto_path = os.path.join(globals.MASCOTA, "perro.png")
    elif "gato" in especie_nombre:
        foto_path = os.path.join(globals.MASCOTA, "gato.png")
    else:
        foto_path = os.path.join(globals.MASCOTA, "default.png")
    
    # Crear mascota con todos los campos requeridos
    mascota = RegistroMascota(
        id=mascota_id,
        cliente_id=cliente_id,
        nombre=nombre,
        especie_id=especie_id,
        raza=raza,
        edad=edad,
        sexo=sexo,
        cambio_edad=datetime.now().date(),
        foto=foto_path,
        estado_registro="A",
    )
    
    # ✅ LÍNEA CORREGIDA: Eliminamos el acceso al atributo inexistente
    print(f"✅ Registrando mascota: {mascota.nombre}, especie: {especie.nombre}, ID: {mascota_id}")

    db.add(mascota)
    db.commit()
    
    return {
        "mensaje": "Mascota registrada exitosamente.",
        "mascota": {
            "id": str(mascota.id),
            "nombre": mascota.nombre,
            "especie": especie.nombre,
            "raza": mascota.raza,
            "edad": mascota.edad,
            "sexo": mascota.sexo,
            "foto": mascota.foto,
        },
    }

# ---------------------------------------------------------------------------
# GET /cliente/mascotas/detalle/{mascota_id}
# ---------------------------------------------------------------------------
@router.get("/detalle/{mascota_id}")
def obtener_detalle_mascota(
    mascota_id: str,
    db: Session = Depends(get_db),
):
    mascota = (
        db.query(RegistroMascota)
        .options(
            joinedload(RegistroMascota.especie),
            joinedload(RegistroMascota.alergia_mascota),
            joinedload(RegistroMascota.condicion_salud),
            joinedload(RegistroMascota.receta_medica),
        )
        .filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A")
        .first()
    )
    
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    
    especie_nombre = mascota.especie.nombre if mascota.especie else "Sin especie"
    
    if not mascota.foto:
        if "perro" in especie_nombre.lower():
            foto = os.path.join(globals.MASCOTA, "perro.png")
        elif "gato" in especie_nombre.lower():
            foto = os.path.join(globals.MASCOTA, "gato.png")
        else:
            foto = os.path.join(globals.MASCOTA, "default.png")
    else:
        foto = mascota.foto
    
    alergias = [
        {
            "id": str(a.id),
            "alergia": a.alergia_especie.nombre if a.alergia_especie else None,
            "severidad": a.severidad,
        }
        for a in mascota.alergia_mascota
    ]
    
    condiciones = [
        {
            "id": str(c.id),
            "nombre": c.nombre,
            "fecha": c.fecha.isoformat() if c.fecha else None,
            "estado_registro": c.estado_registro,
        }
        for c in mascota.condicion_salud
    ]
    
    recetas = [
        {
            "id": str(r.id),
            "fecha": r.fecha.isoformat() if r.fecha else None,
            "archivo": r.archivo,
            "estado_registro": r.estado_registro,
        }
        for r in mascota.receta_medica
    ]
    
    return {
        "id": str(mascota.id),
        "nombre": mascota.nombre,
        "especie": especie_nombre,
        "raza": mascota.raza,
        "edad": mascota.edad,
        "peso": float(mascota.peso) if mascota.peso else None,
        "foto": foto,
        "alergias": alergias,
        "condiciones_salud": condiciones,
        "recetas_medicas": recetas,
        "observaciones": mascota.observaciones,
    }

# ---------------------------------------------------------------------------
# PUT /cliente/mascotas/{mascota_id}
# ---------------------------------------------------------------------------
# Edita los datos de una mascota existente (nombre, peso, edad, observaciones, etc.).
@router.put("/{mascota_id}")
def actualizar_mascota(
    mascota_id: str,
    nombre: str = Form(None),
    edad: int = Form(None),
    peso: float = Form(None),
    raza: str = Form(None),
    observaciones: str = Form(None),
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A").first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    if nombre:
        mascota.nombre = nombre
    if edad is not None:
        mascota.edad = edad
    if peso is not None:
        mascota.peso = peso
    if raza:
        mascota.raza = raza
    if observaciones:
        mascota.observaciones = observaciones
    db.commit()
    return {
        "mensaje": "Datos de la mascota actualizados correctamente.",
        "mascota": {
            "id": str(mascota.id),
            "nombre": mascota.nombre,
            "edad": mascota.edad,
            "peso": float(mascota.peso) if mascota.peso else None,
            "raza": mascota.raza,
            "observaciones": mascota.observaciones,
        },
    }

# ---------------------------------------------------------------------------
# PUT /cliente/mascotas/{mascota_id}/foto
# ---------------------------------------------------------------------------
# Cambia la foto de la mascota. Si no se envía imagen, mantiene la actual.
@router.put("/{mascota_id}/foto")
def actualizar_foto_mascota(
    mascota_id: str,
    foto: UploadFile = None,
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A").first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    uploads_dir = os.path.join("static", "uploads", "mascotas")
    os.makedirs(uploads_dir, exist_ok=True)
    if foto:
        extension = os.path.splitext(foto.filename)[1].lower()
        if extension not in [".jpg", ".jpeg", ".png"]:
            raise HTTPException(status_code=400, detail="Formato de imagen no permitido.")
        nuevo_nombre = f"mascota_{mascota_id}{extension}"
        foto_path = os.path.join(uploads_dir, nuevo_nombre)
        with open(foto_path, "wb") as f:
            f.write(foto.file.read())
        mascota.foto = foto_path
    db.commit()
    return {
        "mensaje": "Foto de mascota actualizada correctamente.",
        "foto": mascota.foto,
    }

# ---------------------------------------------------------------------------
# DELETE /cliente/mascotas/{mascota_id}
# ---------------------------------------------------------------------------
# Elimina o marca como inactiva una mascota del cliente.
# Si tiene pedidos activos asociados, no se borra físicamente.
@router.delete("/{mascota_id}")
def eliminar_mascota(
    mascota_id: str,
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id).first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada.")
    pedidos_activos = (
        db.query(PedidoEspecializado)
        .filter(
            PedidoEspecializado.registro_mascota_id == mascota_id,
            PedidoEspecializado.estado_registro == "A",
        )
        .count()
    )
    if pedidos_activos > 0:
        mascota.estado_registro = "I"
        db.commit()
        return {"mensaje": "Mascota marcada como inactiva por tener pedidos asociados."}
    db.delete(mascota)
    db.commit()
    return {"mensaje": "Mascota eliminada correctamente."}

# ---------------------------------------------------------------------------
# GET /cliente/mascotas/{mascota_id}/alergias
# ---------------------------------------------------------------------------
# Devuelve la lista de alergias registradas para la mascota.
# Incluye nombre, severidad y descripción.
@router.get("/{mascota_id}/alergias")
def listar_alergias_mascota(
    mascota_id: str,
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A").first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    alergias = (
        db.query(AlergiaMascota)
        .options(joinedload(AlergiaMascota.alergia_especie))
        .filter(AlergiaMascota.registro_mascota_id == mascota_id)
        .all()
    )
    if not alergias:
        return {"mensaje": "No se encontraron alergias registradas para esta mascota."}
    resultado = [
        {
            "id": str(a.id),
            "nombre": a.alergia_especie.nombre if a.alergia_especie else None,
            "severidad": a.severidad,
            "descripcion": a.descripcion,
        }
        for a in alergias
    ]
    return {"total": len(resultado), "alergias": resultado}

# ---------------------------------------------------------------------------
# POST /cliente/mascotas/{mascota_id}/alergias
# ---------------------------------------------------------------------------
# Registra una nueva alergia asociada a la mascota.
# Campos: alergia_especie_id, severidad, descripcion (opcional).
@router.post("/{mascota_id}/alergias")
def registrar_alergia_mascota(
    mascota_id: str,
    alergia_especie_id: str = Form(...),
    severidad: str = Form(...),
    descripcion: str = Form(None),
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A").first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    alergia = db.query(AlergiaEspecie).filter(AlergiaEspecie.id == alergia_especie_id).first()
    if not alergia:
        raise HTTPException(status_code=404, detail="Alergia no encontrada en catálogo de especies.")
    # Evitar duplicados
    existente = (
        db.query(AlergiaMascota)
        .filter(
            AlergiaMascota.registro_mascota_id == mascota_id,
            AlergiaMascota.alergia_especie_id == alergia_especie_id,
        )
        .first()
    )
    if existente:
        raise HTTPException(status_code=400, detail="La mascota ya tiene registrada esta alergia.")
    nueva = AlergiaMascota(
        id=keygen.generate_uint64_key(),
        registro_mascota_id=mascota_id,
        alergia_especie_id=alergia_especie_id,
        severidad=severidad,
        descripcion=descripcion,
    )
    db.add(nueva)
    db.commit()
    return {
        "mensaje": "Alergia registrada exitosamente.",
        "alergia": {
            "id": str(nueva.id),
            "nombre": alergia.nombre,
            "severidad": nueva.severidad,
            "descripcion": nueva.descripcion,
        },
    }

# ---------------------------------------------------------------------------
# GET /cliente/mascotas/{mascota_id}/condiciones
# ---------------------------------------------------------------------------
# Devuelve la lista de condiciones de salud asociadas a la mascota.
# Incluye nombre, fecha y estado_registro.
@router.get("/{mascota_id}/condiciones")
def listar_condiciones_mascota(
    mascota_id: str,
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(RegistroMascota.id == mascota_id, RegistroMascota.estado_registro == "A").first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    condiciones = (
        db.query(CondicionSalud)
        .filter(CondicionSalud.registro_mascota_id == mascota_id)
        .order_by(CondicionSalud.fecha.desc())
        .all()
    )
    if not condiciones:
        return {"mensaje": "No se encontraron condiciones de salud registradas para esta mascota."}
    resultado = [
        {
            "id": str(c.id),
            "nombre": c.nombre,
            "fecha": c.fecha.isoformat() if c.fecha else None,
            "estado_registro": c.estado_registro,
        }
        for c in condiciones
    ]
    return {"total": len(resultado), "condiciones_salud": resultado}

# ---------------------------------------------------------------------------
# POST /cliente/mascotas/{mascota_id}/condiciones
# ---------------------------------------------------------------------------
# Registra una nueva condición de salud (ej. “gastroenteritis”, “anemia leve”).
@router.post("/{mascota_id}/condiciones")
def registrar_condicion_mascota(
    mascota_id: str,
    nombre: str = Form(...),
    descripcion: str = Form(None),
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(
        RegistroMascota.id == mascota_id,
        RegistroMascota.estado_registro == "A"
    ).first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    condicion = CondicionSalud(
        id=keygen.generate_uint64_key(),
        registro_mascota_id=mascota_id,
        nombre=nombre,
        descripcion=descripcion,
        fecha=datetime.now(),
        estado_registro="A",
    )
    db.add(condicion)
    db.commit()
    return {
        "mensaje": "Condición de salud registrada exitosamente.",
        "condicion": {
            "id": str(condicion.id),
            "nombre": condicion.nombre,
            "descripcion": condicion.descripcion,
            "fecha": condicion.fecha.isoformat(),
            "estado_registro": condicion.estado_registro,
        },
    }

# ---------------------------------------------------------------------------
# GET /cliente/mascotas/{mascota_id}/recetas
# ---------------------------------------------------------------------------
# Lista las recetas médicas asociadas a la mascota.
# Incluye fecha, estado y archivo descargable.
@router.get("/{mascota_id}/recetas")
def listar_recetas_mascota(
    mascota_id: str,
    db: Session = Depends(get_db),
):
    mascota = db.query(RegistroMascota).filter(
        RegistroMascota.id == mascota_id,
        RegistroMascota.estado_registro == "A"
    ).first()
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o inactiva.")
    recetas = (
        db.query(RecetaMedica)
        .filter(RecetaMedica.registro_mascota_id == mascota_id)
        .order_by(RecetaMedica.fecha.desc())
        .all()
    )
    if not recetas:
        return {"mensaje": "No se encontraron recetas médicas para esta mascota."}
    resultado = [
        {
            "id": str(r.id),
            "fecha": r.fecha.isoformat() if r.fecha else None,
            "estado_registro": r.estado_registro,
            "archivo": r.archivo,
        }
        for r in recetas
    ]
    return {"total": len(resultado), "recetas_medicas": resultado}
</file>

<file path="backend/routers/cliente/pago.py">
# backend/routers/cliente/pago.py

"""
RUTAS DEL CLIENTE – PROCESAMIENTO DE PAGOS
------------------------------------------
Permite al cliente realizar pagos de pedidos mediante
diferentes métodos (Yape, Plin, etc.) y subir comprobantes.
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session, joinedload
from utils.db import get_db
from utils import keygen, globals
from models import Pedido, Pago, PasarelaPago
from datetime import datetime
import os

router = APIRouter(prefix="/cliente/pedido", tags=["Pagos del Cliente"])

# ---------------------------------------------------------------------------
# POST /cliente/pedido/{pedido_id}/pagar
# ---------------------------------------------------------------------------
# Procesa el pago de un pedido y sube el comprobante
@router.post("/{pedido_id}/pagar")
def procesar_pago(
    pedido_id: str,
    pasarela_pago_id: str = Form(..., description="ID del método de pago (1=Yape, 2=Plin)"),
    comprobante: UploadFile = File(None, description="Imagen del comprobante de pago"),
    db: Session = Depends(get_db),
):
    """
    Procesa el pago de un pedido.
    Crea un registro de pago y guarda el comprobante.
    """
    # Verificar que el pedido existe
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    
    # Verificar que el pedido no esté ya pagado
    pago_existente = db.query(Pago).filter(Pago.pedido_id == pedido_id).first()
    if pago_existente:
        raise HTTPException(status_code=400, detail="Este pedido ya tiene un pago registrado.")
    
    # Verificar que la pasarela de pago existe
    pasarela = db.query(PasarelaPago).filter(PasarelaPago.id == pasarela_pago_id).first()
    if not pasarela:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado.")
    
    # Guardar comprobante si se proporcionó
    referencia_pago = None
    if comprobante:
        uploads_dir = os.path.join("static", "uploads", "comprobantes")
        os.makedirs(uploads_dir, exist_ok=True)
        
        # Generar nombre único para el archivo
        extension = os.path.splitext(comprobante.filename)[1]
        filename = f"comprobante_{pedido_id}_{datetime.now().strftime('%Y%m%d%H%M%S')}{extension}"
        file_path = os.path.join(uploads_dir, filename)
        
        # Guardar archivo
        with open(file_path, "wb") as f:
            f.write(comprobante.file.read())
        
        referencia_pago = file_path
        print(f"✅ Comprobante guardado en: {file_path}")
    
    # Crear registro de pago
    pago_id = keygen.generate_uint64_key()
    pago = Pago(
        id=pago_id,
        pedido_id=pedido_id,
        monto=pedido.total,
        fecha=datetime.now(),
        estado="pendiente",  # El admin debe verificar el comprobante
        pasarela_pago_id=pasarela_pago_id,
        referencia_pago=referencia_pago,
    )
    
    db.add(pago)
    
    # Actualizar estado del pedido
    pedido.estado = "en_preparacion"
    
    db.commit()
    db.refresh(pago)
    
    print(f"✅ Pago registrado: {pago_id}")
    
    return {
        "mensaje": "Pago procesado correctamente. Tu pedido está siendo verificado.",
        "pago_id": str(pago.id),
        "pedido_id": str(pedido.id),
        "monto": float(pago.monto),
        "estado": pago.estado,
        "metodo_pago": pasarela.nombre if pasarela else None,
    }


# ---------------------------------------------------------------------------
# GET /cliente/{cliente_id}/pagos
# ---------------------------------------------------------------------------
# Lista todos los pagos realizados por un cliente
@router.get("/{cliente_id}/pagos")
def listar_pagos_cliente(
    cliente_id: str,
    db: Session = Depends(get_db),
):
    """
    Devuelve el historial de pagos de un cliente.
    """
    pagos = (
        db.query(Pago)
        .join(Pedido)
        .options(
            joinedload(Pago.pedido),
            joinedload(Pago.pasarela_pago)
        )
        .filter(Pedido.cliente_id == cliente_id)
        .order_by(Pago.fecha.desc())
        .all()
    )
    
    if not pagos:
        return {"mensaje": "No se encontraron pagos para este cliente."}
    
    resultado = []
    for p in pagos:
        resultado.append({
            "pago_id": str(p.id),
            "pedido_id": str(p.pedido_id),
            "monto": float(p.monto),
            "fecha": p.fecha.isoformat(),
            "estado": p.estado,
            "metodo_pago": p.pasarela_pago.nombre if p.pasarela_pago else None,
            "comprobante": p.referencia_pago,
        })
    
    return {"total": len(resultado), "pagos": resultado}


# ---------------------------------------------------------------------------
# GET /cliente/pago/{pago_id}/estado
# ---------------------------------------------------------------------------
# Verifica el estado de un pago específico
@router.get("/pago/{pago_id}/estado")
def verificar_estado_pago(
    pago_id: str,
    db: Session = Depends(get_db),
):
    """
    Verifica el estado actual de un pago.
    """
    pago = (
        db.query(Pago)
        .options(
            joinedload(Pago.pedido),
            joinedload(Pago.pasarela_pago)
        )
        .filter(Pago.id == pago_id)
        .first()
    )
    
    if not pago:
        raise HTTPException(status_code=404, detail="Pago no encontrado.")
    
    return {
        "pago_id": str(pago.id),
        "pedido_id": str(pago.pedido_id),
        "monto": float(pago.monto),
        "fecha": pago.fecha.isoformat(),
        "estado": pago.estado,
        "metodo_pago": pago.pasarela_pago.nombre if pago.pasarela_pago else None,
        "estado_pedido": pago.pedido.estado if pago.pedido else None,
    }
</file>

<file path="backend/routers/cliente/pedido.py">
"""
RUTAS DEL CLIENTE – PEDIDOS Y PEDIDOS ESPECIALIZADOS
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile, Body, Form, File, Query
from datetime import datetime
from utils import keygen, globals
from sqlalchemy.orm import joinedload, Session
from utils.db import get_db
from models import (
    Cliente, Direccion, Pedido, DetallePedido, ControlEntrega, 
    PlatoCombinado, PedidoEspecializado, RegistroMascota, RecetaMedica, 
    AlergiaMascota, DescripcionAlergias, CondicionSalud, PreferenciaAlimentaria
)
import os
import json
from typing import Optional

router = APIRouter(prefix="/cliente/pedido", tags=["Pedidos del Cliente"])

# ---------------------------------------------------------------------------
# POST /cliente/pedido/{cliente_id}
# ---------------------------------------------------------------------------
@router.post("/{cliente_id}")
def crear_pedido(
    cliente_id: str,
    data: dict = Body(..., description="Datos del pedido: dirección, platos y total"),
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    
    direccion_id = data.get("direccion_id")
    platos = data.get("platos", [])
    total = data.get("total")
    
    if not direccion_id:
        raise HTTPException(status_code=400, detail="Debe especificar una dirección de entrega.")
    if not platos or len(platos) == 0:
        raise HTTPException(status_code=400, detail="Debe incluir al menos un plato en el pedido.")
    if not total or total <= 0:
        raise HTTPException(status_code=400, detail="El total del pedido debe ser mayor que 0.")
    
    direccion = (
        db.query(Direccion)
        .filter(Direccion.id == direccion_id, Direccion.cliente_id == cliente_id)
        .first()
    )
    if not direccion:
        raise HTTPException(status_code=400, detail="La dirección no pertenece al cliente o no existe.")
    
    pedido_id = keygen.generate_uint64_key()
    pedido = Pedido(
        id=pedido_id,
        cliente_id=cliente_id,
        direccion_id=direccion_id,
        fecha=datetime.now(),
        total=total,
        estado="pendiente",
        incluye_plato=True,
    )
    db.add(pedido)
    
    for item in platos:
        # ✅ CÓDIGO CORREGIDO: Eliminamos el debugger y la división por cero
        plato_id = item.get("plato_id")
        cantidad = item.get("cantidad", 1)
        precio_unitario = item.get("precio_unitario", 0)
        
        # Calcular el subtotal correctamente
        subtotal = cantidad * precio_unitario
        
        # Verificar que el plato existe
        plato = db.query(PlatoCombinado).filter(PlatoCombinado.id == plato_id).first()
        if not plato:
            raise HTTPException(
                status_code=404, 
                detail=f"El plato con ID {plato_id} no existe."
            )
        
        # Crear el detalle del pedido
        det = DetallePedido(
            id=keygen.generate_uint64_key(),
            pedido_id=pedido_id,
            plato_combinado_id=plato_id,
            cantidad=cantidad,
            subtotal=subtotal,
        )
        db.add(det)
    
    db.commit()
    
    return {
        "mensaje": "Pedido creado exitosamente.",
        "pedido_id": str(pedido_id),
        "estado": pedido.estado,
        "total": float(pedido.total),
        "fecha": pedido.fecha.isoformat(),
    }

# ---------------------------------------------------------------------------
# GET /cliente/pedido/{cliente_id}/historial
# ---------------------------------------------------------------------------
# Lista todos los pedidos realizados por el cliente.
# Incluye estado, fecha, total y si tiene pedido especializado asociado.
@router.get("/{cliente_id}/historial")
def listar_pedidos_cliente(
    cliente_id: str,
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    pedidos = (
        db.query(Pedido)
        .options(joinedload(Pedido.pedido_especializado))
        .filter(Pedido.cliente_id == cliente_id)
        .order_by(Pedido.fecha.desc())
        .all()
    )
    if not pedidos:
        return {"mensaje": "El cliente no tiene pedidos registrados."}
    resultado = []
    for p in pedidos:
        resultado.append({
            "pedido_id": str(p.id),
            "fecha": p.fecha.isoformat(),
            "estado": p.estado,
            "total": float(p.total),
            "especializado": bool(p.pedido_especializado),
        })
    return {"total": len(resultado), "pedidos": resultado}

# ---------------------------------------------------------------------------
# GET /cliente/pedido/detalle/{pedido_id}
# ---------------------------------------------------------------------------
# Devuelve los detalles del pedido:
# platos, cantidades, subtotal, dirección y estado actual.
@router.get("/detalle/{pedido_id}")
def obtener_detalle_pedido(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    pedido = (
        db.query(Pedido)
        .options(
            joinedload(Pedido.detalle_pedido).joinedload(DetallePedido.plato_combinado),
            joinedload(Pedido.direccion),
            joinedload(Pedido.cliente),
        )
        .filter(Pedido.id == pedido_id)
        .first()
    )
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    direccion = pedido.direccion
    cliente = pedido.cliente
    platos = [
        {
            "plato": det.plato_combinado.nombre if det.plato_combinado else None,
            "cantidad": det.cantidad,
            "subtotal": float(det.subtotal),
        }
        for det in pedido.detalle_pedido
    ]
    return {
        "pedido": {
            "id": str(pedido.id),
            "fecha": pedido.fecha.isoformat(),
            "estado": pedido.estado,
            "total": float(pedido.total),
        },
        "cliente": {
            "id": str(cliente.id),
            "nombre": cliente.nombre,
            "telefono": cliente.telefono,
        } if cliente else None,
        "direccion": {
            "id": str(direccion.id),
            "nombre": direccion.nombre,
            "referencia": direccion.referencia,
            "latitud": float(direccion.latitud),
            "longitud": float(direccion.longitud),
        } if direccion else None,
        "platos": platos,
    }

# ---------------------------------------------------------------------------
# POST /cliente/pedido/{pedido_id}/recibido
# ---------------------------------------------------------------------------
# Marca un pedido como recibido por el cliente.
# Actualiza el estado del pedido y la confirmación de entrega.
@router.post("/{pedido_id}/recibido")
def marcar_pedido_recibido(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado.")
    control = db.query(ControlEntrega).filter(ControlEntrega.pedido_id == pedido_id).first()
    if not control:
        raise HTTPException(status_code=404, detail="El pedido no tiene registro de entrega asignado.")
    if pedido.estado == "entregado" and control.confirmacion_entrega == 1:
        return {"mensaje": "El pedido ya fue confirmado como recibido."}
    pedido.estado = "entregado"
    control.confirmacion_entrega = 1
    control.fecha_entrega = datetime.now()
    db.commit()
    return {
        "mensaje": "El pedido ha sido confirmado como recibido.",
        "pedido": {
            "id": str(pedido.id),
            "estado": pedido.estado,
            "fecha_confirmacion": control.fecha_entrega.isoformat(),
            "confirmacion_entrega": True
        },
    }

# ---------------------------------------------------------------------------
# GET /cliente/pedido/{pedido_id}/qr
# ---------------------------------------------------------------------------
# Devuelve la URL o archivo del QR correspondiente al pedido.
# Si no existe, genera uno en utils.globals.QR y lo guarda.
@router.get("/{pedido_id}/qr")
def obtener_qr_pedido(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    return {"message": f"QR de pedido {pedido_id} en construcción"}


# ---------------------------------------------------------------------------
# POST /cliente/pedido-especializado/{cliente_id}
# ---------------------------------------------------------------------------
# Crea un pedido especializado vinculado a una mascota e inserta:
# - Pedido + PedidoEspecializado
# - (opcional) Receta médica (PDF/imagen)
# - (opcional) Varias alergias (AlergiaMascota)
# - (opcional) Una descripción libre de alergias (DescripcionAlergias)
# - (opcional) Varias condiciones de salud (CondicionSalud)
# - (opcional) Varias preferencias alimentarias (PreferenciaAlimentaria)
# - (opcional) Archivo adicional
@router.post("/especializado/{cliente_id}")
def crear_pedido_especializado(
    cliente_id: str,
    registro_mascota_id: str = Form(..., description="ID del registro de mascota"),
    frecuencia_cantidad: str = Form(..., description="Frecuencia y cantidad, p. ej. '2 veces/semana'"),
    objetivo_dieta: str = Form(..., description="Objetivo de la dieta"),
    indicaciones_adicionales: Optional[str] = Form(None, description="Indicaciones adicionales"),
    consulta_nutricionista: bool = Form(False, description="¿Requiere revisión de nutricionista?"),
    alergias_ids: Optional[str] = Form(None, description="JSON list de IDs de alergias de especie"),
    descripcion_alergias: Optional[str] = Form(None, description="Descripción libre de alergias"),
    condiciones_salud: Optional[str] = Form(None, description="JSON list de objetos {nombre, fecha?}"),
    preferencias_alimentarias: Optional[str] = Form(None, description="JSON list (strings u objetos {nombre, descripcion?})"),
    receta_medica: UploadFile | None = File(None),
    archivo_adicional: UploadFile | None = File(None),
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    mascota = (
        db.query(RegistroMascota)
        .options(joinedload(RegistroMascota.especie))
        .filter(
            RegistroMascota.id == registro_mascota_id,
            RegistroMascota.cliente_id == cliente_id
        )
        .first()
    )
    if not mascota:
        raise HTTPException(status_code=404, detail="Mascota no encontrada o no pertenece al cliente.")
    if not frecuencia_cantidad or not objetivo_dieta:
        raise HTTPException(status_code=400, detail="Debe proporcionar 'frecuencia_cantidad' y 'objetivo_dieta'.")
    def parse_json_list(value: Optional[str], fallback_empty=True):
        if not value:
            return [] if fallback_empty else None
        try:
            parsed = json.loads(value)
            if isinstance(parsed, list):
                return parsed
            return [parsed]
        except Exception:
            raise HTTPException(status_code=400, detail="Formato JSON inválido en uno de los campos de lista.")
    alergias_list = parse_json_list(alergias_ids)  # lista de IDs (int/str)
    condiciones_list = parse_json_list(condiciones_salud)  # lista de objetos
    preferencias_list = parse_json_list(preferencias_alimentarias)  # lista (str u obj)
    pedido_id = keygen.generate_uint64_key()
    pedido = Pedido(
        id=pedido_id,
        cliente_id=cliente_id,
        fecha=datetime.now(),
        total=0,
        incluye_plato=False,
        estado="pendiente",
        direccion_id=None
    )
    db.add(pedido)
    db.flush()
    pedido_esp_id = keygen.generate_uint64_key()
    pedido_esp = PedidoEspecializado(
        id=pedido_esp_id,
        pedido_id=pedido_id,
        registro_mascota_id=registro_mascota_id,
        frecuencia_cantidad=frecuencia_cantidad,
        objetivo_dieta=objetivo_dieta,
        indicaciones_adicionales=indicaciones_adicionales,
        consulta_nutricionista=1 if consulta_nutricionista else 0,
        estado_registro="A",
    )
    db.add(pedido_esp)
    db.flush()
    uploads_dir = os.path.join("static", "uploads", "pedido_especializado")
    os.makedirs(uploads_dir, exist_ok=True)
    if archivo_adicional:
        extra_path = os.path.join(uploads_dir, f"extra_{pedido_esp_id}_{archivo_adicional.filename}")
        with open(extra_path, "wb") as f:
            f.write(archivo_adicional.file.read())
        pedido_esp.archivo_adicional = extra_path
    if receta_medica:
        receta_path = os.path.join(uploads_dir, f"receta_{pedido_esp_id}_{receta_medica.filename}")
        with open(receta_path, "wb") as f:
            f.write(receta_medica.file.read())
        receta = RecetaMedica(
            id=keygen.generate_uint64_key(),
            registro_mascota_id=registro_mascota_id,
            pedido_especializado_id=pedido_esp_id,
            fecha=datetime.now(),
            estado_registro="A",
            archivo=receta_path,
        )
        db.add(receta)
    for alergia_id in alergias_list:
        alergia_registro = AlergiaMascota(
            id=keygen.generate_uint64_key(),
            registro_mascota_id=registro_mascota_id,
            alergia_especie_id=int(alergia_id),
            severidad="moderada",
            estado_registro="A",
        )
        db.add(alergia_registro)
    if descripcion_alergias:
        desc = DescripcionAlergias(
            id=keygen.generate_uint64_key(),
            registro_mascota_id=registro_mascota_id,
            descripcion=descripcion_alergias,
            fecha=datetime.now(),
            estado_registro="A",
        )
        db.add(desc)
    for cond in condiciones_list:
        if isinstance(cond, dict):
            nombre = cond.get("nombre")
            fecha_txt = cond.get("fecha")
        else:
            nombre = str(cond)
            fecha_txt = None
        if not nombre:
            continue
        fecha_val = None
        if fecha_txt:
            try:
                fecha_val = datetime.fromisoformat(fecha_txt)
            except Exception:
                fecha_val = datetime.now()
        else:
            fecha_val = datetime.now()
        db.add(CondicionSalud(
            id=keygen.generate_uint64_key(),
            registro_mascota_id=registro_mascota_id,
            nombre=nombre,
            fecha=fecha_val,
            estado_registro="A",
        ))
    for pref in preferencias_list:
        if isinstance(pref, dict):
            nombre = pref.get("nombre")
            descripcion = pref.get("descripcion")
        else:
            nombre = str(pref)
            descripcion = None
        if not nombre:
            continue
        db.add(PreferenciaAlimentaria(
            id=keygen.generate_uint64_key(),
            registro_mascota_id=registro_mascota_id,
            nombre=nombre,
            estado_registro="A",
            descripcion=descripcion
        ))
    db.commit()
    return {
        "mensaje": "Pedido especializado creado exitosamente.",
        "pedido_id": str(pedido_id),
        "pedido_especializado_id": str(pedido_esp_id),
        "registro_mascota_id": str(registro_mascota_id),
        "consulta_nutricionista": bool(consulta_nutricionista),
        "resumen": {
            "alergias_registradas": len(alergias_list),
            "condiciones_salud_registradas": len(condiciones_list),
            "preferencias_alimentarias_registradas": len(preferencias_list),
            "descripcion_alergias_incluida": bool(descripcion_alergias),
            "receta_medica_adjunta": bool(receta_medica),
            "archivo_adicional_adjuntado": bool(archivo_adicional),
        }
    }

# ---------------------------------------------------------------------------
# GET /cliente/pedido-especializado/{cliente_id}
# ---------------------------------------------------------------------------
# Lista los pedidos especializados del cliente.
# Incluye estado, mascota asociada, objetivo, frecuencia y si requiere nutricionista.
@router.get("/especializado/{cliente_id}")
def listar_pedidos_especializados(
    cliente_id: str,
    db: Session = Depends(get_db),
):
    cliente = db.query(Cliente).filter(Cliente.id == cliente_id).first()
    if not cliente:
        raise HTTPException(status_code=404, detail="Cliente no encontrado.")
    pedidos = (
        db.query(PedidoEspecializado)
        .join(Pedido)
        .join(RegistroMascota)
        .filter(Pedido.cliente_id == cliente_id)
        .options(
            joinedload(PedidoEspecializado.pedido),
            joinedload(PedidoEspecializado.registro_mascota),
        )
        .order_by(Pedido.fecha.desc())
        .all()
    )
    if not pedidos:
        return {"mensaje": "No se encontraron pedidos especializados para este cliente."}
    resultado = []
    for p in pedidos:
        resultado.append({
            "pedido_especializado_id": str(p.id),
            "pedido_id": str(p.pedido_id),
            "fecha": p.pedido.fecha.isoformat() if p.pedido else None,
            "estado_pedido": p.pedido.estado if p.pedido else None,
            "mascota": {
                "id": str(p.registro_mascota.id) if p.registro_mascota else None,
                "nombre": p.registro_mascota.nombre if p.registro_mascota else None,
                "especie": p.registro_mascota.especie.nombre if p.registro_mascota and p.registro_mascota.especie else None,
            } if p.registro_mascota else None,
            "frecuencia_cantidad": p.frecuencia_cantidad,
            "objetivo_dieta": p.objetivo_dieta,
            "consulta_nutricionista": bool(p.consulta_nutricionista),
            "estado_registro": p.estado_registro,
        })
    return {"total": len(resultado), "pedidos_especializados": resultado}

# ---------------------------------------------------------------------------
# GET /cliente/pedido-especializado/detalle/{pedido_id}
# ---------------------------------------------------------------------------
# Devuelve los datos detallados de un pedido especializado:
# mascota, alergias, condiciones, preferencias, objetivo dieta, archivos adjuntos.
@router.get("/especializado/detalle/{pedido_id}")
def obtener_detalle_pedido_especializado(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    pedido_esp = (
        db.query(PedidoEspecializado)
        .options(
            joinedload(PedidoEspecializado.pedido).joinedload(Pedido.cliente),
            joinedload(PedidoEspecializado.registro_mascota)
                .joinedload(RegistroMascota.especie),
            joinedload(PedidoEspecializado.receta_medica),
        )
        .filter(PedidoEspecializado.pedido_id == pedido_id)
        .first()
    )
    if not pedido_esp:
        raise HTTPException(status_code=404, detail="Pedido especializado no encontrado.")
    pedido = pedido_esp.pedido
    mascota = pedido_esp.registro_mascota
    receta = pedido_esp.receta_medica[0] if pedido_esp.receta_medica else None
    alergias = db.query(AlergiaMascota).filter(AlergiaMascota.registro_mascota_id == mascota.id).all()
    condiciones = db.query(CondicionSalud).filter(CondicionSalud.registro_mascota_id == mascota.id).all()
    preferencias = db.query(PreferenciaAlimentaria).filter(PreferenciaAlimentaria.registro_mascota_id == mascota.id).all()
    descripcion = db.query(DescripcionAlergias).filter(DescripcionAlergias.registro_mascota_id == mascota.id).order_by(DescripcionAlergias.fecha.desc()).first()
    return {
        "pedido": {
            "id": str(pedido.id),
            "fecha": pedido.fecha.isoformat() if pedido.fecha else None,
            "estado": pedido.estado,
            "cliente": {
                "id": str(pedido.cliente.id) if pedido.cliente else None,
                "nombre": pedido.cliente.nombre if pedido.cliente else None,
                "telefono": pedido.cliente.telefono if pedido.cliente else None,
            } if pedido.cliente else None,
        },
        "pedido_especializado": {
            "id": str(pedido_esp.id),
            "frecuencia_cantidad": pedido_esp.frecuencia_cantidad,
            "objetivo_dieta": pedido_esp.objetivo_dieta,
            "indicaciones_adicionales": pedido_esp.indicaciones_adicionales,
            "consulta_nutricionista": bool(pedido_esp.consulta_nutricionista),
            "estado_registro": pedido_esp.estado_registro,
        },
        "mascota": {
            "id": str(mascota.id),
            "nombre": mascota.nombre,
            "especie": mascota.especie.nombre if mascota.especie else None,
            "edad": mascota.edad,
            "raza": mascota.raza,
            "peso": float(mascota.peso) if mascota.peso else None,
            "foto": mascota.foto,
        } if mascota else None,
        "detalles_nutricionales": {
            "alergias": [
                {
                    "id": str(a.id),
                    "alergia_especie_id": a.alergia_especie_id,
                    "severidad": a.severidad,
                } for a in alergias
            ],
            "descripcion_alergias": descripcion.descripcion if descripcion else None,
            "condiciones_salud": [
                {
                    "id": str(c.id),
                    "nombre": c.nombre,
                    "fecha": c.fecha.isoformat() if c.fecha else None,
                } for c in condiciones
            ],
            "preferencias_alimentarias": [
                {
                    "id": str(pf.id),
                    "nombre": pf.nombre,
                    "descripcion": pf.descripcion,
                } for pf in preferencias
            ],
        },
        "archivos": {
            "receta_medica": receta.archivo if receta else None,
            "archivo_adicional": pedido_esp.archivo_adicional,
        },
    }
</file>

<file path="backend/routers/cliente/perfil.py">
"""
RUTAS DEL CLIENTE – PERFIL Y DIRECCIONES DE ENTREGA
----------------------------------------------------
Permite al cliente actualizar su información personal y administrar sus
direcciones de entrega.

Incluye:
- Modificación de datos personales del cliente
- Cambio de foto de perfil
- Gestión de direcciones (crear, listar, editar, eliminar)
- Selección de dirección principal

Notas:
- IDs en formato `str` (por BIGINT).
- Las fotos de cliente se guardan en utils.globals.CLIENTE.
- Si no hay imagen, se usa CLIENTE/default.png.
- Solo accesibles para el propio cliente autenticado.
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile
from utils import globals

router = APIRouter(prefix="/cliente/perfil", tags=["Perfil del Cliente"])


# ---------------------------------------------------------------------------
# GET /cliente/perfil/{cliente_id}
# ---------------------------------------------------------------------------
# Devuelve los datos completos del perfil del cliente:
# nombre, teléfono, correo, membresía y foto.
@router.get("/{cliente_id}")
def obtener_perfil_cliente(cliente_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /cliente/perfil/{cliente_id}
# ---------------------------------------------------------------------------
# Actualiza la información personal del cliente.
# Campos editables: nombre, teléfono, correo electrónico.
@router.put("/{cliente_id}")
def actualizar_perfil_cliente(cliente_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /cliente/perfil/{cliente_id}/foto
# ---------------------------------------------------------------------------
# Permite subir o actualizar la foto de perfil del cliente.
# Si no se envía, se mantiene la actual; si se borra, vuelve a default.png.
@router.put("/{cliente_id}/foto")
def actualizar_foto_cliente(cliente_id: str, foto: UploadFile = None):
    pass


# ---------------------------------------------------------------------------
# GET /cliente/perfil/{cliente_id}/direcciones
# ---------------------------------------------------------------------------
# Lista todas las direcciones de entrega registradas por el cliente.
# Indica cuál es la dirección principal.
@router.get("/{cliente_id}/direcciones")
def listar_direcciones_cliente(cliente_id: str):
    pass


# ---------------------------------------------------------------------------
# POST /cliente/perfil/{cliente_id}/direcciones
# ---------------------------------------------------------------------------
# Crea una nueva dirección de entrega.
# Campos: nombre, latitud, longitud, referencia, es_principal.
@router.post("/{cliente_id}/direcciones")
def crear_direccion_cliente(cliente_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /cliente/perfil/direcciones/{direccion_id}
# ---------------------------------------------------------------------------
# Edita una dirección existente.
# Permite modificar nombre, coordenadas, referencia o marcar como principal.
@router.put("/direcciones/{direccion_id}")
def actualizar_direccion(direccion_id: str):
    pass


# ---------------------------------------------------------------------------
# DELETE /cliente/perfil/direcciones/{direccion_id}
# ---------------------------------------------------------------------------
# Elimina (o marca como inactiva) una dirección de entrega del cliente.
@router.delete("/direcciones/{direccion_id}")
def eliminar_direccion(direccion_id: str):
    pass


# ---------------------------------------------------------------------------
# PUT /cliente/perfil/direcciones/{direccion_id}/principal
# ---------------------------------------------------------------------------
# Marca una dirección como principal y desmarca las demás.
@router.put("/direcciones/{direccion_id}/principal")
def establecer_direccion_principal(direccion_id: str):
    pass
</file>

<file path="backend/routers/cliente/platos_mascotas.py">
from fastapi import APIRouter, Depends, HTTPException, Request, Query
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import or_
from utils.db import get_db
from utils.globals import PLATO
from models import PlatoCombinado, Categoria, Especie, EtiquetaPlato, Etiqueta
from slugify import slugify

router = APIRouter(
    prefix="/cliente/platos-mascotas",
    tags=["Cliente - Platos para Mascotas"]
)

# ---------------------------------------------------------------------------
# 🖼️ Utilidad: construir URL completa para la imagen
# ---------------------------------------------------------------------------
def construir_url_imagen(request: Request, nombre_archivo: str | None):
    """Construye una URL completa para acceder a la imagen."""
    if not nombre_archivo:
        return None
    base = str(request.base_url).rstrip("/")
    path = PLATO.strip("/")
    return f"{base}/{path}/{nombre_archivo.lstrip('/')}"

# ---------------------------------------------------------------------------
# 🧩 Utilidad: convertir PlatoCombinado → dict JSON serializable
# ---------------------------------------------------------------------------
def plato_to_dict(p: PlatoCombinado, request: Request):
    """Convierte un PlatoCombinado en un diccionario listo para JSON."""
    return {
        "id": str(p.id),
        "nombre": p.nombre,
        "descripcion": p.descripcion,
        "precio": float(p.precio),
        "imagen": construir_url_imagen(request, p.imagen),
        "categoria": p.categoria.nombre if p.categoria else None,
        "especie": p.especie.nombre if p.especie else None,
        "etiquetas": [ep.etiqueta.nombre for ep in p.etiqueta_plato],
    }

# ---------------------------------------------------------------------------
# 🥘 GET /cliente/platos-mascotas
# ---------------------------------------------------------------------------
@router.get(
    "/", 
    summary="Listar platos con filtros por categoría, especie o etiquetas",
)
def listar_platos(
    request: Request,
    db: Session = Depends(get_db),
    categoria_id: str | None = Query(None, description="ID de la categoría"),
    especie_id: str | None = Query(None, description="ID de la especie"),
    etiquetas: list[str] | None = Query(None, description="IDs de etiquetas"),
    search: str | None = Query(None, description="Texto libre para búsqueda"),
):
    """
    Lista platos combinados filtrando por:
    - categoría
    - especie
    - etiquetas (una o varias)
    - texto libre (nombre o descripción)

    Solo devuelve platos activos y publicados.
    """
    query = (
        db.query(PlatoCombinado)
        .options(
            joinedload(PlatoCombinado.categoria),
            joinedload(PlatoCombinado.especie),
            joinedload(PlatoCombinado.etiqueta_plato).joinedload(EtiquetaPlato.etiqueta),
        )
        .filter(
            PlatoCombinado.estado_registro == "A",
            PlatoCombinado.publicado == 1,
        )
    )
    print("📥 Filtros recibidos →", categoria_id, especie_id, etiquetas, search)
    # Filtros combinados
    if categoria_id:
        query = query.filter(PlatoCombinado.categoria_id == categoria_id)
    if especie_id:
        query = query.filter(PlatoCombinado.especie_id == especie_id)
    if etiquetas and len(etiquetas) > 0:
        query = query.filter(
            PlatoCombinado.etiqueta_plato.any(
                EtiquetaPlato.etiqueta_id.in_(etiquetas)
            )
        )
    if search:
        search_like = f"%{search.lower()}%"
        query = query.filter(
            or_(
                PlatoCombinado.nombre.ilike(search_like),
                PlatoCombinado.descripcion.ilike(search_like),
                PlatoCombinado.etiqueta_plato.any(
                    EtiquetaPlato.etiqueta.has(Etiqueta.nombre.ilike(search_like))
                ),
            )
        )
    platos = query.all()
    return [plato_to_dict(p, request) for p in platos]
# ---------------------------------------------------------------------------
# 🔍 GET /cliente/platos-mascotas/id/{plato_id}
# ---------------------------------------------------------------------------
@router.get("/id/{plato_id}", summary="Obtener detalles de un plato")
def obtener_plato(plato_id: str, request: Request, db: Session = Depends(get_db)):
    """Devuelve la información detallada de un plato específico."""
    plato = (
        db.query(PlatoCombinado)
        .options(
            joinedload(PlatoCombinado.categoria),
            joinedload(PlatoCombinado.especie),
            joinedload(PlatoCombinado.etiqueta_plato).joinedload(EtiquetaPlato.etiqueta),
        )
        .filter(
            PlatoCombinado.id == plato_id,
            PlatoCombinado.estado_registro == "A",
            PlatoCombinado.publicado == 1,
        )
        .first()
    )

    if not plato:
        raise HTTPException(status_code=404, detail="Plato no encontrado")

    return plato_to_dict(plato, request)

# ---------------------------------------------------------------------------
# 📂 GET /cliente/platos-mascotas/categorias
# ---------------------------------------------------------------------------
@router.get("/categorias", summary="Listar categorías activas")
def listar_categorias(db: Session = Depends(get_db)):
    """Devuelve todas las categorías activas con slug."""
    categorias = db.query(Categoria).filter(Categoria.estado_registro == "A").all()
    return [
        {
            "id": str(c.id),
            "nombre": c.nombre,
            "descripcion": c.descripcion,
            "slug": slugify(c.nombre, separator="-"),
        }
        for c in categorias
    ]

# ---------------------------------------------------------------------------
# 🧬 GET /cliente/platos-mascotas/especies
# ---------------------------------------------------------------------------
@router.get("/especies", summary="Listar especies (solo perros y gatos)")
def listar_especies(db: Session = Depends(get_db)):
    """Devuelve las especies activas (solo Perros y Gatos)."""
    especies = db.query(Especie).filter(Especie.estado_registro == "A").all()
    return [{"id": str(e.id), "nombre": e.nombre} for e in especies]

# ---------------------------------------------------------------------------
# 🏷️ GET /cliente/platos-mascotas/etiquetas
# ---------------------------------------------------------------------------
@router.get("/etiquetas", summary="Listar etiquetas asociadas a platos publicados")
def listar_etiquetas(db: Session = Depends(get_db)):
    """Devuelve las etiquetas vinculadas a platos activos y publicados."""
    etiquetas = (
        db.query(Etiqueta)
        .join(Etiqueta.etiqueta_plato)
        .join(EtiquetaPlato.plato_combinado)
        .filter(
            PlatoCombinado.estado_registro == "A",
            PlatoCombinado.publicado == 1,
        )
        .distinct()
        .all()
    )
    return [{"id": str(e.id), "nombre": e.nombre} for e in etiquetas]


@router.get("/especies/{especie_id}/razas", summary="Listar razas por especie")
def listar_razas_por_especie(especie_id: str):
    """
    Devuelve una lista predefinida de razas según el ID de la especie.
    Esto es un ejemplo, en un futuro podría venir de la base de datos.
    """
    # Convertimos el ID a entero para comparar
    try:
        especie_id_int = int(especie_id)
    except ValueError:
        raise HTTPException(status_code=400, detail="El ID de la especie debe ser un número.")

    razas_perro = ["Mestizo", "Labrador Retriever", "Bulldog Francés", "Pastor Alemán", "Golden Retriever", "Chihuahua", "Beagle"]
    razas_gato = ["Mestizo", "Siamés", "Persa", "Maine Coon", "Bengalí", "Ragdoll", "Esfinge"]

    if especie_id_int == 1: # ID de Perro
        return sorted(razas_perro)
    elif especie_id_int == 2: # ID de Gato
        return sorted(razas_gato)
    else:
        return ["No especificado"] # Para otras especies o si el ID es inválido
</file>

<file path="backend/routers/cliente/subscripciones.py">
"""
RUTAS DEL CLIENTE – SUBSCRIPCIONES Y MEMBRESÍAS
------------------------------------------------
Permite al cliente consultar los planes disponibles, suscribirse a uno,
ver su suscripción activa y cancelar su membresía si lo desea.

Incluye:
- Listado de planes activos
- Detalle de un plan
- Suscripción a un plan
- Consulta de la membresía actual del cliente
- Cancelación o cambio de suscripción

Notas:
- IDs en formato `str` (por BIGINT).
- Los planes se gestionan en la tabla `membresia_subscripcion`.
- La relación cliente–plan está en `cliente.membresia_subscripcion_id`.
- Campo `estado_registro`: "A" (activo), "I" (inactivo).
"""

from fastapi import APIRouter, Depends, HTTPException
from utils import keygen

router = APIRouter(prefix="/cliente/subscripciones", tags=["Subscripciones del Cliente"])


# ---------------------------------------------------------------------------
# GET /cliente/subscripciones
# ---------------------------------------------------------------------------
# Lista todos los planes de membresía activos disponibles.
# Incluye nombre, duración, precio y beneficios.
@router.get("/")
def listar_planes_activos():
    pass


# ---------------------------------------------------------------------------
# GET /cliente/subscripciones/{subscripcion_id}
# ---------------------------------------------------------------------------
# Obtiene los detalles de un plan específico.
# Retorna precio, descripción y beneficios.
@router.get("/{subscripcion_id}")
def obtener_detalle_plan(subscripcion_id: str):
    pass


# ---------------------------------------------------------------------------
# GET /cliente/subscripciones/{cliente_id}/actual
# ---------------------------------------------------------------------------
# Devuelve la membresía actual del cliente (si tiene una activa).
# Incluye nombre del plan, fecha de inicio y duración restante.
@router.get("/{cliente_id}/actual")
def obtener_subscripcion_actual(cliente_id: str):
    pass


# ---------------------------------------------------------------------------
# POST /cliente/subscripciones/{cliente_id}/suscribirse/{subscripcion_id}
# ---------------------------------------------------------------------------
# Permite al cliente suscribirse a un plan.
# Si ya tiene una membresía activa, puede actualizarla o reemplazarla.
@router.post("/{cliente_id}/suscribirse/{subscripcion_id}")
def suscribirse_plan(cliente_id: str, subscripcion_id: str):
    pass


# ---------------------------------------------------------------------------
# DELETE /cliente/subscripciones/{cliente_id}/cancelar
# ---------------------------------------------------------------------------
# Cancela la suscripción actual del cliente.
# Actualiza `cliente.membresia_subscripcion_id` a NULL.
@router.delete("/{cliente_id}/cancelar")
def cancelar_subscripcion(cliente_id: str):
    pass
</file>

<file path="backend/routers/nutricionista.py">
"""
RUTAS DEL NUTRICIONISTA – REVISIÓN Y APROBACIÓN DE PEDIDOS
------------------------------------------------------------
Permite al nutricionista revisar, aprobar o sugerir modificaciones en
pedidos especializados de los clientes.

Incluye:
- Consulta de pedidos especializados pendientes de revisión
- Revisión de recetas médicas y archivos adjuntos
- Aprobación o rechazo de pedidos especializados
- Creación de platos personalizados para mascotas específicas
- Registro de observaciones y recomendaciones

Notas:
- IDs en formato `str` (por BIGINT).
- Las claves nuevas (por ejemplo, de platos creados) se generan con
  utils.keygen.generate_uint64_key().
- Los platos creados por nutricionista se guardan con:
  creado_nutricionista = 1 y publicado = 0 (por defecto).
"""

from fastapi import APIRouter, Depends, HTTPException, UploadFile
from utils import keygen, globals

router = APIRouter(prefix="/nutricionista", tags=["Nutricionista"])


# ---------------------------------------------------------------------------
# GET /nutricionista/pedidos/pendientes
# ---------------------------------------------------------------------------
# Lista los pedidos especializados pendientes de revisión.
# Muestra información de la mascota, cliente, objetivo de dieta y fecha de solicitud.
@router.get("/pedidos/pendientes")
def listar_pedidos_pendientes():
    pass


# ---------------------------------------------------------------------------
# GET /nutricionista/pedidos/{pedido_id}
# ---------------------------------------------------------------------------
# Devuelve los detalles de un pedido especializado específico:
# mascota, archivos adjuntos, receta médica, y observaciones previas.
@router.get("/pedidos/{pedido_id}")
def obtener_detalle_pedido_especializado(pedido_id: str):
    pass


# ---------------------------------------------------------------------------
# POST /nutricionista/pedidos/{pedido_id}/revisar
# ---------------------------------------------------------------------------
# Permite al nutricionista registrar una revisión:
# Campos: observaciones, recomendaciones, aprobado (bool).
# Si se aprueba, se actualiza el estado del pedido especializado.
@router.post("/pedidos/{pedido_id}/revisar")
def revisar_pedido_especializado(pedido_id: str):
    pass


# ---------------------------------------------------------------------------
# POST /nutricionista/pedidos/{pedido_id}/receta
# ---------------------------------------------------------------------------
# Adjunta o actualiza una receta médica relacionada a un pedido especializado.
# Permite subir un archivo (PDF, imagen, etc.) que se guarda en el servidor.
@router.post("/pedidos/{pedido_id}/receta")
def subir_receta_medica(pedido_id: str, archivo: UploadFile):
    pass


# ---------------------------------------------------------------------------
# POST /nutricionista/platos/personalizados
# ---------------------------------------------------------------------------
# Crea un nuevo plato personalizado asociado a una mascota específica.
# Campos: nombre, descripcion, precio, especie_id, registro_mascota_id, imagen (opcional).
# Estos platos no se publican globalmente.
@router.post("/platos/personalizados")
def crear_plato_personalizado(imagen: UploadFile = None):
    pass


# ---------------------------------------------------------------------------
# GET /nutricionista/platos/personalizados/{mascota_id}
# ---------------------------------------------------------------------------
# Lista los platos personalizados creados para una mascota específica.
@router.get("/platos/personalizados/{mascota_id}")
def listar_platos_personalizados(mascota_id: str):
    pass


# ---------------------------------------------------------------------------
# GET /nutricionista/historial
# ---------------------------------------------------------------------------
# Devuelve el historial de pedidos revisados por el nutricionista.
# Incluye fecha, mascota, cliente y resultado (aprobado/rechazado).
@router.get("/historial")
def listar_historial_revisiones():
    pass
</file>

<file path="backend/routers/repartidor.py">
"""
RUTAS DEL REPARTIDOR – CONTROL DE ENTREGA
------------------------------------------
Permite al repartidor gestionar y actualizar el estado de sus pedidos asignados,
así como consultar su historial de entregas.
Incluye:
- Listado de pedidos pendientes o asignados al repartidor.
- Consulta detallada de un pedido específico.
- Registro de entrega completada (confirmación de entrega).
- Registro de pedido devuelto.
- Historial de pedidos entregados o devueltos.
Notas:
- IDs manejados como `str` (por BIGINT).
- Los cambios de estado se reflejan en las tablas `pedido` y `control_entrega`.
- Campo `confirmacion_entrega`:
    * 1 → Entregado
    * 0 → Pendiente o devuelto
- Solo el repartidor autenticado puede acceder o modificar sus propios pedidos.
"""
from sqlalchemy.orm import joinedload, Session
from fastapi import APIRouter, Depends, HTTPException
from utils import keygen
from utils.db import get_db
from datetime import datetime
router = APIRouter(prefix="/repartidor", tags=["Repartidor"])

# ---------------------------------------------------------------------------
# GET /repartidor/{repartidor_id}/pedidos
# ---------------------------------------------------------------------------
# Lista todos los pedidos asignados al repartidor (pendientes de entrega).
# Incluye cliente, dirección, estado y fecha del pedido.
# Si el repartidor no existe o no tiene pedidos pendientes, retorna un mensaje informativo.
@router.get("/{repartidor_id}/pedidos")
def listar_pedidos_asignados(
    repartidor_id: str,
    db: Session = Depends(get_db),
):
    # Verificar si el repartidor existe
    repartidor = db.query(Repartidor).filter(Repartidor.id == repartidor_id).first()
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    entregas = (
        db.query(ControlEntrega)
        .join(ControlEntrega.pedido)
        .options(
            joinedload(ControlEntrega.pedido).joinedload(Pedido.cliente),
            joinedload(ControlEntrega.pedido).joinedload(Pedido.direccion)
        )
        .filter(ControlEntrega.repartidor_id == repartidor_id)
        .filter(ControlEntrega.confirmacion_entrega == 0) 
        .order_by(Pedido.fecha.asc())
        .all()
    )
    if not entregas:
        return {"mensaje": "No hay pedidos pendientes asignados a este repartidor."}
    pedidos = []
    for ctrl in entregas:
        pedido = ctrl.pedido
        cliente = pedido.cliente if pedido else None
        direccion = pedido.direccion if pedido else None
        pedidos.append({
            "pedido_id": str(pedido.id),
            "fecha_pedido": pedido.fecha.isoformat(),
            "estado_pedido": pedido.estado,
            "total": float(pedido.total),
            "cliente": {
                "id": str(cliente.id),
                "nombre": cliente.nombre,
                "telefono": cliente.telefono,
            } if cliente else None,
            "direccion": {
                "nombre": direccion.nombre if direccion else None,
                "referencia": direccion.referencia if direccion else None,
                "latitud": float(direccion.latitud) if direccion else None,
                "longitud": float(direccion.longitud) if direccion else None,
            } if direccion else None,
        })
    return {
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
        },
        "total_pedidos_pendientes": len(pedidos),
        "pedidos": pedidos,
    }

# ---------------------------------------------------------------------------
# GET /repartidor/pedidos/{pedido_id}
# ---------------------------------------------------------------------------
# Devuelve los detalles de un pedido asignado al repartidor.
# Incluye cliente, dirección, platos, total y confirmación de entrega.
@router.get("/pedidos/{pedido_id}")
def obtener_detalle_pedido_asignado(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    control = (
        db.query(ControlEntrega)
        .options(
            joinedload(ControlEntrega.pedido)
            .joinedload(Pedido.cliente),
            joinedload(ControlEntrega.pedido)
            .joinedload(Pedido.direccion),
            joinedload(ControlEntrega.pedido)
            .joinedload(Pedido.detalle_pedido)
            .joinedload(DetallePedido.plato_combinado),
            joinedload(ControlEntrega.repartidor)
        )
        .filter(ControlEntrega.pedido_id == pedido_id)
        .first()
    )
    if not control:
        raise HTTPException(status_code=404, detail="El pedido no está asignado o no existe.")
    pedido = control.pedido
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado en la base de datos.")
    cliente = pedido.cliente
    direccion = pedido.direccion
    repartidor = control.repartidor
    platos_info = []
    for det in pedido.detalle_pedido:
        platos_info.append({
            "id": str(det.id),
            "plato": det.plato_combinado.nombre if det.plato_combinado else None,
            "cantidad": det.cantidad,
            "subtotal": float(det.subtotal),
        })
    respuesta = {
        "pedido": {
            "id": str(pedido.id),
            "fecha": pedido.fecha.isoformat(),
            "total": float(pedido.total),
            "estado": pedido.estado,
            "confirmacion_entrega": bool(control.confirmacion_entrega),
        },
        "cliente": {
            "id": str(cliente.id),
            "nombre": cliente.nombre,
            "telefono": cliente.telefono,
        } if cliente else None,
        "direccion": {
            "id": str(direccion.id),
            "nombre": direccion.nombre,
            "referencia": direccion.referencia,
            "latitud": float(direccion.latitud),
            "longitud": float(direccion.longitud),
        } if direccion else None,
        "platos": platos_info,
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
        } if repartidor else None,
    }
    return respuesta


# ---------------------------------------------------------------------------
# PUT /repartidor/pedidos/{pedido_id}/entregado
# ---------------------------------------------------------------------------
# Marca el pedido como entregado y actualiza la fecha y confirmación de entrega.
@router.put("/pedidos/{pedido_id}/entregado")
def marcar_pedido_completado(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    control = db.query(ControlEntrega).filter(ControlEntrega.pedido_id == pedido_id).first()
    if not control:
        raise HTTPException(status_code=404, detail="El pedido no está asignado o no existe.")
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado en la base de datos.")
    if pedido.estado == "entregado" and control.confirmacion_entrega == 1:
        return {"mensaje": "El pedido ya fue marcado como entregado anteriormente."}
    pedido.estado = "entregado"
    control.confirmacion_entrega = 1
    control.fecha_entrega = datetime.now()
    db.commit()
    return {
        "mensaje": "El pedido ha sido marcado como entregado correctamente.",
        "pedido": {
            "id": str(pedido.id),
            "estado": pedido.estado,
            "fecha_entrega": control.fecha_entrega.isoformat(),
            "confirmacion_entrega": True,
        },
    }

# ---------------------------------------------------------------------------
# PUT /repartidor/pedidos/{pedido_id}/devuelto
# ---------------------------------------------------------------------------
# Marca el pedido como devuelto.
# Cambia `pedido.estado` a "devuelto" y `confirmacion_entrega` a 0.
@router.put("/pedidos/{pedido_id}/devuelto")
def marcar_pedido_devuelto(
    pedido_id: str,
    db: Session = Depends(get_db),
):
    control = db.query(ControlEntrega).filter(ControlEntrega.pedido_id == pedido_id).first()
    if not control:
        raise HTTPException(status_code=404, detail="El pedido no está asignado o no existe en el control de entrega.")
    pedido = db.query(Pedido).filter(Pedido.id == pedido_id).first()
    if not pedido:
        raise HTTPException(status_code=404, detail="Pedido no encontrado en la base de datos.")
    if pedido.estado in ["entregado", "cancelado"]:
        raise HTTPException(status_code=400, detail=f"No se puede marcar un pedido '{pedido.estado}' como devuelto.")
    pedido.estado = "devuelto"
    control.confirmacion_entrega = 0
    control.fecha_entrega = datetime.now()
    db.commit()
    return {
        "mensaje": "El pedido ha sido marcado como devuelto correctamente.",
        "pedido": {
            "id": str(pedido.id),
            "estado": pedido.estado,
            "fecha_actualizacion": control.fecha_entrega.isoformat(),
            "confirmacion_entrega": False,
        },
    }

# ---------------------------------------------------------------------------
# GET /repartidor/{repartidor_id}/historial
# ---------------------------------------------------------------------------
# Devuelve el historial de entregas completadas o devueltas del repartidor.
# Incluye fecha, estado final, cliente y total del pedido.
@router.get("/{repartidor_id}/historial")
def listar_historial_entregas(
    repartidor_id: str,
    db: Session = Depends(get_db),
):
    repartidor = db.query(Repartidor).filter(Repartidor.id == repartidor_id).first()
    if not repartidor:
        raise HTTPException(status_code=404, detail="Repartidor no encontrado.")
    entregas = (
        db.query(ControlEntrega)
        .join(ControlEntrega.pedido)
        .options(
            joinedload(ControlEntrega.pedido).joinedload(Pedido.cliente)
        )
        .filter(ControlEntrega.repartidor_id == repartidor_id)
        .filter(Pedido.estado.in_(["entregado", "devuelto"]))
        .order_by(ControlEntrega.fecha_entrega.desc())
        .all()
    )
    if not entregas:
        return {"mensaje": "No se encontraron entregas completadas o devueltas para este repartidor."}
    historial = []
    for ctrl in entregas:
        pedido = ctrl.pedido
        cliente = pedido.cliente if pedido else None
        historial.append({
            "pedido_id": str(pedido.id),
            "fecha_pedido": pedido.fecha.isoformat(),
            "fecha_entrega": ctrl.fecha_entrega.isoformat() if ctrl.fecha_entrega else None,
            "estado_final": pedido.estado,
            "total": float(pedido.total),
            "cliente": {
                "id": str(cliente.id) if cliente else None,
                "nombre": cliente.nombre if cliente else None,
                "telefono": cliente.telefono if cliente else None,
            } if cliente else None,
        })
    return {
        "repartidor": {
            "id": str(repartidor.id),
            "nombre": repartidor.nombre,
            "telefono": repartidor.telefono,
        },
        "total_registros": len(historial),
        "historial": historial,
    }
</file>

<file path="backend/seed_data.py">
# backend/seed_data.py (VERSIÓN FINAL)

from utils.db import SessionLocal
from models import Categoria, Especie, PlatoCombinado, Rol 
from utils import keygen

def seed_database():
    db = SessionLocal()
    try:
        from models import Base
        from utils.db import engine
        Base.metadata.create_all(bind=engine)

        print("👤 Insertando roles...")
        roles = [
            {'id': 1, 'nombre': 'admin', 'desc': 'Administrador del sistema'},
            {'id': 2, 'nombre': 'cliente', 'desc': 'Usuario cliente de la aplicación'},
            {'id': 3, 'nombre': 'nutricionista', 'desc': 'Profesional de nutrición animal'},
            {'id': 4, 'nombre': 'repartidor', 'desc': 'Encargado de las entregas'}
        ]
        
        for r_data in roles:
            existing = db.query(Rol).filter(Rol.id == r_data['id']).first()
            if not existing:
                rol = Rol(
                    id=r_data['id'],  # <-- Usamos el ID fijo del diccionario
                    nombre=r_data['nombre'], 
                    estado_registro='A', 
                    descripcion=r_data['desc']
                )
                db.add(rol)
                print(f"  ✅ Rol '{rol.nombre}' agregado con ID {rol.id}")
            else:
                 print(f"  ⚠️  Rol '{existing.nombre}' ya existe con ID {existing.id}")

        db.commit()

        print("📂 Insertando categorías...")
        nombres_categorias = ["Platos caseros", "Ensaladas", "Postres", "Bebidas"]
        ids_categorias = {}
        for nombre_cat in nombres_categorias:
            existing = db.query(Categoria).filter(Categoria.nombre == nombre_cat).first()
            if not existing:
                nueva_cat = Categoria(id=keygen.generate_uint64_key(), nombre=nombre_cat, estado_registro="A")
                db.add(nueva_cat)
                db.flush()
                ids_categorias[nombre_cat] = nueva_cat.id
            else:
                ids_categorias[nombre_cat] = existing.id
        db.commit()

        print("\n🐾 Insertando especies...")
        nombres_especies = ["Perro", "Gato"]
        ids_especies = {}
        for nombre_esp in nombres_especies:
            existing = db.query(Especie).filter(Especie.nombre == nombre_esp).first()
            if not existing:
                nueva_esp = Especie(id=keygen.generate_uint64_key(), nombre=nombre_esp, estado_registro="A")
                db.add(nueva_esp)
                db.flush()
                ids_especies[nombre_esp] = nueva_esp.id
            else:
                ids_especies[nombre_esp] = existing.id
        db.commit()
        
        print("\n🍽️  Insertando platos de ejemplo...")
        platos = [
            { "nombre": "BARF Pollo Balanceado", "precio": 28.00, "categoria": "Platos caseros", "especie": "Perro", "descripcion": "Dieta BARF a base de pollo con vísceras...", "imagen": "barf_pollo.png" },
            { "nombre": "BARF Ternera Premium", "precio": 32.00, "categoria": "Platos caseros", "especie": "Perro", "descripcion": "Dieta BARF de ternera con corazón de res...", "imagen": "barf_ternera.png" },
            { "nombre": "BARF Pato para Gato", "precio": 30.00, "categoria": "Platos caseros", "especie": "Gato", "descripcion": "Dieta BARF especial para gatos con carne de pato.", "imagen": "barf_pato_gato.png" }
        ]
        
        db.query(PlatoCombinado).delete()
        db.commit()

        for plato_data in platos:
            plato = PlatoCombinado(
                id=keygen.generate_uint64_key(),
                nombre=plato_data["nombre"],
                precio=plato_data["precio"],
                categoria_id=ids_categorias.get(plato_data["categoria"]),
                especie_id=ids_especies.get(plato_data["especie"]),
                descripcion=plato_data["descripcion"],
                imagen=plato_data["imagen"],
                publicado=1, estado_registro="A", incluye_plato=1, es_crudo=0, creado_nutricionista=0
            )
            db.add(plato)
        db.commit()
        print("\n✅ ¡Datos de ejemplo insertados correctamente!")
        
    except Exception as e:
        db.rollback()
        print(f"\n❌ Error al insertar datos: {str(e)}")
    finally:
        db.close()

if __name__ == "__main__":
    print("🌱 Iniciando inserción de datos de ejemplo...\n")
    seed_database()
</file>

<file path="backend/utils/db.py">
#utils/db.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
# Datos de conexión a MySQL
DATABASE_URL = "mysql+pymysql://root:@localhost/mascotas"
# Crea el motor de conexión
engine = create_engine(DATABASE_URL, echo=True)
# Sesión para interactuar con la base de datos
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
# Clase base para modelos (ORM)
Base = declarative_base()
# 🔹 ESTA FUNCIÓN ES CLAVE
def get_db():
    """Crea y cierra la sesión de base de datos para cada solicitud."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="backend/utils/globals.py">
#utils/globals.py
IMAGEN = "static/imagenes/"
PLATO = f"{IMAGEN}/plato/"
QR = f"{IMAGEN}/qr/"
MASCOTA = f"{IMAGEN}/mascota/"
CLIENTE = f"{IMAGEN}/cliente/"
</file>

<file path="backend/utils/keygen.py">
#/utils/keygen.py
import secrets

# Máximo número permitido por BIGINT UNSIGNED de MySQL
MAX_UINT64 = 18446744073709551615

def generate_uint64_key() -> str:
    """
    Genera un número aleatorio válido para BIGINT UNSIGNED (hasta 20 dígitos).
    Puede variar en longitud (no siempre 20 dígitos).
    """
    val = secrets.randbelow(MAX_UINT64) + 1
    return str(val)

def generate_full_20digit_key() -> str:
    """
    Genera una clave de exactamente 20 dígitos.
    Se debe almacenar como CHAR(20) o VARCHAR(20) si quieres conservar los dígitos completos.
    """
    digits = ''.join(str(secrets.randbelow(10)) for _ in range(20))
    if digits[0] == '0':  # evitar que empiece en 0 si no lo quieres
        digits = str(secrets.randbelow(9) + 1) + digits[1:]
    return digits
</file>

<file path="backend/utils/security.py">
# backend/utils/security.py

from passlib.context import CryptContext

# ✅ CAMBIO: Ahora usamos 'argon2' como el método principal.
# Es más moderno y no tiene los problemas de compilación de bcrypt en Windows.
pwd_context = CryptContext(schemes=["argon2", "bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verifica si la contraseña en texto plano coincide con la contraseña hasheada.
    """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """
    Genera un hash de una contraseña en texto plano usando Argon2.
    """
    return pwd_context.hash(password)
</file>

<file path="backend/utils/token_manager.py">
# backend/utils/token_manager.py

import jwt
from datetime import datetime, timedelta

SECRET_KEY = "mi_clave_secreta_super_segura_2024"  # ← Cámbiala en producción
ALGORITHM = "HS256"

def generar_token(user_id: int, rol_id: int, duracion_horas: int = 12) -> str:
    """
    Genera un token JWT con ID de usuario y rol.
    """
    payload = {
        "user_id": str(user_id),  # ← Convertir a string
        "rol_id": rol_id,
        "exp": datetime.utcnow() + timedelta(hours=duracion_horas)
    }
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

def decodificar_token(token: str) -> dict:
    """
    Decodifica y valida un token JWT.
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise Exception("Token expirado")
    except jwt.InvalidTokenError:
        raise Exception("Token inválido")
</file>

<file path="frontend/App.js">
import React from 'react';
import AppNavigator from './AppNavigator';

export default function App() {
  return <AppNavigator />;
}
</file>

<file path="frontend/app.json">
{
  "expo": {
    "name": "PawPalsApp",
    "slug": "PawPalsApp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "favicon": "./assets/favicon.png"
    }
  }
}
</file>

<file path="frontend/AppNavigator.js">
// frontend/AppNavigator.js

import React from 'react';
import { View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import { createDrawerNavigator } from '@react-navigation/drawer';

// Importar todas las pantallas
import SplashScreen from './screens/SplashScreen';
import WelcomeScreen from './screens/WelcomeScreen';
import LoginScreen from './screens/LoginScreen';
import RegisterScreen from './screens/RegisterScreen';
import SuccessScreen from './screens/SuccessScreen';
import HomeScreen from './screens/HomeScreen';
import ProductDetailScreen from './screens/ProductDetailScreen';
import FavoritesScreen from './screens/FavoritesScreen';
import PetProfileScreen from './screens/PetProfileScreen';
import CartScreen from './screens/CartScreen';
import CheckoutScreen from './screens/CheckoutScreen';
import PaymentScreen from './screens/PaymentScreen'; // ✅ NUEVO
import OrderSuccessScreen from './screens/OrderSuccessScreen';
import AddAddressScreen from './screens/AddAddressScreen';
// import UploadProofScreen from './screens/UploadProofScreen';
import AddPetScreen from './screens/AddPetScreen';
import UserProfileScreen from './screens/UserProfileScreen';


const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();
const Drawer = createDrawerNavigator();

/* ======================================================
   Navegador Principal con Menú Lateral (Drawer)
====================================================== */
function DrawerNavigator({ route }) {
  const { clienteId } = route.params;
  return (
    <Drawer.Navigator
      screenOptions={{ headerShown: false }}
    // Aquí podrías agregar un componente de menú personalizado si quieres
    >
      <Drawer.Screen name="AppTabs" component={MainTabs} initialParams={{ clienteId }} />
      {/* Puedes agregar más ítems al menú aquí si quieres */}
    </Drawer.Navigator>
  );
}

/* ======================================================
   Stack para Home → Detalle de Producto
====================================================== */
function HomeStack({ route }) {
  const { clienteId } = route.params || {};
  return (
    <Stack.Navigator screenOptions={{ headerShown: false }}>
      <Stack.Screen
        name="HomeFeed"
        component={HomeScreen}
        initialParams={{ clienteId }}
      />
      <Stack.Screen
        name="ProductDetail"
        component={ProductDetailScreen}
      />
    </Stack.Navigator>
  );
}

/* ======================================================
   Navegador de Tabs Principal
====================================================== */
function MainTabs({ route }) {
  const { clienteId } = route.params || {};
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarShowLabel: true,
        tabBarStyle: {
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          elevation: 5,
          backgroundColor: '#875686',
          borderTopLeftRadius: 30,
          borderTopRightRadius: 30,
          height: 90,
          borderTopWidth: 0,
          paddingTop: 10,
        },
        tabBarLabelStyle: {
          color: 'white',
          fontSize: 12,
          marginBottom: 20,
        },
        tabBarActiveTintColor: '#FF8C42',
        tabBarInactiveTintColor: 'white',
        tabBarItemStyle: {
          paddingBottom: 5,
          height: '100%',
        },
        tabBarIcon: ({ focused }) => {
          let iconName;
          if (route.name === 'HomeStack') iconName = 'home';
          else if (route.name === 'PetProfile') iconName = 'paw';
          else if (route.name === 'Cart') iconName = 'cart';
          else if (route.name === 'Favorites') iconName = 'heart';

          if (focused) {
            return (
              <View
                style={{
                  backgroundColor: '#FF8C42',
                  width: 60,
                  height: 60,
                  borderRadius: 30,
                  justifyContent: 'center',
                  alignItems: 'center',
                  transform: [{ translateY: -20 }],
                  elevation: 8,
                  shadowColor: '#000',
                  shadowOffset: { width: 0, height: 4 },
                  shadowOpacity: 0.3,
                  shadowRadius: 4.65,
                }}
              >
                <Ionicons name={iconName} size={30} color="white" />
              </View>
            );
          }
          return (
            <View>
              <Ionicons name={iconName} size={24} color="white" />
            </View>
          );
        },
      })}
    >
      <Tab.Screen
        name="HomeStack"
        component={HomeStack}
        initialParams={{ clienteId }}
        options={{ tabBarLabel: 'Inicio' }}
      />
      <Tab.Screen
        name="PetProfile"
        component={PetProfileScreen}
        initialParams={{ clienteId }}
        options={{ tabBarLabel: 'Perfil Mascota' }}
      />
      <Tab.Screen
        name="Cart"
        component={CartScreen}
        initialParams={{ clienteId }}
        options={{ tabBarLabel: 'Carrito' }}
      />
      <Tab.Screen
        name="Favorites"
        component={FavoritesScreen}
        initialParams={{ clienteId }}
        options={{ tabBarLabel: 'Favoritos' }}
      />
    </Tab.Navigator>
  );
}

/* ======================================================
   Navegador Global
====================================================== */
const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator
        initialRouteName="Splash"
        screenOptions={{ headerShown: false }}
      >
        <Stack.Screen name="Splash" component={SplashScreen} />
        <Stack.Screen name="Welcome" component={WelcomeScreen} />
        <Stack.Screen name="Login" component={LoginScreen} />
        <Stack.Screen name="Register" component={RegisterScreen} />
        <Stack.Screen name="Success" component={SuccessScreen} />

        {/* App principal con Tabs */}
        <Stack.Screen name="Main" component={DrawerNavigator} />

        {/* Flujo de compra */}
        <Stack.Screen
          name="Checkout"
          component={CheckoutScreen}
          options={{ headerShown: false }}
        />

        {/*  NUEVA PANTALLA: Pago */}
        <Stack.Screen
          name="Payment"
          component={PaymentScreen}
          options={{ headerShown: false }}
        />

        {/*  AÑADE LA NUEVA PANTALLA AQUÍ  */}
        {/* <Stack.Screen // <--- BORRA O COMENTA ESTE BLOQUE
          name="UploadProof"
          component={UploadProofScreen}
          options={{ headerShown: false }}
        /> */}

        <Stack.Screen
          name="OrderSuccess"
          component={OrderSuccessScreen}
          options={{ headerShown: false }}
        />

        {/* Agregar/Editar Dirección */}
        <Stack.Screen
          name="AddAddress"
          component={AddAddressScreen}
          options={{
            headerShown: false,
            presentation: 'modal'
          }}
        />

        {/* 👇 --- 2. AGREGAR ESTA NUEVA PANTALLA --- 👇 */}
        <Stack.Screen
          name="AddPet"
          component={AddPetScreen}
          options={{
            headerShown: false,
            presentation: 'modal' // Para que aparezca desde abajo
          }}
        />
        {/* ------------------------------------------- */}
      </Stack.Navigator>

      <Stack.Screen name="UserProfile" component={UserProfileScreen} />
      
    </NavigationContainer>
  );
};

export default AppNavigator;
</file>

<file path="frontend/components/AuthContainer.js">
// components/AuthContainer.js
import React from 'react';
import { View, Image, StyleSheet, ImageBackground, KeyboardAvoidingView, Platform } from 'react-native';

const backgroundImage = require('../assets/fondo.jpg'); // Imagen de fondo
const logo = require('../assets/logo.png'); // Logo

const AuthContainer = ({ children }) => {
  return (
    <ImageBackground source={backgroundImage} style={styles.background}>
      {/* Capa con degradado encima de la imagen */}
      <View style={styles.overlay} />

      <KeyboardAvoidingView 
        behavior={Platform.OS === "ios" ? "padding" : "height"} 
        style={styles.container}
      >
        <Image source={logo} style={styles.logo} />
        {children}
      </KeyboardAvoidingView>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
  },
  overlay: {
    ...StyleSheet.absoluteFillObject, // Ocupa todo el fondo
    backgroundColor: 'rgba(96, 57, 95, 0.4)', // morado con 30% opacidad
  },
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'flex-end',
  },
  logo: {
    width: 250,
    height: 250,
    resizeMode: 'contain',
    position: 'absolute',
    top: 50,
  },
});

export default AuthContainer;
</file>

<file path="frontend/components/CartBadge.js">
// frontend/components/CartBadge.js

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useFocusEffect } from '@react-navigation/native';
import { getCartItemCount } from '../services/cartService';

/**
 * 🛒 Badge que muestra la cantidad de items en el carrito
 * Úsalo envolviendo el ícono del carrito
 */
const CartBadge = ({ clienteId, children }) => {
  const [itemCount, setItemCount] = useState(0);

  // Cargar al montar el componente
  useEffect(() => {
    loadItemCount();
  }, [clienteId]);

  // Actualizar cada vez que la pantalla esté en foco
  useFocusEffect(
    React.useCallback(() => {
      loadItemCount();
      
      // Actualizar cada 3 segundos mientras la pantalla está activa
      const interval = setInterval(loadItemCount, 3000);
      
      return () => clearInterval(interval);
    }, [clienteId])
  );

  const loadItemCount = async () => {
    if (!clienteId) {
      setItemCount(0);
      return;
    }
    
    try {
      const count = await getCartItemCount(clienteId);
      setItemCount(count);
    } catch (error) {
      console.error('❌ Error al cargar contador del carrito:', error);
      setItemCount(0);
    }
  };

  return (
    <View style={styles.container}>
      {children}
      {itemCount > 0 && (
        <View style={styles.badge}>
          <Text style={styles.badgeText}>
            {itemCount > 99 ? '99+' : itemCount}
          </Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'relative',
  },
  badge: {
    position: 'absolute',
    top: -8,
    right: -8,
    backgroundColor: '#FF6B6B',
    borderRadius: 12,
    minWidth: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 6,
    borderWidth: 2,
    borderColor: 'white',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  badgeText: {
    color: 'white',
    fontSize: 11,
    fontWeight: 'bold',
  },
});

export default CartBadge;
</file>

<file path="frontend/components/ProductCard.js">
// frontend/components/ProductCard.js
import React from 'react';
import { View, Text, Image, TouchableOpacity } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { styles } from '../styles/productCardStyles';
import { addToCart } from '../services/cartService';

const ProductCard = ({ item, clienteId }) => {
  const navigation = useNavigation();
  if (!item) return null;

  const imageSource = item.imagen ? { uri: item.imagen } : require('../assets/placeholder.png');

  const handlePress = () => {
    //navigation.navigate('ProductDetail', { productId: item.id });
    navigation.navigate('ProductDetail', { 
      productId: item.id,
      clienteId 
    });

    const handleAddToCart = async (e) => {
    e.stopPropagation(); // Evita que se active la navegación al detalle
    if (!clienteId) {
      alert("Inicia sesión para agregar al carrito.");
      return;
    }
    try {
      await addToCart(clienteId, item.id, 1);
      alert(`${item.nombre} fue agregado al carrito.`);
    } catch (error) {
      alert("Error al agregar al carrito.");
    }
  };
  };

  return (
    <TouchableOpacity style={styles.cardContainer} onPress={handlePress}>
      <Image source={imageSource} style={styles.image} />
      
      {/* NUEVO: Agrupamos todo el contenido central en una View */}
      {/* Parte Superior: Título y Descripción */}
      <Text style={styles.title} numberOfLines={2}>{item.nombre}</Text>
      <Text style={styles.subtitle} numberOfLines={3}>{item.descripcion}</Text>

      {/* 👇 EL SEPARADOR MÁGICO 👇 */}
      <View style={styles.spacer} />

      {/* Parte Inferior: Precio y Footer siempre alineados al fondo */}
      <Text style={styles.price}>S/ {item.precio?.toFixed(2) || '0.00'}</Text>

      <View style={styles.footer}>
  <TouchableOpacity style={styles.addToCartButton}>
  <Text style={styles.addToCartText}>AGREGAR AL CARRITO</Text>
</TouchableOpacity>

  <Text style={styles.seeMoreText}>Ver más →</Text>
</View>

      
    </TouchableOpacity>
  );
};

export default ProductCard;
</file>

<file path="frontend/index.js">
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
</file>

<file path="frontend/package.json">
{
  "name": "pawpalsapp",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.2",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-picker/picker": "^2.11.4",
    "@react-navigation/bottom-tabs": "^7.8.12",
    "@react-navigation/drawer": "^7.7.9",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/stack": "^7.4.8",
    "axios": "^1.13.2",
    "expo": "~54.0.9",
    "expo-image-picker": "~17.0.9",
    "expo-linear-gradient": "~15.0.7",
    "expo-location": "~18.0.7",
    "expo-status-bar": "~3.0.8",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.4",
    "react-native-gesture-handler": "^2.29.1",
    "react-native-reanimated": "^4.2.0",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0"
  },
  "private": true
}
</file>

<file path="frontend/README.md">
# PawPals Frontend

Este proyecto es el frontend de PawPals, construido con React Native y Expo.

## Requisitos
- Node.js 18+
- Instalar Expo CLI globalmente:
	```powershell
	npm install -g expo-cli
	```
- Instalar dependencias del proyecto:
	```powershell
	npm install
	```

## Cómo correr el frontend

1. Abre una terminal en la carpeta `frontend`.
2. Ejecuta el siguiente comando para iniciar el proyecto:
	 ```powershell
	 npm start
	 ```
	 o
	 ```powershell
	 expo start
	 ```

## Notas
- La app se conecta al backend por defecto en `http://localhost:8000` 
- Los componentes y pantallas principales están en las carpetas `components` y `screens`.
</file>

<file path="frontend/screens/AddAddressScreen.js">
// frontend/screens/AddAddressScreen.js

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Alert,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as Location from 'expo-location';

import { createAddress, updateAddress } from '../services/addressService';
import { styles } from '../styles/addAddressScreenStyles';

const AddAddressScreen = ({ navigation, route }) => {
  const { clienteId, addressId, existingAddress } = route.params || {};
  
  // Estados del formulario
  const [nombre, setNombre] = useState('');
  const [referencia, setReferencia] = useState('');
  const [esPrincipal, setEsPrincipal] = useState(false);
  
  // Estados de ubicación
  const [latitud, setLatitud] = useState('');
  const [longitud, setLongitud] = useState('');
  const [loadingLocation, setLoadingLocation] = useState(false);
  const [saving, setSaving] = useState(false);

  // Cargar dirección existente si está en modo edición
  useEffect(() => {
    if (existingAddress) {
      setNombre(existingAddress.nombre || '');
      setReferencia(existingAddress.referencia || '');
      setEsPrincipal(existingAddress.es_principal || false);
      
      if (existingAddress.latitud && existingAddress.longitud) {
        setLatitud(existingAddress.latitud.toString());
        setLongitud(existingAddress.longitud.toString());
      }
    }
  }, [existingAddress]);

  // Obtener ubicación actual del usuario
  const getCurrentLocation = async () => {
    setLoadingLocation(true);
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      
      if (status !== 'granted') {
        Alert.alert(
          'Permiso denegado',
          'Necesitamos acceso a tu ubicación para obtener las coordenadas.'
        );
        setLoadingLocation(false);
        return;
      }

      const location = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.High,
      });

      setLatitud(location.coords.latitude.toFixed(6));
      setLongitud(location.coords.longitude.toFixed(6));

      console.log('✅ Ubicación actual obtenida:', {
        lat: location.coords.latitude,
        lng: location.coords.longitude
      });
      
      Alert.alert('Éxito', 'Ubicación obtenida correctamente');
    } catch (error) {
      console.error('❌ Error al obtener ubicación:', error);
      Alert.alert('Error', 'No se pudo obtener tu ubicación actual.');
    } finally {
      setLoadingLocation(false);
    }
  };

  // Validar formulario
  const validateForm = () => {
    if (!nombre.trim()) {
      Alert.alert('Campo requerido', 'Por favor ingresa un nombre para la dirección.');
      return false;
    }

    if (!latitud || !longitud) {
      Alert.alert('Ubicación requerida', 'Por favor obtén tu ubicación o ingresa coordenadas manualmente.');
      return false;
    }

    // Validar que sean números válidos
    const lat = parseFloat(latitud);
    const lng = parseFloat(longitud);
    
    if (isNaN(lat) || isNaN(lng)) {
      Alert.alert('Coordenadas inválidas', 'Por favor ingresa coordenadas válidas.');
      return false;
    }

    if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
      Alert.alert('Coordenadas inválidas', 'Las coordenadas están fuera del rango válido.');
      return false;
    }

    return true;
  };

  // Guardar dirección
  const handleSave = async () => {
  if (!validateForm()) return;

  setSaving(true);
  try {
    const addressData = {
      nombre: nombre.trim(),
      referencia: referencia.trim(),
      latitud: parseFloat(latitud),
      longitud: parseFloat(longitud),
      es_principal: esPrincipal,
    };

    console.log('💾 Guardando dirección:', addressData);

    let result;
    if (addressId) {
      // Actualizar dirección existente
      result = await updateAddress(addressId, addressData);
      console.log('✅ Dirección actualizada:', result);
      
      // ✅ MOSTRAR ALERTA Y VOLVER
      Alert.alert(
        '¡Éxito!',
        'Dirección actualizada correctamente',
        [
          { 
            text: 'OK', 
            onPress: () => {
              console.log('🔙 Volviendo a Checkout...');
              navigation.goBack();
            }
          }
        ]
      );
    } else {
      // Crear nueva dirección
      result = await createAddress(clienteId, addressData);
      console.log('✅ Dirección creada:', result);
      
      // ✅ MOSTRAR ALERTA Y VOLVER
      Alert.alert(
        '¡Dirección guardada!',
        `"${addressData.nombre}" fue agregada correctamente`,
        [
          { 
            text: 'OK', 
            onPress: () => {
              console.log('🔙 Volviendo a Checkout...');
              navigation.goBack();
            }
          }
        ]
      );
    }

  } catch (error) {
    console.error('❌ Error al guardar dirección:', error);
    
    // Extraer mensaje de error específico
    let errorMessage = 'No se pudo guardar la dirección.';
    
    if (error.response?.data?.detail) {
      errorMessage = error.response.data.detail;
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    Alert.alert('Error', errorMessage);
  } finally {
    setSaving(false);
  }
};

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView 
        style={styles.container} 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        {/* HEADER */}
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={28} color="#875686" />
          </TouchableOpacity>

          <Text style={styles.headerTitle}>
            {addressId ? 'Editar Dirección' : 'Agregar Dirección'}
          </Text>

          <View style={{ width: 28 }} />
        </View>

        <ScrollView 
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
        >
          {/* SECCIÓN DE UBICACIÓN */}
          <View style={styles.locationSection}>
            <Text style={styles.sectionTitle}>Ubicación</Text>
            
            {/* Botón Obtener Ubicación Actual */}
            <TouchableOpacity
              style={styles.locationButton}
              onPress={getCurrentLocation}
              disabled={loadingLocation}
            >
              {loadingLocation ? (
                <>
                  <ActivityIndicator color="white" size="small" />
                  <Text style={styles.locationButtonText}>Obteniendo ubicación...</Text>
                </>
              ) : (
                <>
                  <Ionicons name="locate" size={24} color="white" />
                  <Text style={styles.locationButtonText}>Usar mi ubicación actual</Text>
                </>
              )}
            </TouchableOpacity>

            {/* Inputs de Coordenadas Manuales */}
            <View style={styles.coordsInputContainer}>
              <View style={styles.coordInputGroup}>
                <Text style={styles.coordLabel}>Latitud</Text>
                <TextInput
                  style={styles.coordInput}
                  placeholder="-16.4090"
                  value={latitud}
                  onChangeText={setLatitud}
                  keyboardType="numeric"
                />
              </View>

              <View style={styles.coordInputGroup}>
                <Text style={styles.coordLabel}>Longitud</Text>
                <TextInput
                  style={styles.coordInput}
                  placeholder="-71.5375"
                  value={longitud}
                  onChangeText={setLongitud}
                  keyboardType="numeric"
                />
              </View>
            </View>

            {/* Información de ayuda */}
            <View style={styles.helpBox}>
              <Ionicons name="information-circle" size={20} color="#875686" />
              <Text style={styles.helpText}>
                Puedes usar tu ubicación actual o ingresar coordenadas manualmente
              </Text>
            </View>
          </View>

          {/* FORMULARIO */}
          <View style={styles.formContainer}>
            <Text style={styles.sectionTitle}>Detalles de la Dirección</Text>

            {/* Nombre de la dirección */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>
                Nombre <Text style={styles.required}>*</Text>
              </Text>
              <TextInput
                style={styles.input}
                placeholder="Ej: Casa, Oficina, Casa de mis padres"
                value={nombre}
                onChangeText={setNombre}
                maxLength={60}
              />
            </View>

            {/* Referencia */}
            <View style={styles.inputGroup}>
              <Text style={styles.label}>Referencia</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                placeholder="Ej: Portón verde, al lado del parque"
                value={referencia}
                onChangeText={setReferencia}
                multiline
                numberOfLines={3}
                maxLength={100}
              />
            </View>

            {/* Dirección principal */}
            <TouchableOpacity
              style={styles.checkboxContainer}
              onPress={() => setEsPrincipal(!esPrincipal)}
            >
              <View style={[styles.checkbox, esPrincipal && styles.checkboxChecked]}>
                {esPrincipal && (
                  <Ionicons name="checkmark" size={18} color="white" />
                )}
              </View>
              <Text style={styles.checkboxLabel}>
                Establecer como dirección principal
              </Text>
            </TouchableOpacity>
          </View>
        </ScrollView>

        {/* BOTÓN GUARDAR */}
        <View style={styles.bottomContainer}>
          <TouchableOpacity
            style={[
              styles.saveButton,
              (!nombre.trim() || !latitud || !longitud || saving) && styles.saveButtonDisabled
            ]}
            onPress={handleSave}
            disabled={!nombre.trim() || !latitud || !longitud || saving}
          >
            {saving ? (
              <ActivityIndicator color="white" />
            ) : (
              <>
                <Ionicons name="checkmark-circle" size={24} color="white" />
                <Text style={styles.saveButtonText}>
                  {addressId ? 'Actualizar Dirección' : 'Guardar Dirección'}
                </Text>
              </>
            )}
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

export default AddAddressScreen;
</file>

<file path="frontend/screens/AddPetScreen.js">
// frontend/screens/AddPetScreen.js

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Alert,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Picker } from '@react-native-picker/picker';
import { createPet, getSpecies, getBreedsBySpecies } from '../services/petService';
import { styles } from '../styles/addPetScreenStyles';

const AddPetScreen = ({ navigation, route }) => {
  const { clienteId } = route.params || {};

  // Estados del formulario
  const [petName, setPetName] = useState('');
  const [petType, setPetType] = useState('');
  const [breed, setBreed] = useState('');
  const [age, setAge] = useState('');
  const [petSex, setPetSex] = useState('M');

  // Estados de datos y carga
  const [especies, setEspecies] = useState([]);
  const [razas, setRazas] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [razasLoading, setRazasLoading] = useState(false);

  // Carga las especies al iniciar
  useEffect(() => {
    const loadSpecies = async () => {
      try {
        const speciesData = await getSpecies();
        setEspecies(speciesData);
        if (speciesData.length > 0) setPetType(speciesData[0].id);
      } catch (error) {
        console.error('❌ Error cargando especies:', error);
      }
    };
    loadSpecies();
  }, []);

  // Carga las razas cuando cambia el tipo de mascota
  useEffect(() => {
    const loadBreeds = async () => {
      if (!petType) return;
      setRazasLoading(true);
      setRazas([]);
      try {
        const breedsData = await getBreedsBySpecies(petType);
        setRazas(breedsData);
        if (breedsData.length > 0) setBreed(breedsData[0]);
      } catch (error) {
        console.error('❌ Error cargando razas:', error);
      } finally {
        setRazasLoading(false);
      }
    };
    loadBreeds();
  }, [petType]);

  const handleSavePet = async () => {
    if (!petName.trim() || !breed || !age.trim()) {
      Alert.alert('Campos incompletos', 'Por favor completa todos los campos.');
      return;
    }
    setIsLoading(true);
    try {
      const petData = {
        nombre: petName,
        especie_id: petType,
        raza: breed,
        edad: parseInt(age, 10),
        sexo: petSex
      };
      await createPet(clienteId, petData);
      Alert.alert('¡Éxito!', 'Tu mascota ha sido registrada.', [
        { text: 'OK', onPress: () => navigation.goBack() }
      ]);
    } catch (error) {
      const errorMessage = error.response?.data?.detail || 'Ocurrió un error al registrar la mascota.';
      Alert.alert('Error', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const isFormValid = petName.trim() && breed && age.trim() && !razasLoading;

  return (
    <SafeAreaView style={styles.safeArea}>
      <KeyboardAvoidingView 
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={28} color="#875686" />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Agregar Mascota</Text>
          <View style={{ width: 28 }} />
        </View>

        <ScrollView contentContainerStyle={styles.formContainer} keyboardShouldPersistTaps="handled">
          <TextInput style={styles.input} placeholder="Nombre de la mascota" value={petName} onChangeText={setPetName} />
          
          <View style={styles.pickerContainer}>
            <Text style={styles.pickerLabel}>Tipo de mascota:</Text>
            <Picker selectedValue={petType} onValueChange={setPetType} style={styles.picker}>
              {especies.map(e => <Picker.Item key={e.id} label={e.nombre} value={e.id} />)}
            </Picker>
          </View>
          
          <View style={styles.pickerContainer}>
            <Text style={styles.pickerLabel}>Raza:</Text>
            {razasLoading ? (
              <ActivityIndicator size="small" color="#732C71" style={{ height: 40 }}/>
            ) : (
              <Picker selectedValue={breed} onValueChange={setBreed} style={styles.picker} enabled={!razasLoading && razas.length > 0}>
                {razas.map((r, index) => <Picker.Item key={index} label={r} value={r} />)}
              </Picker>
            )}
          </View>

          <TextInput style={styles.input} placeholder="Edad (años)" value={age} onChangeText={setAge} keyboardType="numeric" />
          
          <View style={styles.pickerContainer}>
            <Text style={styles.pickerLabel}>Sexo:</Text>
            <Picker selectedValue={petSex} onValueChange={setPetSex} style={styles.picker}>
              <Picker.Item label="Macho" value="M" />
              <Picker.Item label="Hembra" value="H" />
            </Picker>
          </View>

          <TouchableOpacity 
            style={[styles.saveButton, (!isFormValid || isLoading) && styles.saveButtonDisabled]}
            onPress={handleSavePet}
            disabled={!isFormValid || isLoading}
          >
            {isLoading ? (
              <ActivityIndicator color="white" />
            ) : (
              <>
                <Ionicons name="checkmark-circle" size={24} color="white" />
                <Text style={styles.saveButtonText}>Guardar Mascota</Text>
              </>
            )}
          </TouchableOpacity>
        </ScrollView>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
};

export default AddPetScreen;
</file>

<file path="frontend/screens/CartScreen.js">
// frontend/screens/CartScreen.js

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Alert,
  ImageBackground,
  ScrollView
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';

import {
  getCart,
  removeFromCart,
  updateCartItemQuantity,
  clearCart,
  checkout
} from '../services/cartService';

import { styles } from '../styles/cartScreenStyles';

const CartScreen = ({ navigation, route }) => {
  const { clienteId } = route.params || {};
  
  // Estados
  const [cart, setCart] = useState({ items: [], subtotal: 0, total: 0 });
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [processingCheckout, setProcessingCheckout] = useState(false);

  // Verificar clienteId
  useEffect(() => {
    if (!clienteId) {
      console.error('❌ No se recibió clienteId en CartScreen');
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      navigation.goBack();
    } else {
      console.log('✅ CartScreen iniciado con clienteId:', clienteId);
    }
  }, [clienteId]);

  // Cargar carrito al entrar a la pantalla
  useFocusEffect(
    useCallback(() => {
      console.log('🔄 Cargando carrito...');
      loadCart();
    }, [clienteId])
  );

  const loadCart = async () => {
    if (!clienteId) {
      console.error('❌ No hay clienteId para cargar carrito');
      return;
    }
    
    try {
      console.log('📦 Obteniendo carrito para cliente:', clienteId);
      const cartData = await getCart(clienteId);
      console.log('✅ Carrito obtenido:', cartData.items.length, 'items');
      setCart(cartData);
    } catch (error) {
      console.error('❌ Error cargando carrito:', error);
      Alert.alert('Error', 'No se pudo cargar el carrito.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadCart();
  };

  // Incrementar cantidad
  const handleIncrement = async (platoId, currentQuantity) => {
    try {
      console.log('➕ Incrementando cantidad de:', platoId);
      const updatedCart = await updateCartItemQuantity(
        clienteId,
        platoId,
        currentQuantity + 1
      );
      setCart(updatedCart);
      console.log('✅ Cantidad incrementada');
    } catch (error) {
      console.error('❌ Error al incrementar:', error);
      Alert.alert('Error', 'No se pudo actualizar la cantidad.');
    }
  };

  // Decrementar cantidad
  const handleDecrement = async (platoId, currentQuantity) => {
    if (currentQuantity <= 1) {
      handleRemoveItem(platoId);
      return;
    }
    
    try {
      const updatedCart = await updateCartItemQuantity(
        clienteId,
        platoId,
        currentQuantity - 1
      );
      setCart(updatedCart);
    } catch (error) {
      Alert.alert('Error', 'No se pudo actualizar la cantidad.');
    }
  };

  // Eliminar un item específico
  const handleRemoveItem = async (platoId) => {
    const item = cart.items.find(i => i.plato_id === platoId);
    
    Alert.alert(
      "Eliminar Producto",
      `¿Deseas eliminar "${item?.nombre}" del carrito?`,
      [
        { text: "Cancelar", style: "cancel" },
        {
          text: "Eliminar",
          style: "destructive",
          onPress: async () => {
            try {
              const updatedCart = await removeFromCart(clienteId, platoId);
              setCart(updatedCart);
            } catch (error) {
              Alert.alert('Error', 'No se pudo eliminar el producto.');
            }
          }
        }
      ]
    );
  };

  // Vaciar todo el carrito
  const handleClearCart = () => {
    Alert.alert(
      "Vaciar Carrito",
      "¿Estás seguro de que deseas eliminar todos los productos del carrito?",
      [
        { text: "Cancelar", style: "cancel" },
        {
          text: "Vaciar",
          style: "destructive",
          onPress: async () => {
            try {
              const emptyCart = await clearCart(clienteId);
              setCart(emptyCart);
            } catch (error) {
              Alert.alert('Error', 'No se pudo vaciar el carrito.');
            }
          }
        }
      ]
    );
  };

  // Finalizar compra
  const handleCheckout = () => {
    if (cart.items.length === 0) {
      Alert.alert('Carrito vacío', 'Agrega productos antes de continuar.');
      return;
    }

    // Navegar a la pantalla de Checkout
    navigation.navigate('Checkout', { clienteId });
  };

  // Renderizar cada item del carrito
  const renderCartItem = ({ item }) => {
    const imageSource = item.imagen
      ? { uri: item.imagen }
      : require('../assets/placeholder.png');

    return (
      <View style={styles.cartItem}>
        <Image source={imageSource} style={styles.itemImage} />
        
        <View style={styles.itemInfo}>
          <Text style={styles.itemName} numberOfLines={2}>
            {item.nombre}
          </Text>
          <Text style={styles.itemPrice}>
            S/ {item.precio_unitario.toFixed(2)}
          </Text>
        </View>

        <View style={styles.itemActions}>
          <View style={styles.quantityControl}>
            <TouchableOpacity
              style={styles.quantityButton}
              onPress={() => handleDecrement(item.plato_id, item.cantidad)}
            >
              <Ionicons name="remove" size={20} color="white" />
            </TouchableOpacity>
            
            <Text style={styles.quantityText}>{item.cantidad}</Text>
            
            <TouchableOpacity
              style={styles.quantityButton}
              onPress={() => handleIncrement(item.plato_id, item.cantidad)}
            >
              <Ionicons name="add" size={20} color="white" />
            </TouchableOpacity>
          </View>

          <Text style={styles.itemSubtotal}>
            S/ {item.subtotal.toFixed(2)}
          </Text>

          <TouchableOpacity
            style={styles.removeButton}
            onPress={() => handleRemoveItem(item.plato_id)}
          >
            <Ionicons name="trash-outline" size={20} color="#FF6B6B" />
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      {/* FONDO */}
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />

      {/* HEADER */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={30} color="white" />
        </TouchableOpacity>

        <Image
          source={require('../assets/logo_amarillo.png')}
          style={styles.logo}
        />

        {cart.items.length > 0 && (
          <TouchableOpacity onPress={handleClearCart}>
            <Ionicons name="trash-outline" size={28} color="white" />
          </TouchableOpacity>
        )}
        {cart.items.length === 0 && <View style={{ width: 28 }} />}
      </View>

      {/* CONTENIDO */}
      <View style={styles.container}>
        {/* TÍTULO */}
        <View style={styles.titleContainer}>
          <Text style={styles.screenTitle}>Mi Carrito</Text>
          {!loading && cart.items.length > 0 && (
            <Text style={styles.countText}>
              {cart.items.length} {cart.items.length === 1 ? 'producto' : 'productos'}
            </Text>
          )}
        </View>

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#875686" />
            <Text style={styles.loadingText}>Cargando carrito...</Text>
          </View>
        ) : cart.items.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="cart-outline" size={100} color="#ccc" />
            <Text style={styles.emptyTitle}>Tu carrito está vacío</Text>
            <Text style={styles.emptySubtitle}>
              Explora nuestros productos y agrega tus favoritos
            </Text>
            <TouchableOpacity
              style={styles.exploreButton}
              onPress={() => navigation.navigate('HomeStack')}
            >
              <Text style={styles.exploreButtonText}>Explorar Productos</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <FlatList
              data={cart.items}
              renderItem={renderCartItem}
              keyExtractor={(item) => item.plato_id.toString()}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={false}
              refreshing={refreshing}
              onRefresh={handleRefresh}
            />

            {/* RESUMEN DEL PEDIDO */}
            <View style={styles.summaryContainer}>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Subtotal:</Text>
                <Text style={styles.summaryValue}>
                  S/ {cart.subtotal.toFixed(2)}
                </Text>
              </View>

              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Envío:</Text>
                <Text style={styles.summaryValue}>Gratis</Text>
              </View>

              <View style={styles.divider} />

              <View style={styles.summaryRow}>
                <Text style={styles.totalLabel}>Total:</Text>
                <Text style={styles.totalValue}>
                  S/ {cart.total.toFixed(2)}
                </Text>
              </View>

              <TouchableOpacity
                style={[
                  styles.checkoutButton,
                  processingCheckout && styles.checkoutButtonDisabled
                ]}
                onPress={handleCheckout}
                disabled={processingCheckout}
              >
                {processingCheckout ? (
                  <ActivityIndicator color="white" />
                ) : (
                  <>
                    <Ionicons name="card-outline" size={24} color="white" />
                    <Text style={styles.checkoutButtonText}>
                      Proceder al Pago
                    </Text>
                  </>
                )}
              </TouchableOpacity>
            </View>
          </>
        )}
      </View>
    </SafeAreaView>
  );
};

export default CartScreen;
</file>

<file path="frontend/screens/CheckoutScreen.js">
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  ScrollView,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Alert,
  ImageBackground,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';
import { getAddresses } from '../services/addressService';
import { getCart, checkout } from '../services/cartService';
import { styles } from '../styles/checkoutScreenStyles';

const CheckoutScreen = ({ navigation, route }) => {
  const { clienteId } = route.params || {};
  const [cart, setCart] = useState({ items: [], subtotal: 0, total: 0 });
  const [addresses, setAddresses] = useState([]);
  const [selectedAddress, setSelectedAddress] = useState(null);
  const [loading, setLoading] = useState(true);
  const [processing, setProcessing] = useState(false);

  useEffect(() => {
    if (!clienteId) {
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      navigation.goBack();
      return;
    }
  }, [clienteId]);

  useFocusEffect(
    React.useCallback(() => {
      console.log('📦 Checkout enfocado - Recargando datos...');
      loadCheckoutData();
    }, [clienteId])
  );

  const loadCheckoutData = async () => {
    try {
      console.log('📦 Cargando datos de checkout para cliente:', clienteId);
      const cartData = await getCart(clienteId);
      console.log('🛒 Carrito cargado:', cartData.items.length, 'items');
      setCart(cartData);
      const addressesData = await getAddresses(clienteId);
      console.log('📍 Direcciones obtenidas:', addressesData.length);
      setAddresses(addressesData);
      const mainAddress = addressesData.find(addr => addr.es_principal);
      if (mainAddress) {
        console.log('✅ Dirección principal encontrada:', mainAddress.nombre);
        setSelectedAddress(mainAddress.id);
      } else if (addressesData.length > 0) {
        console.log('✅ Seleccionando primera dirección:', addressesData[0].nombre);
        setSelectedAddress(addressesData[0].id);
      }
      console.log('✅ Datos de checkout cargados');
    } catch (error) {
      console.error('❌ Error cargando datos de checkout:', error);
      Alert.alert('Error', 'No se pudieron cargar los datos necesarios.');
    } finally {
      setLoading(false);
    }
  };

  const handleConfirmOrder = async () => {
    console.log('🔘 Botón "Confirmar Pedido" presionado');
    console.log('📍 Dirección seleccionada:', selectedAddress);
    console.log('🛒 Items en carrito:', cart.items.length);
    console.log('💰 Total:', cart.total);
    
    if (!selectedAddress) {
      Alert.alert('Dirección requerida', 'Por favor selecciona una dirección de entrega.');
      return;
    }
    
    if (!cart.items || cart.items.length === 0) {
      Alert.alert('Carrito vacío', 'No hay productos en tu carrito.');
      return;
    }
    
    console.log('✅ Validaciones pasadas - Procesando pedido directamente...');
    await processOrder();
  };

  const processOrder = async () => {
    console.log('═══════════════════════════════════════');
    console.log('🚀 INICIANDO PROCESO DE PEDIDO');
    console.log('═══════════════════════════════════════');
    setProcessing(true);
    try {
      console.log('📋 Datos del pedido:');
      console.log('  - Cliente ID:', clienteId);
      console.log('  - Dirección ID:', selectedAddress);
      console.log('  - Total items:', cart.items.length);
      console.log('  - Total a pagar:', cart.total);
      console.log('📡 Enviando pedido al backend...');
      const result = await checkout(clienteId, selectedAddress);
      console.log('✅ PEDIDO CREADO EXITOSAMENTE');
      console.log('📦 Pedido ID:', result.pedido_id);
      console.log('🔀 Navegando a Payment con:');
      const paymentParams = { clienteId, pedidoId: result.pedido_id, direccionId: selectedAddress, total: cart.total };
      console.log('   Parámetros:', paymentParams);
      navigation.navigate('Payment', paymentParams);
      console.log('✅ Navegación exitosa');
      console.log('═══════════════════════════════════════');
    } catch (error) {
      console.log('═══════════════════════════════════════');
      console.log('❌ ERROR AL CREAR PEDIDO');
      console.log('═══════════════════════════════════════');
      console.error('Error completo:', error);
      console.error('Respuesta del servidor:', error.response?.data);
      console.error('Status code:', error.response?.status);
      console.log('═══════════════════════════════════════');
      const errorMessage = error.response?.data?.detail || error.message || 'No se pudo crear el pedido.';
      Alert.alert('Error en el pedido', errorMessage);
    } finally {
      setProcessing(false);
    }
  };

  const handleAddAddress = () => { navigation.navigate('AddAddress', { clienteId }); };
  const handleEditAddress = (address) => { navigation.navigate('AddAddress', { clienteId, addressId: address.id, existingAddress: address }); };

  if (loading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#875686" />
          <Text style={styles.loadingText}>Cargando datos...</Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <ImageBackground source={require('../assets/FONDOA.png')} style={styles.backgroundImage} resizeMode="cover" />
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={30} color="white" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Finalizar Pedido</Text>
        <View style={{ width: 30 }}></View>
      </View>
      <View style={styles.container}>
        <ScrollView showsVerticalScrollIndicator={false} contentContainerStyle={styles.scrollContent}>
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Resumen del Pedido</Text>
            <View style={styles.orderSummary}>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Productos ({cart.items.length}):</Text>
                <Text style={styles.summaryValue}>S/ {cart.subtotal.toFixed(2)}</Text>
              </View>
              <View style={styles.summaryRow}>
                <Text style={styles.summaryLabel}>Envío:</Text>
                <Text style={styles.summaryValueGreen}>Gratis</Text>
              </View>
              <View style={styles.divider} />
              <View style={styles.summaryRow}>
                <Text style={styles.totalLabel}>Total:</Text>
                <Text style={styles.totalValue}>S/ {cart.total.toFixed(2)}</Text>
              </View>
            </View>
          </View>
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>Dirección de Entrega</Text>
              <TouchableOpacity onPress={handleAddAddress}>
                <Ionicons name="add-circle-outline" size={28} color="#875686" />
              </TouchableOpacity>
            </View>
            {addresses.length === 0 ? (
              <View style={styles.noAddressContainer}>
                <Ionicons name="location-outline" size={60} color="#ccc" />
                <Text style={styles.noAddressText}>No tienes direcciones registradas</Text>
                <TouchableOpacity style={styles.addAddressButton} onPress={handleAddAddress}>
                  <Text style={styles.addAddressButtonText}>Agregar Dirección</Text>
                </TouchableOpacity>
              </View>
            ) : (
              <View style={styles.addressList}>
                {addresses.map((address) => (
                  <View key={address.id} style={styles.addressCardWrapper}>
                    <TouchableOpacity style={[styles.addressCard, selectedAddress === address.id && styles.addressCardSelected]} onPress={() => { console.log('📍 Dirección seleccionada:', address.id, '-', address.nombre); setSelectedAddress(address.id); }}>
                      <View style={styles.radioButton}>
                        {selectedAddress === address.id && (<View style={styles.radioButtonInner} />)}
                      </View>
                      <View style={styles.addressInfo}>
                        <View style={styles.addressHeader}>
                          <Text style={styles.addressName}>{address.nombre}</Text>
                          {address.es_principal && (<View style={styles.principalBadge}><Text style={styles.principalBadgeText}>Principal</Text></View>)}
                        </View>
                        {address.referencia && (<Text style={styles.addressReference}>{address.referencia}</Text>)}
                      </View>
                      <Ionicons name="location-sharp" size={24} color={selectedAddress === address.id ? '#875686' : '#ccc'} />
                    </TouchableOpacity>
                    <TouchableOpacity style={styles.editAddressButton} onPress={() => handleEditAddress(address)}>
                      <Ionicons name="create-outline" size={20} color="#875686" />
                    </TouchableOpacity>
                  </View>
                ))}
              </View>
            )}
          </View>
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Productos</Text>
            {cart.items.map((item) => {
              const imageSource = item.imagen ? { uri: item.imagen } : require('../assets/placeholder.png');
              return (
                <View key={item.plato_id} style={styles.productItem}>
                  <Image source={imageSource} style={styles.productImage} />
                  <View style={styles.productInfo}>
                    <Text style={styles.productName} numberOfLines={2}>{item.nombre}</Text>
                    <Text style={styles.productPrice}>S/ {item.precio_unitario.toFixed(2)} x {item.cantidad}</Text>
                  </View>
                  <Text style={styles.productSubtotal}>S/ {item.subtotal.toFixed(2)}</Text>
                </View>
              );
            })}
          </View>
        </ScrollView>
        <View style={styles.bottomContainer}>
          <TouchableOpacity style={[styles.confirmButton, (processing || addresses.length === 0 || !selectedAddress) && styles.confirmButtonDisabled]} onPress={handleConfirmOrder} disabled={processing || addresses.length === 0 || !selectedAddress}>
            {processing ? (<ActivityIndicator color="white" />) : (<><Ionicons name="checkmark-circle" size={24} color="white" /><Text style={styles.confirmButtonText}>Confirmar Pedido</Text></>)}
          </TouchableOpacity>
        </View>
      </View>
    </SafeAreaView>
  );
};

export default CheckoutScreen;
</file>

<file path="frontend/screens/FavoritesScreen.js">
// frontend/screens/FavoritesScreen.js

import React, { useEffect, useState, useCallback } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Alert,
  ImageBackground
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';

import { getFavorites, removeFavorite } from '../services/favoriteService';
import { styles } from '../styles/favoritesScreenStyles';

const FavoritesScreen = ({ navigation, route }) => {
  const { clienteId } = route.params || {};
  const [favorites, setFavorites] = useState([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [activeTab, setActiveTab] = useState('favorites');

  useEffect(() => {
    if (!clienteId) {
      console.error('❌ No se recibió clienteId en FavoritesScreen');
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      navigation.goBack();
    }
  }, [clienteId]);

  const loadFavorites = async () => {
    if (!clienteId) return;
    try {
      const data = await getFavorites(clienteId);
      setFavorites(data.favoritos || []);
    } catch (error) {
      console.error('❌ Error cargando favoritos:', error);
      Alert.alert('Error', 'No se pudieron cargar los favoritos.');
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      loadFavorites();
    }, [clienteId])
  );

  const handleRefresh = () => {
    setRefreshing(true);
    loadFavorites();
  };

  const handleRemoveFavorite = async (platoId, platoNombre) => {
    if (!clienteId) return;

    Alert.alert(
      "Eliminar de Favoritos",
      `¿Deseas eliminar "${platoNombre}" de tus favoritos?`,
      [
        { text: "Cancelar", style: "cancel" },
        {
          text: "Eliminar",
          style: "destructive",
          onPress: async () => {
            try {
              await removeFavorite(clienteId, platoId);
              setFavorites(prev => prev.filter(fav => fav.plato.id !== platoId));
            } catch (error) {
              Alert.alert('Error', 'No se pudo eliminar de favoritos.');
            }
          }
        }
      ]
    );
  };

  const handleProductPress = (productId) => {
    navigation.navigate('HomeStack', {
      screen: 'ProductDetail',
      params: { productId, clienteId }
    });
  };

  const renderFavoriteCard = ({ item }) => {
    const plato = item.plato;
    const imageSource = plato.imagen
      ? { uri: plato.imagen }
      : require('../assets/placeholder.png');

    return (
      <View style={styles.card}>
        <TouchableOpacity
          style={{ flex: 1, flexDirection: 'row', alignItems: 'center' }}
          onPress={() => handleProductPress(plato.id)}
          activeOpacity={0.8}
        >
          <Image source={imageSource} style={styles.cardImage} />

          <View style={styles.cardContent}>
            <Text style={styles.cardTitle} numberOfLines={2}>
              {plato.nombre}
            </Text>
            <Text style={styles.cardDescription} numberOfLines={2}>
              {plato.descripcion || 'Sin descripción'}
            </Text>
            <Text style={styles.cardPrice}>
              S/ {plato.precio?.toFixed(2) || '0.00'}
            </Text>
          </View>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.removeButton}
          onPress={() => handleRemoveFavorite(plato.id, plato.nombre)}
        >
          <Ionicons name="heart" size={24} color="#FF6B6B" />
        </TouchableOpacity>
      </View>
    );
  };

  return (
    <SafeAreaView style={styles.safeArea}>

      {/* FONDO */}
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />

      {/* HEADER */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="menu" size={30} color="white" />
        </TouchableOpacity>

        <Image
          source={require('../assets/logo_amarillo.png')}
          style={styles.logo}
        />

        <TouchableOpacity
          onPress={() => navigation.navigate('Cart', { clienteId })}
        >
          <Ionicons name="cart-outline" size={30} color="white" />
        </TouchableOpacity>
      </View>

      {/* CONTENIDO */}
      <View style={styles.container}>

        {/* ✅ TÍTULO */}
        <View style={styles.titleContainer}>
          <Text style={styles.screenTitle}>Tus favoritos</Text>

          {!loading && favorites.length > 0 && (
            <Text style={styles.countText}>
              {favorites.length} {favorites.length === 1 ? 'producto guardado' : 'productos guardados'}
            </Text>
          )}
        </View>

        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#875686" />
            <Text style={styles.loadingText}>Cargando favoritos...</Text>
          </View>
        ) : favorites.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="heart-outline" size={100} color="#ccc" />
            <Text style={styles.emptyTitle}>No tienes favoritos aún</Text>
            <Text style={styles.emptySubtitle}>
              Explora nuestros productos y agrega tus favoritos
            </Text>
            <TouchableOpacity
              style={styles.exploreButton}
              onPress={() => navigation.navigate('Home', { clienteId })}
            >
              <Text style={styles.exploreButtonText}>Explorar Productos</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <FlatList
            data={favorites}
            renderItem={renderFavoriteCard}
            keyExtractor={(item) => item.favorito_id.toString()}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            refreshing={refreshing}
            onRefresh={handleRefresh}
          />
        )}

      </View>
    </SafeAreaView>
  );
};

export default FavoritesScreen;
</file>

<file path="frontend/screens/HomeScreen.js">
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  ScrollView,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  ImageBackground,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';

import { getProducts, getCategories } from '../services/productService';
import ProductCard from '../components/ProductCard';
import { styles } from '../styles/homeScreenStyles';

const HomeScreen = ({ navigation, route }) => {
  // ===== ESTADOS =====
  const clienteId = route.params?.clienteId;
  const [userName, setUserName] = useState('Paúl');
  const [petName, setPetName] = useState('Caramelo');
  const [categories, setCategories] = useState([]);
  const [products, setProducts] = useState([]);
  const [activeCategoryId, setActiveCategoryId] = useState(null);
  const [loading, setLoading] = useState(true);

  // ===== EFECTOS =====
  useEffect(() => {
    if (!clienteId) {
      console.error('❌ No se recibió cliente_id');
    } else {
      console.log('✅ Cliente ID:', clienteId);
    }
  }, [clienteId]);

  useEffect(() => {
    const loadInitialData = async () => {
      try {
        const categoriesData = await getCategories();
        setCategories(categoriesData);

        if (categoriesData.length > 0) {
          const firstCategoryId = categoriesData[0].id;
          setActiveCategoryId(firstCategoryId);
          const productsData = await getProducts({ categoria_id: firstCategoryId });
          setProducts(productsData);
        }
      } catch (error) {
        console.error('❌ Error cargando datos:', error);
      } finally {
        setLoading(false);
      }
    };

    loadInitialData();
  }, []);

  // ===== HANDLERS =====
  const handleCategoryPress = async (categoryId) => {
    setActiveCategoryId(categoryId);
    setLoading(true);
    try {
      const productsData = await getProducts({ categoria_id: categoryId });
      setProducts(productsData);
    } catch (error) {
      console.error('❌ Error cargando productos:', error);
    } finally {
      setLoading(false);
    }
  };

  // ===== RENDER =====
  return (
    <SafeAreaView style={styles.safeArea}>

      {/* 🔥 FONDO CON IMAGEN (ABSOLUTO) */}
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />

      {/* 🔹 HEADER MORADO */}
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.openDrawer()}> {/*aea*/ }
          <Ionicons name="menu" size={30} color="white" />
        </TouchableOpacity>

        <Image
          source={require('../assets/logo_amarillo.png')}
          style={styles.logo}
        />

        <TouchableOpacity>
          <Ionicons name="cart-outline" size={30} color="white" />
        </TouchableOpacity>
      </View>

      {/* 🤍 CONTENEDOR BLANCO */}
      <View style={styles.container}>
        <Text style={styles.welcomeTitle}>
          Bienvenido {userName} y {petName}!!
        </Text>

        {/* CATEGORÍAS */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.categoryScrollView}
        >
          {categories.map((category) => (
            <TouchableOpacity
              key={category.id}
              style={styles.categoryButton}
              onPress={() => handleCategoryPress(category.id)}
            >
              <Text
                style={[
                  styles.categoryText,
                  activeCategoryId === category.id && styles.activeCategoryText,
                ]}
              >
                {category.nombre}
              </Text>

              {activeCategoryId === category.id && (
                <View style={styles.categoryUnderline} />
              )}
            </TouchableOpacity>
          ))}
        </ScrollView>

        {/* PRODUCTOS */}
        {loading ? (
          <ActivityIndicator
            size="large"
            color="#875686"
            style={{ marginTop: 50 }}
          />
        ) : (
          <FlatList
            data={products}
            horizontal
            showsHorizontalScrollIndicator={false}
            keyExtractor={(item) => item.id.toString()}
            renderItem={({ item, index }) => (
              <ProductCard
                item={item}
                clienteId={clienteId}
                isCenter={index === Math.floor(products.length / 2)}
              />
            )}
            contentContainerStyle={styles.productList}
            ListEmptyComponent={
              <Text style={styles.emptyText}>
                No hay productos en esta categoría.
              </Text>
            }
            snapToInterval={300}
            decelerationRate="fast"
          />
        )}
      </View>

      {/* ✅ AQUÍ VA TU BOTTOM TAB */}
    </SafeAreaView>
  );
};

export default HomeScreen;
</file>

<file path="frontend/screens/LoginScreen.js">
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, Alert, ActivityIndicator } from 'react-native';
import { login } from '../services/authService';
import AuthContainer from '../components/AuthContainer'; // Reutilizamos el contenedor
import { styles } from '../styles/loginScreenStyles'; // Usamos los nuevos estilos

const LoginScreen = ({ navigation }) => {
  // --- LÓGICA EXISTENTE (INTACTA) ---
  const [correo, setCorreo] = useState('');
  const [contrasena, setContrasena] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleLogin = async () => {
    if (!correo || !contrasena) {
      Alert.alert('Error', 'Por favor, introduce tu correo y contraseña.');
      return;
    }
    setIsLoading(true);
    try {
      const response = await login(correo, contrasena);
      if (response && response.token) {
        const clienteId = response.usuario?.cliente_id;
        if (!clienteId) {
          Alert.alert('Error', 'No se pudo obtener la información del cliente.');
          return;
        }
        navigation.replace('Main', { clienteId });
      } else {
        const serverMessage = response.detail || 'Usuario o contraseña incorrectos.';
        Alert.alert('Error de inicio de sesión', serverMessage);
      }
    } catch (error) {
      const errorMessage = error.response?.data?.detail || 'Ocurrió un problema al conectar con el servidor.';
      Alert.alert('Error de inicio de sesión', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const goToRegister = () => {
    navigation.navigate('Register');
  };

  // --- NUEVA ESTRUCTURA VISUAL BASADA EN FIGMA ---
  return (
    <AuthContainer>
      <View style={styles.card}>
        <Text style={styles.title}>Welcome to PawPals</Text>

        <TextInput
          style={styles.input}
          placeholder="User / E-mail"
          placeholderTextColor="#888"
          value={correo}
          onChangeText={setCorreo}
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <TextInput
          style={styles.input}
          placeholder="Contraseña"
          placeholderTextColor="#888"
          secureTextEntry={true}
          value={contrasena}
          onChangeText={setContrasena}
        />
        
        <TouchableOpacity
          style={styles.button}
          onPress={handleLogin}
          disabled={isLoading}
        >
          {isLoading ? (
            <ActivityIndicator color="#fff" />
          ) : (
            <Text style={styles.buttonText}>Iniciar Sesión</Text>
          )}
        </TouchableOpacity>
        
        <Text style={styles.forgotPasswordText}>¿Olvidaste tu contraseña?</Text>

        <TouchableOpacity style={styles.registerContainer} onPress={goToRegister}>
          <Text style={styles.registerText}>
            ¿No tienes una cuenta? <Text style={styles.registerLink}>Regístrate</Text>
          </Text>
        </TouchableOpacity>
      </View>
    </AuthContainer>
  );
};

export default LoginScreen;
</file>

<file path="frontend/screens/OrderSuccessScreen.js">
// frontend/screens/OrderSuccessScreen.js

import React, { useEffect } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  TouchableOpacity,
  Image,
  Animated,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { styles } from '../styles/orderSuccessScreenStyles';

const OrderSuccessScreen = ({ navigation, route }) => {
  const { clienteId, pedidoId, total } = route.params || {};

  // Animación de entrada
  const scaleAnim = React.useRef(new Animated.Value(0)).current;
  const fadeAnim = React.useRef(new Animated.Value(0)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.spring(scaleAnim, {
        toValue: 1,
        tension: 50,
        friction: 7,
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 800,
        useNativeDriver: true,
      }),
    ]).start();
  }, []);

  const handleGoHome = () => {
    navigation.reset({
      index: 0,
      routes: [{ name: 'Main', params: { clienteId } }],
    });
  };

  const handleViewOrders = () => {
    // TODO: Implementar navegación a historial de pedidos
    handleGoHome();
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <View style={styles.container}>
        {/* ÍCONO DE ÉXITO ANIMADO */}
        <Animated.View
          style={[
            styles.iconContainer,
            {
              transform: [{ scale: scaleAnim }],
              opacity: fadeAnim,
            },
          ]}
        >
          <View style={styles.iconCircle}>
            <Ionicons name="checkmark" size={80} color="white" />
          </View>
        </Animated.View>

        {/* MENSAJE */}
        <Animated.View style={[styles.messageContainer, { opacity: fadeAnim }]}>
          <Text style={styles.title}>¡Pedido Realizado!</Text>
          <Text style={styles.subtitle}>
            Tu pedido ha sido procesado exitosamente
          </Text>

          {/* INFORMACIÓN DEL PEDIDO */}
          <View style={styles.orderInfoCard}>
            <View style={styles.orderInfoRow}>
              <Text style={styles.orderInfoLabel}>Número de Pedido:</Text>
              <Text style={styles.orderInfoValue}>#{pedidoId || 'N/A'}</Text>
            </View>

            <View style={styles.divider} />

            <View style={styles.orderInfoRow}>
              <Text style={styles.orderInfoLabel}>Total Pagado:</Text>
              <Text style={styles.orderInfoValueHighlight}>
                S/ {total?.toFixed(2) || '0.00'}
              </Text>
            </View>
          </View>

          {/* MENSAJE ADICIONAL */}
          <View style={styles.additionalInfo}>
            <Ionicons name="time-outline" size={24} color="#875686" />
            <Text style={styles.additionalInfoText}>
              Recibirás una notificación cuando tu pedido esté en camino
            </Text>
          </View>
        </Animated.View>

        {/* BOTONES */}
        <View style={styles.buttonsContainer}>
          <TouchableOpacity
            style={styles.primaryButton}
            onPress={handleGoHome}
          >
            <Ionicons name="home" size={24} color="white" />
            <Text style={styles.primaryButtonText}>Volver al Inicio</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.secondaryButton}
            onPress={handleViewOrders}
          >
            <Ionicons name="receipt-outline" size={24} color="#875686" />
            <Text style={styles.secondaryButtonText}>Ver Mis Pedidos</Text>
          </TouchableOpacity>
        </View>

        {/* DECORACIÓN */}
        <View style={styles.decorationCircle1} />
        <View style={styles.decorationCircle2} />
      </View>
    </SafeAreaView>
  );
};

export default OrderSuccessScreen;
</file>

<file path="frontend/screens/PaymentScreen.js">
// frontend/screens/PaymentScreen.js (VERSIÓN SIMPLIFICADA)
import React, { useState } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  ScrollView,
  TouchableOpacity,
  Image,
  ImageBackground,
  Platform,
  Alert,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { styles } from '../styles/paymentScreenStyles'; // Usamos los mismos estilos base

const PaymentScreen = ({ navigation, route }) => {
  const { clienteId, total, pedidoId } = route.params || {};

  const [selectedMethodId, setSelectedMethodId] = useState(null);

  const paymentMethods = [
    { id: '1', name: 'Yape', qr: require('../assets/qr/imagen1.png'), icon: 'phone-portrait-outline' },
    { id: '2', name: 'Plin', qr: require('../assets/qr/imagen2.png'), icon: 'wallet-outline' },
  ];
  
  const handleContinue = () => {
    if (!selectedMethodId) {
        Alert.alert("Selección requerida", "Por favor, elige un método de pago para continuar.");
        return;
    }
    
    const selectedPaymentMethod = paymentMethods.find(m => m.id === selectedMethodId);

    // Navegamos a la nueva pantalla pasando todos los datos necesarios
    navigation.navigate('UploadProof', {
        clienteId,
        pedidoId,
        total,
        paymentMethod: selectedPaymentMethod, // Pasamos el objeto completo
    });
  };

  return (
    <View style={styles.mainContainer}>
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={30} color="white" />
          </TouchableOpacity>
          <Image source={require('../assets/logo_amarillo.png')} style={styles.logo} />
          <View style={{ width: 30 }} />
        </View>

        <View style={styles.container}>
          <ScrollView
           style={styles.container} // Quitamos flex: 1
            contentContainerStyle={styles.scrollContent}
            showsVerticalScrollIndicator={false}
          >
            <Text style={styles.paymentTitle}>Realizar Pago</Text>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Resumen del Pago</Text>
              <View style={styles.summaryCard}>
                <View style={styles.summaryRow}>
                  <Text style={styles.summaryLabel}>Total a pagar:</Text>
                  <Text style={styles.totalValue}>S/ {total?.toFixed(2) || '0.00'}</Text>
                </View>
              </View>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>1. Selecciona el método de pago</Text>
              <View style={styles.methodsContainer}>
                {paymentMethods.map((method) => (
                  <TouchableOpacity
                    key={method.id}
                    style={[styles.methodCard, selectedMethodId === method.id && styles.methodCardSelected]}
                    onPress={() => setSelectedMethodId(method.id)}
                  >
                    <View style={styles.radioButton}>
                      {selectedMethodId === method.id && <View style={styles.radioButtonInner} />}
                    </View>
                    <Ionicons name={method.icon} size={24} color={selectedMethodId === method.id ? '#875686' : '#666'} />
                    <Text style={[styles.methodName, selectedMethodId === method.id && styles.methodNameSelected]}>
                      {method.name}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>
            </View>

            {selectedMethodId && (
              <View style={styles.section}>
                <Text style={styles.sectionTitle}>2. Escanea y Paga</Text>
                <View style={styles.qrCard}>
                  <Image source={paymentMethods.find(m => m.id === selectedMethodId)?.qr} style={styles.qrImage} />
                  <Text style={styles.qrInstructions}>
                    1. Abre tu app de {paymentMethods.find(m => m.id === selectedMethodId)?.name}.
                    {'\n'}2. Escanea este código QR.
                    {'\n'}3. Confirma el pago de S/ {total?.toFixed(2)}.
                    {'\n'}4. Guarda una captura del comprobante.
                  </Text>
                </View>
              </View>
            )}
          </ScrollView>

          {/* El botón de abajo ahora navega a la siguiente pantalla */}
          {selectedMethodId && (
            <View style={styles.bottomContainer}>
              <TouchableOpacity
                style={styles.confirmButton}
                onPress={handleContinue}
              >
                <Text style={styles.confirmButtonText}>Subir Comprobante</Text>
                <Ionicons name="arrow-forward-circle" size={24} color="white" style={{marginLeft: 8}}/>
              </TouchableOpacity>
            </View>
          )}
        </View>
      </SafeAreaView>
    </View>
  );
};

export default PaymentScreen;
</file>

<file path="frontend/screens/PetProfileScreen.js">
// frontend/screens/PetProfileScreen.js

import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  Image,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  ImageBackground
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';

import { getPetsByCliente } from '../services/petService';
import { styles, MAIN_PURPLE } from '../styles/petProfileScreenStyles';

const PetProfileScreen = ({ navigation, route }) => {
  const { clienteId } = route.params || {};

  const [pets, setPets] = useState([]);
  const [selectedPet, setSelectedPet] = useState(null);
  const [loading, setLoading] = useState(true);

  const loadPets = async () => {
    if (!clienteId) {
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      setLoading(false);
      return;
    }
    
    try {
      console.log(`🐾 Cargando mascotas para el cliente: ${clienteId}`);
      const response = await getPetsByCliente(clienteId);
      
      if (response && response.mascotas) {
        setPets(response.mascotas);
        if (response.mascotas.length > 0) {
          setSelectedPet(response.mascotas[0]);
        } else {
          setSelectedPet(null);
        }
      } else {
        setPets([]);
        setSelectedPet(null);
      }
    } catch (error) {
      console.error('❌ Error al cargar mascotas:', error);
      Alert.alert('Error', 'No se pudieron cargar los perfiles de las mascotas.');
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      setLoading(true);
      loadPets();
    }, [clienteId])
  );

  const renderPetSelector = () => (
    <View style={styles.petSelectorContainer}>
      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
        {pets.map(pet => (
          <TouchableOpacity 
            key={pet.id} 
            style={styles.petSelectorItem}
            onPress={() => setSelectedPet(pet)}
          >
            <View style={[
              styles.petImageWrapper,
              selectedPet?.id === pet.id && styles.petImageWrapperSelected
            ]}>
              <Image 
                source={pet.foto ? { uri: pet.foto.replace('static/', 'http://localhost:8000/static/') } : require('../assets/placeholder.png')} 
                style={styles.petImage} 
              />
            </View>
            <Text style={[
              styles.petSelectorName,
              selectedPet?.id === pet.id && styles.petSelectorNameSelected
            ]}>
              {pet.nombre}
            </Text>
          </TouchableOpacity>
        ))}
        <TouchableOpacity style={styles.petSelectorItem} onPress={() => navigation.navigate('AddPet', { clienteId })}>
            <View style={styles.petImageWrapper}>
                <Ionicons name="add" size={30} color="#CCC" />
            </View>
            <Text style={styles.petSelectorName}>Agregar</Text>
        </TouchableOpacity>
      </ScrollView>
    </View>
  );

  const renderEmptyState = () => (
    <View style={styles.emptyContainer}>
      <Ionicons name="paw-outline" size={100} color="#ccc" />
      <Text style={styles.emptyTitle}>Aún no tienes mascotas</Text>
      <Text style={styles.emptySubtitle}>
        Registra a tu primer compañero para ver su perfil aquí.
      </Text>
      <TouchableOpacity 
        style={styles.addButton} 
        onPress={() => navigation.navigate('AddPet', { clienteId })}
      >
        <Ionicons name="add-circle" size={24} color="white" />
        <Text style={styles.addButtonText}>Agregar Mascota</Text>
      </TouchableOpacity>
    </View>
  );

  const renderPetDetails = () => (
    <ScrollView>
      <View style={styles.detailCard}>
        <Image 
          source={selectedPet.foto ? { uri: selectedPet.foto.replace('static/', 'http://localhost:8000/static/') } : require('../assets/placeholder.png')}
          style={styles.mainPetImage}
        />
        <Text style={styles.petName}>{selectedPet.nombre}</Text>
        <View style={styles.detailGrid}>
          <View style={styles.detailItem}>
            <Text style={styles.detailLabel}>Especie</Text>
            <Text style={styles.detailValue}>{selectedPet.especie || 'N/A'}</Text>
          </View>
          <View style={styles.detailItem}>
            <Text style={styles.detailLabel}>Raza</Text>
            <Text style={styles.detailValue}>{selectedPet.raza || 'N/A'}</Text>
          </View>
          <View style={styles.detailItem}>
            <Text style={styles.detailLabel}>Edad</Text>
            <Text style={styles.detailValue}>{selectedPet.edad} años</Text>
          </View>
          <View style={styles.detailItem}>
            <Text style={styles.detailLabel}>Peso</Text>
            <Text style={styles.detailValue}>{selectedPet.peso ? `${selectedPet.peso} kg` : 'N/A'}</Text>
          </View>
        </View>
        <View style={styles.actionButtonsContainer}>
            <TouchableOpacity style={styles.editButton}>
                <Ionicons name="create-outline" size={20} color="white" />
                <Text style={styles.buttonText}>Editar Perfil</Text>
            </TouchableOpacity>
        </View>
      </View>
    </ScrollView>
  );

  return (
    <SafeAreaView style={styles.safeArea}>
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />
      <View style={styles.header}>
        <TouchableOpacity>
          <Ionicons name="menu" size={30} color="white" />
        </TouchableOpacity>
        <Image
          source={require('../assets/logo_amarillo.png')}
          style={styles.logo}
        />
        <TouchableOpacity onPress={() => navigation.navigate('Cart', { clienteId })}>
          <Ionicons name="cart-outline" size={30} color="white" />
        </TouchableOpacity>
      </View>
      <View style={styles.container}>
        {loading ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={MAIN_PURPLE} />
          </View>
        ) : pets.length > 0 ? (
          <View style={styles.profileContainer}>
            {renderPetSelector()}
            {selectedPet && renderPetDetails()}
          </View>
        ) : (
          renderEmptyState()
        )}
      </View>
    </SafeAreaView>
  );
};

export default PetProfileScreen;
</file>

<file path="frontend/screens/ProductDetailScreen.js">
// frontend/screens/ProductDetailScreen.js

import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  Image,
  TouchableOpacity,
  SafeAreaView,
  ScrollView,
  ActivityIndicator,
  Alert,
  ImageBackground,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { styles } from '../styles/productDetailScreenStyles';
import { getProductById } from '../services/productService';
import { addFavorite, removeFavorite, checkFavorite } from '../services/favoriteService';
import { addToCart } from '../services/cartService';

const ProductDetailScreen = ({ route, navigation }) => {
  const { productId, clienteId } = route.params;

  // Estados
  const [product, setProduct] = useState(null);
  const [loading, setLoading] = useState(true);
  const [quantity, setQuantity] = useState(1);
  const [isFavorite, setIsFavorite] = useState(false);
  const [favoriteLoading, setFavoriteLoading] = useState(false);

  const handleAddToCart = async () => {
  if (!clienteId) {
    Alert.alert('Error', 'No se pudo identificar al usuario.');
    return;
  }

  try {
    console.log('🛒 Agregando al carrito:', {
      clienteId,
      productId,
      quantity,
      productName: product.nombre
    });
    
    await addToCart(clienteId, product, quantity);
    
    console.log('✅ Producto agregado al carrito exitosamente');
    
    Alert.alert(
      "¡Añadido al Carrito!",
      `${product.nombre} (${quantity} unid.) se agregó correctamente.`,
      [
        { 
          text: "Ver Carrito", 
          onPress: () => {
            console.log('📱 Navegando a Cart con clienteId:', clienteId);
            navigation.navigate('Cart', { clienteId });
          }
        },
        { text: "Seguir Comprando", style: "cancel" }
      ],
      { cancelable: true }
    );
  } catch (error) {
    console.error('❌ Error al agregar al carrito:', error);
    Alert.alert('Error', 'No se pudo agregar al carrito.');
  }
};
  
   useEffect(() => {
    if (!clienteId) {
      console.error('❌ No se recibió cliente_id en ProductDetailScreen');
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      navigation.goBack();
    }
  }, [clienteId]);
 
  // Cargar datos del producto
  useEffect(() => {
    const fetchProduct = async () => {
      if (!clienteId) return;
      
      try {
        const data = await getProductById(productId);
        setProduct(data);
          
        // ✅ USAR clienteId recibido por parámetro
        const favStatus = await checkFavorite(clienteId, productId);
        setIsFavorite(favStatus.es_favorito);
      } catch (error) {
        console.error('❌ Error cargando producto:', error);
      } finally {
        setLoading(false);
      }
    };
    fetchProduct();
  }, [productId, clienteId]);


  // Manejadores
  const handleIncrement = () => setQuantity(prev => prev + 1);
  const handleDecrement = () => setQuantity(prev => (prev > 1 ? prev - 1 : 1));

  // Manejador de Favorito con notificación
  const handleFavorite = async () => {
    if (favoriteLoading || !clienteId) return;
    
    setFavoriteLoading(true);
    try {
      if (isFavorite) {
        // Eliminar de favoritos
        await removeFavorite(clienteId, productId);
        setIsFavorite(false);
        Alert.alert(
          "Eliminado de Favoritos",
          `${product.nombre} fue eliminado de tus favoritos.`,
          [{ text: "OK" }]
        );


      } else {
        // Agregar a favoritos
        await addFavorite(clienteId, productId);
        setIsFavorite(true);
        Alert.alert(
          "¡Agregado a Favoritos!",
          `${product.nombre} fue agregado a tus favoritos.`,
          [{ text: "OK" }]
        );
      }
    } catch (error) {
      const errorMessage = error.response?.data?.detail || 'Ocurrió un error al actualizar favoritos.';
      Alert.alert('Error', errorMessage);
    } finally {
      setFavoriteLoading(false);
    }
  };

  // Loading
  if (loading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#875686" />
          <Text style={{ marginTop: 10, color: '#666' }}>Cargando producto...</Text>
        </View>
      </SafeAreaView>
    );
  }

  // Error - producto no encontrado
  if (!product) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={30} color="white" />
          </TouchableOpacity>
          <Image source={require('../assets/logo_amarillo.png')} style={styles.logo} />
          <View style={{ width: 30 }} />
        </View>
        
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>No se pudo cargar el producto</Text>
          <TouchableOpacity style={styles.errorButton} onPress={() => navigation.goBack()}>
            <Text style={styles.errorButtonText}>Volver</Text>
          </TouchableOpacity>
        </View>
      </SafeAreaView>
    );
  }

  // Imagen del producto
  const imageSource = product.imagen 
    ? { uri: product.imagen } 
    : require('../assets/placeholder.png');

  return (
    <SafeAreaView style={styles.safeArea}>

    {/* 🔥 FONDO IGUAL AL HOME Y FAVORITES */}
    <ImageBackground
      source={require('../assets/FONDOA.png')}
      style={styles.backgroundImage}
      resizeMode="cover"
    />

    {/* Header Morado */}
    <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="arrow-back" size={30} color="white" />
        </TouchableOpacity>
        <Image source={require('../assets/logo_amarillo.png')} style={styles.logo} />
        <TouchableOpacity>
          <Ionicons name="cart-outline" size={30} color="white" />
        </TouchableOpacity>
      </View>

      {/* Contenedor Principal */}
      <View style={styles.container}>
        {/* Imagen Flotante - FUERA del ScrollView */}
        <View style={styles.imageContainer}>
          <Image source={imageSource} style={styles.productImage} />
        </View>

        {/* Botón Favorito Flotante MODIFICADO */}
        <TouchableOpacity 
          style={styles.favoriteButton}
          onPress={handleFavorite} // 👈 Acción de click
        >
          <Ionicons 
            name={isFavorite ? "heart" : "heart-outline"} // 👈 Cambia el ícono si es favorito
            size={28} 
            color="#875686" 
          />
        </TouchableOpacity>

        <ScrollView 
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
        >

          {/* Contenido */}
          <View style={styles.contentContainer}>
            {/* Título */}
            <Text style={styles.productName}>{product.nombre}</Text>

            {/* Precio */}
            <View style={styles.priceRow}>
              <Text style={styles.productPrice}>
                S/ {product.precio?.toFixed(2) || '0.00'}
              </Text>
            </View>

            {/* Etiquetas */}
            <View style={styles.tagsContainer}>
              {['Alto en Proteína', 'BARF', 'Sin Conservantes'].map((tag, index) => (
                <View key={`test-${index}`} style={styles.tag}>
                  <Text style={styles.tagText}>{tag}</Text>
                </View>
              ))}
            </View>

            {/* Ingredientes Clave */}
            {product.descripcion && (
              <View style={styles.section}>
                <Text style={styles.sectionTitle}>Ingredientes Clave</Text>
                <Text style={styles.sectionText}>{product.descripcion}</Text>
              </View>
            )}

            {/* Beneficios Clave */}
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Beneficios Clave</Text>
              <Text style={styles.sectionText}>
                • Alto contenido nutricional{'\n'}
                • Ingredientes naturales{'\n'}
                • Especialmente formulado para tu mascota
              </Text>
            </View>

            {/* Contador de Cantidad */}
            <View style={styles.quantityContainer}>
              <TouchableOpacity 
                style={styles.quantityButton} 
                onPress={handleDecrement}
              >
                <Ionicons name="remove" size={24} color="white" />
              </TouchableOpacity>
              
              <Text style={styles.quantityText}>{quantity}</Text>
              
              <TouchableOpacity 
                style={styles.quantityButton} 
                onPress={handleIncrement}
              >
                <Ionicons name="add" size={24} color="white" />
              </TouchableOpacity>
            </View>

            {/* Botón Agregar al Carrito */}
            <TouchableOpacity 
              style={styles.addToCartButton}
              onPress={handleAddToCart} // 👈 Llamará al Alert
            >
              <Ionicons name="cart" size={24} color="white" />
              <Text style={styles.addToCartText}>Agregar al carrito</Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </View>

      {/* Barra de Navegación Inferior */}
      
    </SafeAreaView>
  );
};

export default ProductDetailScreen;
</file>

<file path="frontend/screens/RegisterScreen.js">
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, TouchableOpacity, Alert, Picker, ActivityIndicator } from 'react-native';
import AuthContainer from '../components/AuthContainer.js';
import { styles } from '../styles/registerScreenStyles';
import { register } from '../services/authService';
import { createPet, getSpecies, getBreedsBySpecies } from '../services/petService';

const RegisterScreen = ({ navigation }) => {
  // --- ESTADOS ---
  const [step, setStep] = useState(1);
  // Estados del formulario de usuario
  const [correo, setCorreo] = useState('');
  const [nombre, setNombre] = useState('');
  const [contrasena, setContrasena] = useState('');
  const [confirmContrasena, setConfirmContrasena] = useState('');
  const [isFormValid, setIsFormValid] = useState(false);
  
  // Estados del formulario de mascota
  const [petName, setPetName] = useState('');
  const [petType, setPetType] = useState('');
  const [breed, setBreed] = useState('');
  const [age, setAge] = useState('');
  const [petSex, setPetSex] = useState('M');
  
  // Estados de datos y carga
  const [especies, setEspecies] = useState([]);
  const [razas, setRazas] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [razasLoading, setRazasLoading] = useState(false);

  // ✅ NUEVO ESTADO: para guardar los datos del usuario registrado
  const [userData, setUserData] = useState(null);

  // --- LÓGICA DE CARGA DE DATOS (useEffect) ---
  
  // Carga las especies al iniciar
  useEffect(() => {
    const loadSpecies = async () => {
      try {
        const speciesData = await getSpecies();
        setEspecies(speciesData);
        if (speciesData.length > 0) setPetType(speciesData[0].id);
      } catch (error) {
        console.error('❌ Error cargando especies:', error);
      }
    };
    loadSpecies();
  }, []);

  // Carga las razas cuando cambia el tipo de mascota
  useEffect(() => {
    const loadBreeds = async () => {
      if (!petType) return;
      setRazasLoading(true);
      setRazas([]);
      try {
        const breedsData = await getBreedsBySpecies(petType);
        setRazas(breedsData);
        if (breedsData.length > 0) setBreed(breedsData[0]);
      } catch (error) {
        console.error('❌ Error cargando razas:', error);
      } finally {
        setRazasLoading(false);
      }
    };
    loadBreeds();
  }, [petType]);

  // Valida el formulario del usuario
  useEffect(() => {
    const isValid =
      nombre.trim().length > 0 &&
      /\S+@\S+\.\S+/.test(correo) &&
      contrasena.length >= 6 &&
      contrasena.length <= 72 &&
      contrasena === confirmContrasena;
    setIsFormValid(isValid);
  }, [nombre, correo, contrasena, confirmContrasena]);

  // --- MANEJADORES DE ACCIONES ---

  // ✅ LÓGICA CORREGIDA: Ahora registra al usuario y avanza
  const handleNextStep = async () => {
    if (isLoading || !isFormValid) return;
    setIsLoading(true);
    try {
      console.log('🌐 Registrando usuario...');
      const response = await register({ nombre, correo, contrasena });
      console.log('✅ Usuario registrado:', response);
      
      setUserData(response.usuario); // Guardamos los datos del usuario
      setStep(2); // Avanzamos al siguiente paso
    } catch (error) {
      const errorMessage = error.response?.data?.detail || 'Ocurrió un error al registrar el usuario.';
      Alert.alert('Error de Registro', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // ✅ LÓGICA CORREGIDA: Ahora solo registra la mascota
  const handleFinishRegistration = async () => {
    if (isLoading || !userData?.cliente_id) return;
    if (!petName.trim() || !breed || !age.trim()) {
      Alert.alert('Campos incompletos', 'Por favor completa todos los campos de la mascota.');
      return;
    }
    setIsLoading(true);
    try {
      const clienteId = userData.cliente_id;
      console.log(`🐾 Registrando mascota para el cliente ID: ${clienteId}`);
      const petData = { nombre: petName, especie_id: petType, raza: breed, edad: parseInt(age, 10), sexo: petSex };
      await createPet(clienteId, petData);
      console.log('✅ Mascota registrada exitosamente');
      navigation.replace('Success', { clienteId });
    } catch (error) {
      const errorMessage = error.response?.data?.detail || 'Ocurrió un error al registrar la mascota.';
      Alert.alert('Error', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // ✅ LÓGICA CORREGIDA: Ahora solo navega
  const handleSkipPet = () => {
    console.log('🚀 Omitiendo registro de mascota, navegando a Success...');
    const clienteId = userData?.cliente_id;

    if (clienteId) {
      navigation.replace('Success', { clienteId });
    } else {
      navigation.replace('Login');
    }
  };

  // --- RENDERIZADO DE COMPONENTES ---

  const renderUserForm = () => (
    <>
      <Text style={styles.title}>Registro:</Text>
      <TextInput style={styles.input} placeholder="Nombre" value={nombre} onChangeText={setNombre} />
      <TextInput style={styles.input} placeholder="E-mail" value={correo} onChangeText={setCorreo} keyboardType="email-address" autoCapitalize="none" />
      <TextInput style={styles.input} placeholder="Contraseña (6-72 caracteres)" value={contrasena} onChangeText={setContrasena} secureTextEntry maxLength={72} />
      <TextInput style={styles.input} placeholder="Repetir Contraseña" value={confirmContrasena} onChangeText={setConfirmContrasena} secureTextEntry maxLength={72} />
      
      <TouchableOpacity 
        style={[styles.buttonPrimary, (!isFormValid || isLoading) && styles.buttonDisabled]}
        onPress={handleNextStep}
        disabled={!isFormValid || isLoading}
      >
        {isLoading ? <ActivityIndicator color="#fff" /> : <Text style={styles.buttonText}>Siguiente</Text>}
      </TouchableOpacity>
    </>
  );

  const renderPetForm = () => {
    const isPetFormValid = petName.trim() && breed && age.trim() && !razasLoading;

    return (
      <>
        <Text style={styles.title}>Añade tu Mascota:</Text>
        <TextInput style={styles.input} placeholder="Nombre de la mascota" value={petName} onChangeText={setPetName} />
        
        <View style={styles.pickerContainer}>
          <Text style={styles.pickerLabel}>Tipo de mascota:</Text>
          <Picker selectedValue={petType} onValueChange={setPetType} style={styles.picker}>
            {especies.map(e => <Picker.Item key={e.id} label={e.nombre} value={e.id} />)}
          </Picker>
        </View>
        
        <View style={styles.pickerContainer}>
          <Text style={styles.pickerLabel}>Raza:</Text>
          {razasLoading ? (
            <ActivityIndicator size="small" color="#732C71" style={{ height: 40 }}/>
          ) : (
            <Picker selectedValue={breed} onValueChange={setBreed} style={styles.picker} enabled={!razasLoading && razas.length > 0}>
              {razas.map((r, index) => <Picker.Item key={index} label={r} value={r} />)}
            </Picker>
          )}
        </View>

        <TextInput style={styles.input} placeholder="Edad (años)" value={age} onChangeText={setAge} keyboardType="numeric" />
        
        <View style={styles.pickerContainer}>
          <Text style={styles.pickerLabel}>Sexo:</Text>
          <Picker selectedValue={petSex} onValueChange={setPetSex} style={styles.picker}>
            <Picker.Item label="Macho" value="M" />
            <Picker.Item label="Hembra" value="H" />
          </Picker>
        </View>
        
        <View style={styles.buttonRow}>
          <TouchableOpacity style={[styles.buttonFlex, styles.buttonSecondary]} onPress={handleSkipPet} disabled={isLoading}>
            <Text style={styles.buttonSecondaryText}>Omitir</Text>
          </TouchableOpacity>
          <TouchableOpacity style={[styles.buttonFlex, { backgroundColor: '#732C71' }, (!isPetFormValid || isLoading) && styles.buttonDisabled]} onPress={handleFinishRegistration} disabled={!isPetFormValid || isLoading}>
            {isLoading ? <ActivityIndicator color="white" size="small" /> : <Text style={styles.buttonText}>Guardar</Text>}
          </TouchableOpacity>
        </View>
      </>
    );
  };

  return (
    <AuthContainer>
      <View style={styles.card}>
        {step === 1 ? renderUserForm() : renderPetForm()}
        <View style={styles.progressContainer}>
          <View style={[styles.progressDot, step === 1 && styles.progressDotActive]} />
          <View style={[styles.progressDot, step === 2 && styles.progressDotActive]} />
        </View>
      </View>
    </AuthContainer>
  );
};

export default RegisterScreen;
</file>

<file path="frontend/screens/SplashScreen.js">
// frontend/screens/SplashScreen.js (CON IMÁGENES)
import React, { useEffect, useRef } from 'react';
import { View, Image, Animated } from 'react-native';
import { styles } from '../styles/splashScreenStyles';

const logo = require('../assets/logo_amarillo.png');
const bone = require('../assets/bone.png'); // 🔥 Imagen de huesito
const paw = require('../assets/paw.png');   // 🔥 Imagen de patita

const SplashScreen = ({ navigation }) => {
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const scaleAnim = useRef(new Animated.Value(0.8)).current;
  const screenFadeAnim = useRef(new Animated.Value(1)).current;

  useEffect(() => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 800,
        useNativeDriver: true,
      }),
      Animated.spring(scaleAnim, {
        toValue: 1,
        tension: 10,
        friction: 2,
        useNativeDriver: true,
      }),
    ]).start();

    const exitTimer = setTimeout(() => {
      Animated.timing(screenFadeAnim, {
        toValue: 0,
        duration: 500,
        useNativeDriver: true,
      }).start(() => {
        navigation.replace('Welcome');
      });
    }, 2500);

    return () => clearTimeout(exitTimer);
  }, [navigation]);

  return (
    <Animated.View style={[styles.background, { opacity: screenFadeAnim }]}>
      <View style={styles.container}>
        {/* Logo animado */}
        <Animated.Image
          source={logo}
          style={[
            styles.logo,
            {
              opacity: fadeAnim,
              transform: [{ scale: scaleAnim }],
            },
          ]}
        />

        {/* Círculos decorativos */}
        <View style={styles.circleTopLeft} />
        <View style={styles.circleTopRight} />
        <View style={styles.circleBottomLeft} />
        <View style={styles.circleBottomRight} />
        
        {/* 🔥 HUESITOS CON IMÁGENES */}
        <Image source={bone} style={styles.boneImage1} />
        <Image source={bone} style={styles.boneImage2} />
        
        {/* 🔥 PATITAS CON IMÁGENES */}
        <Image source={paw} style={styles.pawImage1} />
        <Image source={paw} style={styles.pawImage2} />
        <Image source={paw} style={styles.pawImage3} />
      </View>
    </Animated.View>
  );
};

export default SplashScreen;
</file>

<file path="frontend/screens/SuccessScreen.js">
// frontend/screens/SuccessScreen.js

import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { Feather } from '@expo/vector-icons';

import AuthContainer from '../components/AuthContainer';
import { styles } from '../styles/successScreenStyles';

const SuccessScreen = ({ navigation, route }) => {
  //  RECIBIR clienteId desde RegisterScreen
  const clienteId = route.params?.clienteId;

  const handleNext = () => {
    if (clienteId) {
      //  PASAR clienteId a HomeScreen
      navigation.replace('Main', { clienteId });
    } else {
      console.error('❌ No se recibió clienteId en SuccessScreen');
      navigation.replace('Login');
    }
  };

  return (
    <AuthContainer>
      <View style={styles.card}>
        {/* Ícono de Éxito */}
        <View style={styles.iconContainer}>
          <Feather name="check" size={50} color="#732C71" />
        </View>

        <Text style={styles.title}>REGISTRO TERMINADO</Text>
        <Text style={styles.subtitle}>
          El proceso se ha realizado correctamente
        </Text>

        <TouchableOpacity
          style={styles.buttonPrimary}
          onPress={handleNext}
        >
          <Text style={styles.buttonText}>Siguiente</Text>
        </TouchableOpacity>
      </View>
    </AuthContainer>
  );
};

export default SuccessScreen;
</file>

<file path="frontend/screens/UploadProofScreen.js">
// frontend/screens/UploadProofScreen.js (VERSIÓN FINAL Y ROBUSTA)
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  ScrollView,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  Alert,
  ImageBackground,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import { processPayment } from '../services/paymentService';
import { styles } from '../styles/paymentScreenStyles';

const UploadProofScreen = ({ navigation, route }) => {
  const { clienteId, pedidoId, total, paymentMethod } = route.params || {};

  const [paymentProof, setPaymentProof] = useState(null);
  const [processing, setProcessing] = useState(false);

  // Verificación de que los parámetros llegan correctamente al montar la pantalla
  useEffect(() => {
    if (!clienteId || !pedidoId || !total || !paymentMethod) {
      console.error("❌ Faltan parámetros esenciales en UploadProofScreen:", route.params);
      Alert.alert(
        "Error de navegación",
        "Faltan datos para procesar el pago. Por favor, vuelve a intentarlo desde el checkout.",
        [{ text: "Volver", onPress: () => navigation.goBack() }]
      );
    }
  }, []);


  const handleSelectProof = async () => {
    try {
      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permiso requerido', 'Necesitamos acceso a tus fotos para subir el comprobante.');
        return;
      }
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        allowsEditing: true,
        quality: 0.8,
      });
      if (!result.canceled && result.assets && result.assets.length > 0) {
        console.log("✅ Imagen seleccionada:", result.assets[0].uri);
        setPaymentProof(result.assets[0]);
      }
    } catch (error) {
      console.error('❌ Error al seleccionar imagen:', error);
      Alert.alert('Error', 'No se pudo seleccionar la imagen.');
    }
  };

  // ✅ SOLUCIÓN: La lógica se mueve a una función que se llama desde el Alert.
  // Esto asegura que siempre se ejecute con el estado más reciente.
  const processPaymentAction = async () => {
    // Doble verificación por si acaso
    if (!paymentProof) {
        Alert.alert('Error', 'No se encontró el comprobante para enviar.');
        return;
    }

    console.log('🚀 Iniciando procesamiento de pago...');
    setProcessing(true);
    
    try {
      const result = await processPayment(
        clienteId, 
        pedidoId, 
        paymentMethod.id, 
        paymentProof
      );
      
      console.log('✅ Pago procesado exitosamente en el backend.');
      setProcessing(false);
      
      Alert.alert(
        '🎉 ¡Compra Exitosa!',
        'Tu pago ha sido procesado correctamente.\n\nRecibirás una confirmación cuando validemos tu comprobante.',
        [
          {
            text: 'Ver Detalles',
            onPress: () => {
              console.log('📱 Navegando a la pantalla de éxito...');
              navigation.reset({
                index: 0,
                routes: [
                  {
                    name: 'OrderSuccess',
                    params: {
                      clienteId,
                      pedidoId: result.pedido_id || pedidoId,
                      total,
                      metodoPago: paymentMethod.name,
                    }
                  }
                ],
              });
            }
          }
        ],
        { cancelable: false }
      );
      
    } catch (error) {
      console.error('❌ Error al procesar pago:', error.response?.data || error.message);
      setProcessing(false);
      
      const errorMessage = error.response?.data?.detail 
        || error.message 
        || 'No se pudo procesar el pago.';
      
      Alert.alert(
        'Error en el pago', 
        errorMessage,
        [{ text: 'OK' }]
      );
    }
  };


  const handleConfirmPayment = () => {
    console.log("--- DEBUG: Botón 'Confirmar Pago' presionado ---");
    console.log("--- DEBUG: Verificando 'paymentProof' state:", paymentProof ? `URI: ${paymentProof.uri}` : 'null');

    if (!paymentProof) {
      Alert.alert('Comprobante requerido', 'Por favor sube una captura del pago realizado.');
      return;
    }
    
    Alert.alert(
      'Confirmar Pago',
      `¿Deseas confirmar el pago de S/ ${total.toFixed(2)}?`,
      [
        { text: 'Cancelar', style: 'cancel' },
        // ✅ Se llama a la función de procesamiento directamente desde el onPress
        { text: 'Confirmar', onPress: processPaymentAction },
      ]
    );
  };

  return (
    <View style={styles.mainContainer}>
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => navigation.goBack()}>
            <Ionicons name="arrow-back" size={30} color="white" />
          </TouchableOpacity>
          <Image source={require('../assets/logo_amarillo.png')} style={styles.logo} />
          <View style={{ width: 30 }} />
        </View>

        <View style={styles.container}>
          <ScrollView
            contentContainerStyle={styles.scrollContent}
            showsVerticalScrollIndicator={false}
          >
            <Text style={styles.paymentTitle}>Sube tu Comprobante</Text>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Resumen</Text>
              <View style={styles.summaryCard}>
                <View style={styles.summaryRow}>
                  <Text style={styles.summaryLabel}>Total a pagar:</Text>
                  <Text style={styles.totalValue}>S/ {total?.toFixed(2) || '0.00'}</Text>
                </View>
                <View style={[styles.summaryRow, { marginTop: 10 }]}>
                  <Text style={styles.summaryLabel}>Método:</Text>
                  <Text style={[styles.summaryLabel, {color: '#875686'}]}>{paymentMethod?.name}</Text>
                </View>
              </View>
            </View>
            
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>Comprobante de Pago</Text>
              {!paymentProof ? (
                <TouchableOpacity style={styles.uploadButton} onPress={handleSelectProof}>
                  <Ionicons name="cloud-upload-outline" size={40} color="#875686" />
                  <Text style={styles.uploadText}>Subir captura del pago</Text>
                  <Text style={styles.uploadSubtext}>JPG, PNG (Máx. 5MB)</Text>
                </TouchableOpacity>
              ) : (
                <View style={styles.proofContainer}>
                  <Image source={{ uri: paymentProof.uri }} style={styles.proofImage} />
                  <TouchableOpacity style={styles.changeProofButton} onPress={handleSelectProof}>
                    <Ionicons name="refresh" size={20} color="white" />
                    <Text style={styles.changeProofText}>Cambiar imagen</Text>
                  </TouchableOpacity>
                </View>
              )}
            </View>

            <View style={styles.infoBox}>
              <Ionicons name="information-circle" size={24} color="#875686" />
              <Text style={styles.infoText}>
                Tu pedido será procesado una vez que nuestro equipo verifique el pago. Recibirás una confirmación en breve.
              </Text>
            </View>
          </ScrollView>

          {/* El botón de confirmar ahora vive aquí */}
          {paymentProof && (
            <View style={styles.bottomContainer}>
              <TouchableOpacity
                style={[styles.confirmButton, processing && styles.confirmButtonDisabled]}
                onPress={handleConfirmPayment} 
                disabled={processing}
              >
                {processing ? (
                  <ActivityIndicator color="white" />
                ) : (
                  <>
                    <Ionicons name="checkmark-circle" size={24} color="white" />
                    <Text style={styles.confirmButtonText}>Confirmar Pago</Text>
                  </>
                )}
              </TouchableOpacity>
            </View>
          )}
        </View>
      </SafeAreaView>
    </View>
  );
};

export default UploadProofScreen;
</file>

<file path="frontend/screens/UserProfileScreen.js">
// frontend/screens/UserProfileScreen.js

import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  SafeAreaView,
  Image,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  ImageBackground,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useFocusEffect } from '@react-navigation/native';

import { getClientProfile } from '../services/authService'; // Necesitaremos esta nueva función
import { getPetsByCliente } from '../services/petService';
import { styles } from '../styles/userProfileScreenStyles';

// Imágenes por defecto locales
const defaultUserImage = require('../assets/user.png');
const defaultDogImage = require('../assets/perro.png');
const defaultCatImage = require('../assets/gato.png');

const UserProfileScreen = ({ navigation, route }) => {
  const { clienteId } = route.params;

  const [profile, setProfile] = useState(null);
  const [pets, setPets] = useState([]);
  const [loading, setLoading] = useState(true);

  const loadData = async () => {
    if (!clienteId) {
      Alert.alert('Error', 'No se pudo identificar al usuario.');
      setLoading(false);
      return;
    }
    try {
      // Cargar perfil y mascotas en paralelo
      const [profileData, petsResponse] = await Promise.all([
        getClientProfile(clienteId),
        getPetsByCliente(clienteId)
      ]);
      setProfile(profileData);
      setPets(petsResponse.mascotas || []);
    } catch (error) {
      console.error('❌ Error al cargar datos del perfil:', error);
      Alert.alert('Error', 'No se pudieron cargar los datos del perfil.');
    } finally {
      setLoading(false);
    }
  };

  useFocusEffect(
    useCallback(() => {
      setLoading(true);
      loadData();
    }, [clienteId])
  );

  const getPetDefaultImage = (especie) => {
    if (especie.toLowerCase().includes('perro')) return defaultDogImage;
    if (especie.toLowerCase().includes('gato')) return defaultCatImage;
    return defaultUserImage; // Una imagen genérica si no es perro o gato
  };
  
  if (loading) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#FFF" />
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <ImageBackground
        source={require('../assets/FONDOA.png')}
        style={styles.backgroundImage}
        resizeMode="cover"
      />
      <View style={styles.header}>
        <TouchableOpacity onPress={() => navigation.openDrawer()}>
          <Ionicons name="menu" size={30} color="white" />
        </TouchableOpacity>
        <Image
          source={require('../assets/logo_amarillo.png')}
          style={styles.logo}
        />
        <TouchableOpacity onPress={() => navigation.navigate('Cart', { clienteId })}>
          <Ionicons name="cart-outline" size={30} color="white" />
        </TouchableOpacity>
      </View>

      <View style={styles.container}>
        <ScrollView contentContainerStyle={styles.scrollView}>
          {/* SECCIÓN DEL PERFIL DE USUARIO */}
          <View style={styles.profileHeader}>
            <View style={styles.headerRow}>
              <TouchableOpacity style={styles.backButton} onPress={() => navigation.goBack()}>
                <Ionicons name="arrow-back" size={24} color="white" />
              </TouchableOpacity>
              <Text style={styles.headerTitle}>Tu perfil</Text>
            </View>

            <View style={styles.profileSection}>
              <Image 
                source={profile?.foto ? { uri: profile.foto.replace('static/', 'http://localhost:8000/static/') } : defaultUserImage}
                style={styles.profilePic} 
              />
              <View style={styles.profileInfo}>
                <Text style={styles.profileName}>{profile?.nombre || 'Usuario'}</Text>
                <Text style={styles.profileContact}>{profile?.telefono || 'Sin teléfono'}</Text>
                <Text style={styles.profileContact}>{profile?.correo || 'Sin correo'}</Text>
                <TouchableOpacity style={styles.editButton}>
                  <Text style={styles.editButtonText}>Editar perfil</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>

          {/* SECCIÓN DE MASCOTAS */}
          <View style={styles.petsSection}>
            <Text style={styles.petsSectionTitle}>Mis Mascotas</Text>
            <View style={styles.petsList}>
              {pets.map(pet => (
                <TouchableOpacity key={pet.id} style={styles.petCard} onPress={() => navigation.navigate('PetProfile', { clienteId })}>
                  <Image 
                    source={pet.foto ? { uri: pet.foto.replace('static/', 'http://localhost:8000/static/') } : getPetDefaultImage(pet.especie)}
                    style={styles.petImage}
                  />
                  <Text style={styles.petName}>{pet.nombre}</Text>
                  <Text style={styles.petInfo}>{pet.raza}</Text>
                  <Text style={styles.petInfo}>{pet.edad} años</Text>
                  <Text style={styles.petDetails}>Peso: {pet.peso || 'N/A'} Kg. Alergias: Pollo</Text>
                </TouchableOpacity>
              ))}
              <TouchableOpacity style={styles.addPetCard} onPress={() => navigation.navigate('AddPet', { clienteId })}>
                <View style={styles.addPetCircle}>
                  <Ionicons name="add" size={30} color="white" />
                </View>
                <Text style={styles.addPetText}>Agregar nueva mascota</Text>
              </TouchableOpacity>
            </View>
          </View>
        </ScrollView>
      </View>
    </SafeAreaView>
  );
};

export default UserProfileScreen;
</file>

<file path="frontend/screens/WelcomeScreen.js">
import React from 'react';
// StyleSheet ya no se importa aquí
import { View, Text, Image, TouchableOpacity, ImageBackground } from 'react-native';
// Paso 1: Importar los estilos desde su nueva ubicación
import { styles } from '../styles/welcomeScreenStyles';

const backgroundImage = require('../assets/fondo.jpg');
const logo = require('../assets/logo.png');

const WelcomeScreen = ({ navigation }) => {
  return (
    <ImageBackground source={backgroundImage} style={styles.background}>
      <View style={styles.overlay} />
      <View style={styles.overlay2} />
      <View style={styles.container}>
        <Image source={logo} style={styles.logo} />

        <View style={styles.bottomContainer}>
          <TouchableOpacity 
            style={styles.loginButton} 
            onPress={() => navigation.navigate('Login')}
          >
            <Text style={styles.loginButtonText}>Iniciar Sesión</Text>
          </TouchableOpacity>

          <TouchableOpacity onPress={() => navigation.navigate('Register')}>
             <Text style={styles.registerText}>
              ¿No tienes una cuenta? <Text style={styles.registerLink}>Regístrate</Text>
            </Text>
          </TouchableOpacity>
        </View>
      </View>
    </ImageBackground>
  );
};

export default WelcomeScreen;
</file>

<file path="frontend/services/addressService.js">
import api from './api';

/**
 * 📍 SERVICIO DE DIRECCIONES
 * Maneja todas las operaciones relacionadas con direcciones de entrega
 */

/**
 * Obtiene todas las direcciones de un cliente
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Array>} Lista de direcciones
 */
export const getAddresses = async (clienteId) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('📍 Obteniendo direcciones para cliente:', clienteId);
    const response = await api.get(`/cliente/${clienteId}/direcciones`);

    console.log('✅ Respuesta del backend:', response.data);

    // Manejar caso de array vacío
    if (!response.data.direcciones || response.data.direcciones.length === 0) {
      console.log('ℹ️ No hay direcciones registradas');
      return [];
    }

    console.log('✅ Direcciones obtenidas:', response.data.direcciones.length);
    return response.data.direcciones;
  } catch (error) {
    console.error('❌ Error al obtener direcciones:', error.response?.data || error.message);

    // No lanzar error si es 404, devolver array vacío
    if (error.response?.status === 404) {
      return [];
    }

    throw error;
  }
};

/**
 * Crea una nueva dirección para el cliente
 * @param {string} clienteId - ID del cliente
 * @param {Object} addressData - Datos de la dirección
 * @returns {Promise<Object>}
 */
export const createAddress = async (clienteId, addressData) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('➕ Creando nueva dirección para cliente:', clienteId);
    console.log('📝 Datos:', addressData);

    const formData = new FormData();
    formData.append('nombre', addressData.nombre);
    formData.append('latitud', addressData.latitud.toString());
    formData.append('longitud', addressData.longitud.toString());
    formData.append('referencia', addressData.referencia || '');
    formData.append('es_principal', addressData.es_principal ? 'true' : 'false');

    const response = await api.post(
      `/cliente/${clienteId}/direccion`,
      formData,
      {
        headers: { 'Content-Type': 'multipart/form-data' },
      }
    );

    console.log('✅ Dirección creada exitosamente:', response.data);
    return response.data;
  } catch (error) {
    console.error('❌ Error al crear dirección:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene una dirección específica por su ID
 */
export const getAddressById = async (direccionId) => {
  try {
    if (!direccionId) throw new Error('direccionId es requerido');

    const response = await api.get(`/cliente/direccion/${direccionId}`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener dirección:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Actualiza una dirección existente
 */
export const updateAddress = async (direccionId, addressData) => {
  try {
    if (!direccionId) throw new Error('direccionId es requerido');

    console.log('📝 Actualizando dirección:', direccionId);

    const formData = new FormData();
    if (addressData.nombre) formData.append('nombre', addressData.nombre);
    if (addressData.latitud) formData.append('latitud', addressData.latitud.toString());
    if (addressData.longitud) formData.append('longitud', addressData.longitud.toString());
    if (addressData.referencia !== undefined) formData.append('referencia', addressData.referencia);
    if (addressData.es_principal !== undefined) {
      formData.append('es_principal', addressData.es_principal ? 'true' : 'false');
    }

    const response = await api.put(`/cliente/direccion/${direccionId}`, formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });

    console.log('✅ Dirección actualizada');
    return response.data;
  } catch (error) {
    console.error('❌ Error al actualizar dirección:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Elimina una dirección
 */
export const deleteAddress = async (direccionId) => {
  try {
    if (!direccionId) throw new Error('direccionId es requerido');

    console.log('🗑️ Eliminando dirección:', direccionId);
    const response = await api.delete(`/cliente/direccion/${direccionId}`);

    console.log('✅ Dirección eliminada');
    return response.data;
  } catch (error) {
    console.error('❌ Error al eliminar dirección:', error.response?.data || error.message);
    throw error;
  }
};
</file>

<file path="frontend/services/api.js">
import axios from 'axios';

// ✅ CAMBIO: Usa localhost en lugar de la IP
const API_URL = 'http://localhost:8000'; // ← CORREGIDO

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export default apiClient;
</file>

<file path="frontend/services/authService.js">
// Archivo: services/authService.js

import api from './api'; // Importamos nuestra instancia configurada de axios

/**
 * Función para iniciar sesión.
 * Llama al endpoint POST /auth/login.
 * @param {string} correo 
 * @param {string} contrasena 
 * @returns {Promise<Object>} 
 */
export const login = async (correo, contrasena) => {
  try {
    // El segundo argumento de api.post es el cuerpo (body) de la petición
    const response = await api.post('/auth/login', {
      correo, 
      contrasena, 
    });
    // Devolvemos los datos de la respuesta para que el componente los maneje
    return response.data; 
  } catch (error) {
    // Imprimimos un error más detallado en la consola para depuración
    console.error('Error en el servicio de login:', error.response ? error.response.data : error.message);
    // Propagamos el error para que el componente pueda mostrar un mensaje al usuario
    throw error;
  }
};

/**
 * Función para registrar un nuevo usuario.
 * Llama al endpoint POST /auth/register.
 * @param {Object} userData - Objeto con { nombre, correo, contrasena }.
 * @returns {Promise<Object>} La respuesta del servidor.
 */
export const register = async (userData) => {
  try {
    const response = await api.post('/auth/register', userData);
    // Devolvemos los datos de la respuesta (ej. un mensaje de éxito)
    return response.data;
  } catch (error) {
    console.error('Error en el servicio de registro:', error.response ? error.response.data : error.message);
    throw error;
  }
};

/**
 * Obtiene el perfil completo de un cliente.
 * Llama al endpoint GET /cliente/id/{cliente_id}.
 * @param {string} clienteId - ID del cliente.
 * @returns {Promise<Object>} El perfil del cliente.
 */
export const getClientProfile = async (clienteId) => {
  try {
    const response = await api.get(`/cliente/id/${clienteId}`);
    return response.data;
  } catch (error) {
    console.error('Error en el servicio getClientProfile:', error.response ? error.response.data : error.message);
    throw error;
  }
};
</file>

<file path="frontend/services/cartService.js">
// frontend/services/cartService.js

import AsyncStorage from '@react-native-async-storage/async-storage';

/**
 * 🛒 SERVICIO DEL CARRITO (Versión React Native con AsyncStorage)
 * Maneja todas las operaciones relacionadas con el carrito de compras
 */

/**
 * Obtiene todos los items del carrito del cliente
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Object>} Carrito con items y total
 */
export const getCart = async (clienteId) => {
  try {
    if (!clienteId) {
      console.error('❌ clienteId no proporcionado en getCart');
      return { items: [], total: 0, subtotal: 0 };
    }

    const cartKey = `cart_${clienteId}`;
    const cartData = await AsyncStorage.getItem(cartKey);
    
    if (!cartData) {
      console.log('📦 Carrito vacío para cliente:', clienteId);
      return { items: [], total: 0, subtotal: 0 };
    }
    
    const cart = JSON.parse(cartData);
    console.log('✅ Carrito cargado:', cart.items.length, 'items');
    return cart;
  } catch (error) {
    console.error('❌ Error al obtener carrito:', error);
    return { items: [], total: 0, subtotal: 0 };
  }
};

/**
 * Agrega un producto al carrito
 * @param {string} clienteId - ID del cliente
 * @param {Object} product - Producto a agregar
 * @param {number} quantity - Cantidad
 * @returns {Promise<Object>}
 */
export const addToCart = async (clienteId, product, quantity = 1) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('🛒 Agregando al carrito:', product.nombre, 'x', quantity);
    
    const cart = await getCart(clienteId);
    
    // Buscar si el producto ya existe en el carrito
    const existingItemIndex = cart.items.findIndex(
      item => item.plato_id === product.id
    );
    
    if (existingItemIndex >= 0) {
      // Si existe, incrementar cantidad
      cart.items[existingItemIndex].cantidad += quantity;
      cart.items[existingItemIndex].subtotal = 
        cart.items[existingItemIndex].cantidad * cart.items[existingItemIndex].precio_unitario;
      console.log('📝 Producto actualizado en carrito');
    } else {
      // Si no existe, agregarlo
      cart.items.push({
        plato_id: product.id,
        nombre: product.nombre,
        descripcion: product.descripcion,
        precio_unitario: product.precio,
        cantidad: quantity,
        subtotal: product.precio * quantity,
        imagen: product.imagen
      });
      console.log('➕ Producto agregado al carrito');
    }
    
    // Recalcular totales
    cart.subtotal = cart.items.reduce((sum, item) => sum + item.subtotal, 0);
    cart.total = cart.subtotal; // Aquí podrías agregar descuentos, envío, etc.
    
    // Guardar en AsyncStorage
    const cartKey = `cart_${clienteId}`;
    await AsyncStorage.setItem(cartKey, JSON.stringify(cart));
    
    console.log('💾 Carrito guardado. Total items:', cart.items.length);
    return cart;
  } catch (error) {
    console.error('❌ Error al agregar al carrito:', error);
    throw error;
  }
};

/**
 * Actualiza la cantidad de un producto en el carrito
 * @param {string} clienteId - ID del cliente
 * @param {string} platoId - ID del plato
 * @param {number} newQuantity - Nueva cantidad
 * @returns {Promise<Object>}
 */
export const updateCartItemQuantity = async (clienteId, platoId, newQuantity) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('🔄 Actualizando cantidad:', platoId, 'a', newQuantity);
    
    const cart = await getCart(clienteId);
    
    const itemIndex = cart.items.findIndex(item => item.plato_id === platoId);
    
    if (itemIndex === -1) {
      throw new Error('Producto no encontrado en el carrito');
    }
    
    if (newQuantity <= 0) {
      // Si la cantidad es 0 o negativa, eliminar el item
      return await removeFromCart(clienteId, platoId);
    }
    
    // Actualizar cantidad y subtotal
    cart.items[itemIndex].cantidad = newQuantity;
    cart.items[itemIndex].subtotal = 
      newQuantity * cart.items[itemIndex].precio_unitario;
    
    // Recalcular totales
    cart.subtotal = cart.items.reduce((sum, item) => sum + item.subtotal, 0);
    cart.total = cart.subtotal;
    
    // Guardar
    const cartKey = `cart_${clienteId}`;
    await AsyncStorage.setItem(cartKey, JSON.stringify(cart));
    
    console.log('✅ Cantidad actualizada');
    return cart;
  } catch (error) {
    console.error('❌ Error al actualizar cantidad:', error);
    throw error;
  }
};

/**
 * Elimina un producto específico del carrito
 * @param {string} clienteId - ID del cliente
 * @param {string} platoId - ID del plato a eliminar
 * @returns {Promise<Object>}
 */
export const removeFromCart = async (clienteId, platoId) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('🗑️ Eliminando del carrito:', platoId);
    
    const cart = await getCart(clienteId);
    
    // Filtrar el item a eliminar
    cart.items = cart.items.filter(item => item.plato_id !== platoId);
    
    // Recalcular totales
    cart.subtotal = cart.items.reduce((sum, item) => sum + item.subtotal, 0);
    cart.total = cart.subtotal;
    
    // Guardar
    const cartKey = `cart_${clienteId}`;
    await AsyncStorage.setItem(cartKey, JSON.stringify(cart));
    
    console.log('✅ Producto eliminado. Items restantes:', cart.items.length);
    return cart;
  } catch (error) {
    console.error('❌ Error al eliminar del carrito:', error);
    throw error;
  }
};

/**
 * Vacía completamente el carrito
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Object>}
 */
export const clearCart = async (clienteId) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    console.log('🧹 Vaciando carrito');
    
    const emptyCart = {
      items: [],
      subtotal: 0,
      total: 0
    };
    
    const cartKey = `cart_${clienteId}`;
    await AsyncStorage.setItem(cartKey, JSON.stringify(emptyCart));
    
    console.log('✅ Carrito vaciado');
    return emptyCart;
  } catch (error) {
    console.error('❌ Error al vaciar carrito:', error);
    throw error;
  }
};

/**
 * Obtiene la cantidad total de items en el carrito
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<number>}
 */
export const getCartItemCount = async (clienteId) => {
  try {
    if (!clienteId) {
      return 0;
    }
    
    const cart = await getCart(clienteId);
    const count = cart.items.reduce((sum, item) => sum + item.cantidad, 0);
    return count;
  } catch (error) {
    console.error('❌ Error al contar items del carrito:', error);
    return 0;
  }
};

/**
 * Finaliza la compra creando un pedido en el backend
 * @param {string} clienteId - ID del cliente
 * @param {string} direccionId - ID de la dirección de entrega
 * @returns {Promise<Object>}
 */
export const checkout = async (clienteId, direccionId) => {
  try {
    if (!clienteId) {
      throw new Error('clienteId es requerido');
    }

    if (!direccionId) {
      throw new Error('direccionId es requerido');
    }

    const cart = await getCart(clienteId);
    
    if (cart.items.length === 0) {
      throw new Error('El carrito está vacío');
    }
    
    // Preparar datos para el backend
    const pedidoData = {
      direccion_id: direccionId,
      platos: cart.items.map(item => ({
        plato_id: item.plato_id,
        cantidad: item.cantidad,
        precio_unitario: item.precio_unitario
      })),
      total: cart.total
    };
    
    console.log('💳 Procesando checkout:', pedidoData);
    
    // Enviar al backend
    const api = require('./api').default;
    const response = await api.post(`/cliente/pedido/${clienteId}`, pedidoData);
    
    console.log('✅ Respuesta del backend:', response.data);
    
    // Si el pedido se creó exitosamente, vaciar el carrito
    if (response.data.pedido_id) {
      await clearCart(clienteId);
      console.log('✅ Pedido creado exitosamente:', response.data.pedido_id);
    }
    
    return response.data;
  } catch (error) {
    console.error('❌ Error al finalizar compra:', error.response?.data || error.message);
    throw error;
  }
};
</file>

<file path="frontend/services/favoriteService.js">
// frontend/services/favoriteService.js

import api from './api';

/**
 * Agrega un plato a favoritos
 * @param {string} clienteId - ID del cliente
 * @param {string} platoId - ID del plato
 * @returns {Promise<Object>}
 */
export const addFavorite = async (clienteId, platoId) => {
  try {
    const response = await api.post(
      `/cliente/favoritos/${clienteId}/${platoId}`
    );
    return response.data;
  } catch (error) {
    console.error(
      '❌ Error al agregar favorito:',
      error.response?.data || error.message
    );
    throw error;
  }
};

/**
 * Elimina un plato de favoritos
 * @param {string} clienteId - ID del cliente
 * @param {string} platoId - ID del plato
 * @returns {Promise<Object>}
 */
export const removeFavorite = async (clienteId, platoId) => {
  try {
    const response = await api.delete(
      `/cliente/favoritos/${clienteId}/${platoId}`
    );
    return response.data;
  } catch (error) {
    console.error(
      '❌ Error al eliminar favorito:',
      error.response?.data || error.message
    );
    throw error;
  }
};

/**
 * Obtiene todos los favoritos de un cliente
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Object>}
 */
export const getFavorites = async (clienteId) => {
  try {
    const response = await api.get(
      `/cliente/favoritos/${clienteId}`
    );
    return response.data;
  } catch (error) {
    console.error(
      '❌ Error al obtener favoritos:',
      error.response?.data || error.message
    );
    throw error;
  }
};

/**
 * Verifica si un plato está en favoritos
 * @param {string} clienteId - ID del cliente
 * @param {string} platoId - ID del plato
 * @returns {Promise<Object>}
 */
export const checkFavorite = async (clienteId, platoId) => {
  try {
    const response = await api.get(
      `/cliente/favoritos/${clienteId}/check/${platoId}`
    );
    return response.data;
  } catch (error) {
    console.error(
      '❌ Error al verificar favorito:',
      error.response?.data || error.message
    );
    throw error;
  }
};
</file>

<file path="frontend/services/paymentService.js">
// frontend/services/paymentService.js

import api from './api';
import { clearCart } from './cartService';

/**
 * 💳 SERVICIO DE PAGOS
 * Maneja el procesamiento de pagos y comprobantes
 */

/**
 * Procesa un pago y sube el comprobante
 * @param {string} clienteId - ID del cliente
 * @param {string} pedidoId - ID del pedido
 * @param {string} metodoPagoId - ID del método de pago (1=Yape, 2=Plin)
 * @param {Object} comprobante - Objeto con la imagen del comprobante
 * @returns {Promise<Object>}
 */
export const processPayment = async (clienteId, pedidoId, metodoPagoId, comprobante) => {
  try {
    if (!clienteId || !pedidoId || !metodoPagoId) {
      throw new Error('Datos incompletos para procesar el pago');
    }

    console.log('💳 Procesando pago:', {
      clienteId,
      pedidoId,
      metodoPagoId,
      comprobanteUri: comprobante?.uri
    });

    // Crear FormData para enviar la imagen
    const formData = new FormData();
    formData.append('pasarela_pago_id', metodoPagoId);
    
    // Agregar la imagen del comprobante
    if (comprobante && comprobante.uri) {
      const uriParts = comprobante.uri.split('.');
      const fileType = uriParts[uriParts.length - 1];

      formData.append('comprobante', {
        uri: comprobante.uri,
        name: `comprobante_${pedidoId}.${fileType}`,
        type: `image/${fileType}`,
      });
    }

    // Enviar al backend
    const response = await api.post(
      `/cliente/pedido/${pedidoId}/pagar`,
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );

    console.log('✅ Pago procesado exitosamente:', response.data);

    // Vaciar el carrito después de confirmar el pago
    await clearCart(clienteId);
    console.log('🗑️ Carrito vaciado');

    return response.data;
  } catch (error) {
    console.error('❌ Error al procesar pago:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene el historial de pagos de un cliente
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Array>}
 */
export const getPaymentHistory = async (clienteId) => {
  try {
    const response = await api.get(`/cliente/${clienteId}/pagos`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener historial de pagos:', error);
    throw error;
  }
};

/**
 * Verifica el estado de un pago
 * @param {string} pagoId - ID del pago
 * @returns {Promise<Object>}
 */
export const checkPaymentStatus = async (pagoId) => {
  try {
    const response = await api.get(`/cliente/pago/${pagoId}/estado`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al verificar estado del pago:', error);
    throw error;
  }
};
</file>

<file path="frontend/services/petService.js">
// frontend/services/petService.js
import api from './api';

/**
 * Registra una nueva mascota para un cliente específico.
 * 
 * @param {string} clienteId - ID del cliente propietario
 * @param {Object} petData - Datos de la mascota
 * @param {string} petData.nombre - Nombre de la mascota
 * @param {string} petData.especie_id - ID de la especie (1 = perro, 2 = gato, etc.)
 * @param {string} petData.raza - Raza de la mascota
 * @param {number} petData.edad - Edad de la mascota en años
 * @param {string} petData.sexo - Sexo: 'M' (macho) o 'H' (hembra)
 * @returns {Promise<Object>} Respuesta del servidor con los datos de la mascota creada
 */
export const createPet = async (clienteId, petData) => {
  try {
    // Crear el FormData para enviar los datos
    const formData = new FormData();
    formData.append('nombre', petData.nombre);
    formData.append('especie_id', petData.especie_id);
    formData.append('raza', petData.raza);
    formData.append('edad', petData.edad.toString());
    formData.append('sexo', petData.sexo);

    // Hacer la petición POST al backend
    const response = await api.post(
      `/cliente/mascotas/${clienteId}`,
      formData,
      {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      }
    );

    return response.data;
  } catch (error) {
    console.error('❌ Error al crear la mascota:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene la lista de especies disponibles.
 * @returns {Promise<Array>} Lista de especies (perro, gato, etc.)
 */
export const getSpecies = async () => {
  try {
    const response = await api.get('/cliente/platos-mascotas/especies');
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener especies:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene todas las mascotas de un cliente.
 * @param {string} clienteId - ID del cliente
 * @returns {Promise<Array>} Lista de mascotas del cliente
 */
export const getPetsByCliente = async (clienteId) => {
  try {
    const response = await api.get(`/cliente/mascotas/${clienteId}`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener mascotas:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene el detalle completo de una mascota.
 * @param {string} mascotaId - ID de la mascota
 * @returns {Promise<Object>} Detalle de la mascota
 */
export const getPetDetail = async (mascotaId) => {
  try {
    const response = await api.get(`/cliente/mascotas/detalle/${mascotaId}`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener detalle de mascota:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Actualiza los datos de una mascota.
 * @param {string} mascotaId - ID de la mascota
 * @param {Object} updateData - Datos a actualizar
 * @returns {Promise<Object>} Respuesta del servidor
 */
export const updatePet = async (mascotaId, updateData) => {
  try {
    const formData = new FormData();
    if (updateData.nombre) formData.append('nombre', updateData.nombre);
    if (updateData.edad) formData.append('edad', updateData.edad.toString());
    if (updateData.peso) formData.append('peso', updateData.peso.toString());
    if (updateData.raza) formData.append('raza', updateData.raza);
    if (updateData.observaciones) formData.append('observaciones', updateData.observaciones);

    const response = await api.put(`/cliente/mascotas/${mascotaId}`, formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
    return response.data;
  } catch (error) {
    console.error('❌ Error al actualizar mascota:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Elimina una mascota.
 * @param {string} mascotaId - ID de la mascota
 * @returns {Promise<Object>} Respuesta del servidor
 */
export const deletePet = async (mascotaId) => {
  try {
    const response = await api.delete(`/cliente/mascotas/${mascotaId}`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al eliminar mascota:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Obtiene una lista de razas para una especie específica.
 * @param {string} especieId - El ID de la especie (e.g., '1' para Perro).
 * @returns {Promise<Array<string>>} Una lista de nombres de razas.
 */
export const getBreedsBySpecies = async (especieId) => {
  if (!especieId) return []; // No hacer la llamada si no hay especie seleccionada
  try {
    const response = await api.get(`/cliente/platos-mascotas/especies/${especieId}/razas`);
    return response.data;
  } catch (error) {
    console.error('❌ Error al obtener razas:', error.response?.data || error.message);
    return ["Mestizo"]; // Devolver un valor por defecto en caso de error
  }
};
</file>

<file path="frontend/services/productService.js">
// src/services/productService.js
import api from './api'; // instancia de axios preconfigurada con la baseURL del backend

/**
 * 🔹 Obtiene todos los productos (platos) filtrados opcionalmente.
 * Endpoint: GET /cliente/platos-mascotas
 * 
 * @param {Object} [filters] - Filtros para la búsqueda.
 * @param {string} [filters.categoria_id] - ID de la categoría.
 * @param {string} [filters.especie_id] - ID de la especie.
 * @param {Array<string>} [filters.etiquetas] - IDs de etiquetas.
 * @param {string} [filters.search] - Texto libre de búsqueda.
 * @returns {Promise<Array>} Lista de productos.
 */
export const getProducts = async (filters = {}) => {
  try {
    const response = await api.get('/cliente/platos-mascotas/', { params: filters });
    return response.data;
  } catch (error) {
    console.error('❌ Error en getProducts:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 🔹 Obtiene el detalle de un producto específico.
 * Endpoint: GET /cliente/platos-mascotas/id/{plato_id}
 * 
 * @param {string} productId - ID del producto a obtener.
 * @returns {Promise<Object>} Detalle del producto.
 */
export const getProductById = async (productId) => {
  try {
    const response = await api.get(`/cliente/platos-mascotas/id/${productId}`);
    return response.data;
  } catch (error) {
    console.error('❌ Error en getProductById:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 🔹 Obtiene todas las categorías activas.
 * Endpoint: GET /cliente/platos-mascotas/categorias
 * 
 * @returns {Promise<Array>} Lista de categorías.
 */
export const getCategories = async () => {
  try {
    const response = await api.get('/cliente/platos-mascotas/categorias');
    return response.data;
  } catch (error) {
    console.error('❌ Error en getCategories:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 🔹 Obtiene las especies activas (Perros, Gatos, etc.)
 * Endpoint: GET /cliente/platos-mascotas/especies
 * 
 * @returns {Promise<Array>} Lista de especies.
 */
export const getSpecies = async () => {
  try {
    const response = await api.get('/cliente/platos-mascotas/especies');
    return response.data;
  } catch (error) {
    console.error('❌ Error en getSpecies:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * 🔹 Obtiene las etiquetas activas relacionadas con platos publicados.
 * Endpoint: GET /cliente/platos-mascotas/etiquetas
 * 
 * @returns {Promise<Array>} Lista de etiquetas.
 */
export const getTags = async () => {
  try {
    const response = await api.get('/cliente/platos-mascotas/etiquetas');
    return response.data;
  } catch (error) {
    console.error('❌ Error en getTags:', error.response?.data || error.message);
    throw error;
  }
};
</file>

<file path="frontend/styles/addAddressScreenStyles.js">
// frontend/styles/addAddressScreenStyles.js

import { StyleSheet, Dimensions, Platform } from 'react-native';

const { width, height } = Dimensions.get('window');
const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#F9F9F9',
  },

  container: {
    flex: 1,
  },

  // === HEADER ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 15,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },

  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },

  // === SECCIÓN DE UBICACIÓN ===
  locationSection: {
    paddingHorizontal: 20,
    paddingTop: 25,
    paddingBottom: 15,
    backgroundColor: 'white',
    marginBottom: 2,
  },

  locationButton: {
    backgroundColor: MAIN_PURPLE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 15,
    marginBottom: 20,
    shadowColor: MAIN_PURPLE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  locationButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 10,
  },

  coordsInputContainer: {
    flexDirection: 'row',
    gap: 15,
    marginBottom: 15,
  },

  coordInputGroup: {
    flex: 1,
  },

  coordLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#666',
    marginBottom: 8,
  },

  coordInput: {
    backgroundColor: '#F5F5F5',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 15,
    color: '#333',
    fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace',
  },

  helpBox: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F0F5',
    padding: 12,
    borderRadius: 10,
    borderLeftWidth: 3,
    borderLeftColor: MAIN_PURPLE,
  },

  helpText: {
    flex: 1,
    marginLeft: 10,
    fontSize: 13,
    color: '#666',
    lineHeight: 18,
  },

  // === FORMULARIO ===
  formContainer: {
    paddingHorizontal: 20,
    paddingVertical: 20,
    paddingBottom: 100,
    backgroundColor: 'white',
  },

  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 20,
  },

  inputGroup: {
    marginBottom: 20,
  },

  label: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },

  required: {
    color: '#FF6B6B',
  },

  input: {
    backgroundColor: 'white',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 15,
    color: '#333',
  },

  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },

  // === CHECKBOX ===
  checkboxContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
    paddingVertical: 12,
  },

  checkbox: {
    width: 24,
    height: 24,
    borderRadius: 6,
    borderWidth: 2,
    borderColor: MAIN_PURPLE,
    marginRight: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },

  checkboxChecked: {
    backgroundColor: MAIN_PURPLE,
  },

  checkboxLabel: {
    fontSize: 15,
    color: '#333',
    flex: 1,
  },

  // === BOTÓN GUARDAR ===
  bottomContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'white',
    paddingHorizontal: 20,
    paddingVertical: 20,
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 10,
  },

  saveButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  saveButtonDisabled: {
    backgroundColor: '#CCC',
  },

  saveButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },
});
</file>

<file path="frontend/styles/addPetScreenStyles.js">
// frontend/styles/addPetScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const DISABLED_GREY = '#cccccc';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#F9F9F9',
  },
  container: {
    flex: 1,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingVertical: 15,
    backgroundColor: 'white',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
    textAlign: 'center',
    flex: 1,
  },
  formContainer: {
    padding: 25,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 25,
    color: '#333',
  },
  input: {
    width: '100%',
    height: 50,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    marginBottom: 25,
    fontSize: 16,
  },
  pickerContainer: {
    width: '100%',
    marginBottom: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
  },
  pickerLabel: {
    color: '#888',
    fontSize: 16,
    paddingTop: 10,
  },
  picker: {
    width: '100%',
    height: 40,
    color: '#000',
  },
  saveButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    marginTop: 20,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  saveButtonDisabled: {
    backgroundColor: DISABLED_GREY,
  },
  saveButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },
});
</file>

<file path="frontend/styles/cartScreenStyles.js">
// frontend/styles/cartScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const LIGHT_BACKGROUND = '#F9F9F9';
const SOFT_RED = '#FF6B6B';

export const styles = StyleSheet.create({
  // === CONTENEDOR PRINCIPAL ===
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  backgroundImage: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
  },

  // === HEADER ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },

  logo: {
    width: 160,
    height: 120,
    resizeMode: 'contain',
  },

  // === CONTENEDOR BLANCO ===
  container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
    paddingTop: 30,
  },

  // === TÍTULO ===
  titleContainer: {
    paddingHorizontal: 25,
    marginBottom: 20,
  },

  screenTitle: {
    fontSize: 28,
    fontWeight: '800',
    color: SECOND_PURPLE,
    letterSpacing: 0.3,
    marginBottom: 10,
  },

  countText: {
    fontSize: 15,
    fontWeight: '500',
    color: '#8A8A8A',
    marginLeft: 5,
  },

  // === LISTA ===
  listContent: {
    paddingHorizontal: 20,
    paddingBottom: 200,
  },

  // === ITEMS DEL CARRITO ===
  cartItem: {
    flexDirection: 'row',
    backgroundColor: 'white',
    borderRadius: 20,
    marginBottom: 15,
    padding: 15,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
    alignItems: 'center',
  },

  itemImage: {
    width: 80,
    height: 80,
    borderRadius: 15,
    resizeMode: 'cover',
  },

  itemInfo: {
    flex: 1,
    marginLeft: 15,
    justifyContent: 'center',
  },

  itemName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 5,
  },

  itemPrice: {
    fontSize: 14,
    fontWeight: '600',
    color: MAIN_PURPLE,
  },

  itemActions: {
    alignItems: 'center',
    justifyContent: 'space-between',
    minHeight: 80,
  },

  // === CONTROL DE CANTIDAD ===
  quantityControl: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    borderRadius: 20,
    paddingHorizontal: 8,
    paddingVertical: 5,
  },

  quantityButton: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: MAIN_PURPLE,
    justifyContent: 'center',
    alignItems: 'center',
  },

  quantityText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginHorizontal: 12,
    minWidth: 20,
    textAlign: 'center',
  },

  itemSubtotal: {
    fontSize: 18,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
    marginVertical: 5,
  },

  removeButton: {
    padding: 8,
    backgroundColor: '#FFF0F0',
    borderRadius: 15,
  },

  // === RESUMEN DEL PEDIDO ===
  summaryContainer: {
  backgroundColor: 'white',
  borderTopLeftRadius: 30,
  borderTopRightRadius: 30,
  padding: 25,
  paddingBottom: 120, //  Espacio para la barra de navegación (90px) + margen
  shadowColor: "#000",
  shadowOffset: { width: 0, height: -3 },
  shadowOpacity: 0.1,
  shadowRadius: 8,
  elevation: 10,
},
  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },

  summaryLabel: {
    fontSize: 16,
    color: '#666',
    fontWeight: '500',
  },

  summaryValue: {
    fontSize: 16,
    color: '#333',
    fontWeight: '600',
  },

  divider: {
    height: 1,
    backgroundColor: '#E0E0E0',
    marginVertical: 15,
  },

  totalLabel: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },

  totalValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },

  checkoutButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    marginTop: 20,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  checkoutButtonDisabled: {
    backgroundColor: '#CCC',
  },

  checkoutButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },

  // === ESTADOS DE CARGA Y VACÍO ===
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },

  loadingText: {
    marginTop: 10,
    color: '#666',
    fontSize: 16,
  },

  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 40,
    paddingBottom: 50,
  },

  emptyTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 10,
  },

  emptySubtitle: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 24,
  },

  exploreButton: {
    backgroundColor: ORANGE,
    paddingVertical: 15,
    paddingHorizontal: 35,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  exploreButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="frontend/styles/checkoutScreenStyles.js">
// frontend/styles/checkoutScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const LIGHT_BACKGROUND = '#F9F9F9';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  backgroundImage: {
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
  },

  // === HEADER ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },

  headerTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: 'white',
  },

  // === CONTAINER ===
  container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
  },

  scrollContent: {
    paddingBottom: 100,
  },

  // === SECCIONES ===
  section: {
    paddingHorizontal: 20,
    paddingTop: 25,
  },

  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 15,
  },

  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 15,
  },

  // === RESUMEN DEL PEDIDO ===
  orderSummary: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
  },

  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },

  summaryLabel: {
    fontSize: 15,
    color: '#666',
    fontWeight: '500',
  },

  summaryValue: {
    fontSize: 15,
    color: '#333',
    fontWeight: '600',
  },

  summaryValueGreen: {
    fontSize: 15,
    color: '#4CAF50',
    fontWeight: 'bold',
  },

  divider: {
    height: 1,
    backgroundColor: '#E0E0E0',
    marginVertical: 12,
  },

  totalLabel: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  totalValue: {
    fontSize: 22,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },

  // === DIRECCIONES ===
  noAddressContainer: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 40,
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
  },

  noAddressText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginTop: 15,
    marginBottom: 20,
  },

  addAddressButton: {
    backgroundColor: ORANGE,
    paddingVertical: 12,
    paddingHorizontal: 25,
    borderRadius: 25,
  },

  addAddressButtonText: {
    color: 'white',
    fontSize: 15,
    fontWeight: 'bold',
  },

  addressList: {
    gap: 12,
  },

  // ✅ NUEVO: Wrapper para address card + botón editar
  addressCardWrapper: {
    position: 'relative',
  },

  addressCard: {
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 15,
    paddingRight: 50, // ✅ Espacio para el botón editar
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'transparent',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
  },

  addressCardSelected: {
    borderColor: MAIN_PURPLE,
    backgroundColor: '#F5F0F5',
  },

  radioButton: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: MAIN_PURPLE,
    marginRight: 15,
    justifyContent: 'center',
    alignItems: 'center',
  },

  radioButtonInner: {
    width: 14,
    height: 14,
    borderRadius: 7,
    backgroundColor: MAIN_PURPLE,
  },

  addressInfo: {
    flex: 1,
  },

  addressHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 5,
  },

  addressName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginRight: 10,
  },

  principalBadge: {
    backgroundColor: '#FFD100',
    paddingHorizontal: 10,
    paddingVertical: 3,
    borderRadius: 12,
  },

  principalBadgeText: {
    fontSize: 11,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },

  addressReference: {
    fontSize: 14,
    color: '#666',
  },

  // ✅ NUEVO: Botón editar dirección
  editAddressButton: {
    position: 'absolute',
    right: 15,
    top: '50%',
    marginTop: -18, // Centrar verticalmente (36/2)
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#F5F0F5',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: MAIN_PURPLE,
  },

  // === PRODUCTOS ===
  productItem: {
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },

  productImage: {
    width: 60,
    height: 60,
    borderRadius: 12,
    resizeMode: 'cover',
  },

  productInfo: {
    flex: 1,
    marginLeft: 12,
  },

  productName: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },

  productPrice: {
    fontSize: 13,
    color: '#666',
  },

  productSubtotal: {
    fontSize: 16,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
    marginLeft: 10,
  },

  // === BOTÓN CONFIRMAR ===
  bottomContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'white',
    paddingHorizontal: 20,
    paddingVertical: 20,
    paddingBottom: 30,
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 10,
  },

  confirmButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  confirmButtonDisabled: {
    backgroundColor: '#CCC',
  },

  confirmButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },

  // === LOADING ===
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: LIGHT_BACKGROUND,
  },

  loadingText: {
    marginTop: 10,
    color: '#666',
    fontSize: 16,
  },
});
</file>

<file path="frontend/styles/favoritesScreenStyles.js">
// frontend/styles/favoritesScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const ORANGE = '#FF8C42';
const LIGHT_BACKGROUND = '#F9F9F9';
const SOFT_RED = '#FF6B6B'; // Para el botón de eliminar

export const styles = StyleSheet.create({
  // === 1. CONTENEDOR PRINCIPAL (similar a HomeScreen) ===
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  // === 2. HEADER MORADO (prácticamente idéntico a HomeScreen) ===
    header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15, // ✅ IGUAL QUE HOME
    },

  headerTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: 'white',
  },

  logo: {
  width: 160, // O el tamaño que prefieras
  height: 120,
  resizeMode: 'contain',
},

  // === 3. CONTENEDOR BLANCO ===
    container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
    paddingTop: 30,
    },

  // === 4. CONTADOR DE FAVORITOS ===
  countText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#666',
    marginHorizontal: 25,
    marginBottom: 20,
  },

  // === 5. LISTA Y TARJETAS ===
  listContent: {
    paddingHorizontal: 20,
    // Dejamos espacio abajo para la barra de navegación flotante
    paddingBottom: 120, 
  },
  card: {
    flexDirection: 'row',
    backgroundColor: 'white',
    borderRadius: 20,
    marginBottom: 15,
    padding: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 4,
    alignItems: 'center', // Para centrar verticalmente
  },
  cardImage: {
    width: 100,
    height: 100,
    borderRadius: 15, // Un poco menos redondeado que el círculo completo
    resizeMode: 'cover',
  },
  cardContent: {
    flex: 1,
    marginLeft: 15,
    justifyContent: 'space-between', // Espacia el contenido interno
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 4,
  },
  cardDescription: {
    fontSize: 14,
    color: '#888',
    lineHeight: 20,
    marginBottom: 8,
  },
  cardFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  cardPrice: {
    fontSize: 20,
    fontWeight: 'bold',
    color: MAIN_PURPLE,
  },
  removeButton: {
    padding: 8, // Aumenta el área de toque del botón
    backgroundColor: '#FFF0F0', // Un fondo rojo muy suave
    borderRadius: 20,
  },

  // === 6. ESTADOS DE CARGA Y VACÍO ===
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  loadingText: {
    marginTop: 10,
    color: '#666',
    fontSize: 16,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 40,
    paddingBottom: 50, // Para que no quede tan pegado abajo
  },
  emptyTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 10,
  },
  emptySubtitle: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 24,
  },
  exploreButton: {
    backgroundColor: ORANGE,
    paddingVertical: 15,
    paddingHorizontal: 35,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  exploreButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },

  titleContainer: {
  paddingHorizontal: 25,
  marginBottom: 20,
},

screenTitle: {
  fontSize: 28,          // ✅ Más grande
  fontWeight: '800',     // ✅ Más presencia
  color: '#732C71',
  letterSpacing: 0.3,    // ✅ Elegante
  marginBottom: 10,
},

countText: {
  fontSize: 15,
  fontWeight: '500',
  color: '#8A8A8A',
  marginLeft: 5,         // ✅ alineado suave con el título
},
});
</file>

<file path="frontend/styles/homeScreenStyles.js">
// src/styles/homeScreenStyles.js
import { StyleSheet, Dimensions, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const LIGHT_BACKGROUND = '#F9F9F9';
const ORANGE = '#FF8C42';

export const styles = StyleSheet.create({
  // === CONTENEDOR PRINCIPAL ===
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  // === HEADER MORADO ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },
  logo: {
    width: 160,
    height: 120,
    resizeMode: 'contain',
  },

  // === CONTENEDOR BLANCO ===
  container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
    paddingTop: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -5 },
    shadowOpacity: 0.1,
    shadowRadius: 10,
    elevation: 10,
  },

  // === TÍTULO DE BIENVENIDA ===
  welcomeTitle: {
    fontSize: 28,
    fontWeight: '800',
    color: '#732C71',
    marginHorizontal: 25,
    marginBottom: 25,
    lineHeight: 38,
  },

  // === CATEGORÍAS CON LÍNEA INFERIOR ===
  categoryScrollView: {
    marginBottom: 25,
    paddingLeft: 25,
    maxHeight: 50,
  },
  categoryButton: {
    marginRight: 30,
    paddingBottom: 10,
    alignItems: 'center',
  },
  categoryText: {
    fontSize: 16,
    color: '#999',
    fontWeight: '600',
    marginBottom: 8,
  },
  activeCategoryText: {
    color: MAIN_PURPLE,
    fontWeight: 'bold',
    fontSize: 17,
  },
  categoryUnderline: {
    height: 4,
    width: '100%',
    backgroundColor: MAIN_PURPLE,
    borderRadius: 2,
    shadowColor: MAIN_PURPLE,
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.5,
    shadowRadius: 4,
    elevation: 3,
  },

  // === LISTA DE PRODUCTOS ===
  productList: {
    paddingLeft: 25,
    paddingVertical: 0,
    paddingBottom: 30,
  },

  // === MENSAJE VACÍO ===
  emptyText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    marginTop: 50,
    marginHorizontal: 40,
  },

  // === BARRA DE NAVEGACIÓN INFERIOR ===
  bottomNavigation: {
    flexDirection: 'row',
    backgroundColor: MAIN_PURPLE,
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderTopLeftRadius: 25,
    borderTopRightRadius: 25,
    justifyContent: 'space-around',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 10,
    borderRadius: 25, 
  },
  navButton: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  navIconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 4,
  },
  activeNavButton: {
    backgroundColor: ORANGE,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 8,
    elevation: 6,
  },
  navText: {
    fontSize: 12,
    color: 'white',
    fontWeight: '500',
  },
  activeNavText: {
    fontWeight: 'bold',
    color: 'white',
  },

  
});
</file>

<file path="frontend/styles/loginScreenStyles.js">
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    width: '100%',
    padding: 30,
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    alignItems: 'center',
    paddingTop: 80, // Espacio para que el logo se vea arriba
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 30,
  },
  input: {
    width: '100%',
    height: 50,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    marginBottom: 25,
    fontSize: 16,
    paddingLeft: 5,
  },
  button: {
    width: '100%',
    height: 50,
    backgroundColor: '#732C71', // Morado de Figma
    borderRadius: 25,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold',
  },
  forgotPasswordText: {
    marginTop: 20,
    color: '#555',
    fontSize: 14,
  },
  registerContainer: {
    marginTop: 15,
  },
  registerText: {
    color: '#555',
    fontSize: 14,
  },
  registerLink: {
    color: '#732C71',
    fontWeight: 'bold',
    textDecorationLine: 'underline',
  },
});
</file>

<file path="frontend/styles/orderSuccessScreenStyles.js">
// frontend/styles/orderSuccessScreenStyles.js

import { StyleSheet } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const YELLOW = '#FFD100';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#F9F9F9',
  },

  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 30,
    position: 'relative',
  },

  // === ÍCONO DE ÉXITO ===
  iconContainer: {
    marginBottom: 40,
  },

  iconCircle: {
    width: 160,
    height: 160,
    borderRadius: 80,
    backgroundColor: '#4CAF50',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#4CAF50",
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 16,
    elevation: 12,
  },

  // === MENSAJE ===
  messageContainer: {
    alignItems: 'center',
    width: '100%',
  },

  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
    textAlign: 'center',
  },

  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 24,
  },

  // === INFORMACIÓN DEL PEDIDO ===
  orderInfoCard: {
    width: '100%',
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 25,
    marginBottom: 25,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 6,
  },

  orderInfoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },

  orderInfoLabel: {
    fontSize: 15,
    color: '#666',
    fontWeight: '500',
  },

  orderInfoValue: {
    fontSize: 16,
    color: '#333',
    fontWeight: 'bold',
  },

  orderInfoValueHighlight: {
    fontSize: 20,
    color: SECOND_PURPLE,
    fontWeight: 'bold',
  },

  divider: {
    height: 1,
    backgroundColor: '#E0E0E0',
    marginVertical: 15,
  },

  // === INFORMACIÓN ADICIONAL ===
  additionalInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F0F5',
    borderRadius: 15,
    padding: 15,
    marginBottom: 40,
  },

  additionalInfoText: {
    flex: 1,
    marginLeft: 12,
    fontSize: 14,
    color: '#666',
    lineHeight: 20,
  },

  // === BOTONES ===
  buttonsContainer: {
    width: '100%',
    gap: 15,
  },

  primaryButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  primaryButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },

  secondaryButton: {
    backgroundColor: 'white',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    borderWidth: 2,
    borderColor: MAIN_PURPLE,
  },

  secondaryButtonText: {
    color: MAIN_PURPLE,
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 10,
  },

  // === DECORACIÓN ===
  decorationCircle1: {
    position: 'absolute',
    top: -50,
    right: -50,
    width: 200,
    height: 200,
    borderRadius: 100,
    backgroundColor: YELLOW,
    opacity: 0.15,
  },

  decorationCircle2: {
    position: 'absolute',
    bottom: -80,
    left: -80,
    width: 250,
    height: 250,
    borderRadius: 125,
    backgroundColor: MAIN_PURPLE,
    opacity: 0.1,
  },
});
</file>

<file path="frontend/styles/paymentScreenStyles.js">
// frontend/styles/paymentScreenStyles.js
import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const LIGHT_GRAY = '#F5F5F5';
const DARK_TEXT = '#333';
const INFO_BG = '#FFF3E0';

export const styles = StyleSheet.create({
  mainContainer: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  safeArea: {
    flex: 1,
  },

  backgroundImage: {
    ...StyleSheet.absoluteFillObject,
    zIndex: -1,
  },

  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 40 : 10,
    paddingBottom: 15,
    backgroundColor: 'transparent',
  },

  logo: {
    width: 160,
    height: 120,
    resizeMode: 'contain',
  },

  // 🔥 CAMBIO CRÍTICO #1: Container con flex
  container: {
    flex: 1,
    backgroundColor: LIGHT_GRAY,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
  },

  // 🔥 CAMBIO CRÍTICO #2: ScrollView sin flex
  scrollContainer: {
    flex: 1,
  },

  // 🔥 CAMBIO CRÍTICO #3: Padding aumentado
  scrollContent: {
    paddingTop: 30,
    paddingHorizontal: 20,
    paddingBottom: -20, // ⬆️ AUMENTADO de 200 a 250
  },

  paymentTitle: {
    fontSize: 24,
    fontWeight: '800',
    color: '#732C71',
    marginHorizontal: 25,
    marginBottom: 20,
    lineHeight: 36,
  },

  section: {
    marginBottom: 25,
  },

  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: DARK_TEXT,
    marginBottom: 12,
  },

  summaryCard: {
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },

  summaryRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },

  summaryLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: DARK_TEXT,
  },

  totalValue: {
    fontSize: 22,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },

  methodsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 10,
  },

  methodCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 3,
  },

  methodCardSelected: {
    borderWidth: 2,
    borderColor: MAIN_PURPLE,
    backgroundColor: '#F9F5F9',
  },

  radioButton: {
    width: 20,
    height: 20,
    borderRadius: 10,
    borderWidth: 2,
    borderColor: '#ccc',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 8,
  },

  radioButtonInner: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: MAIN_PURPLE,
  },

  methodName: {
    marginLeft: 8,
    fontSize: 16,
    color: DARK_TEXT,
  },

  methodNameSelected: {
    fontWeight: 'bold',
    color: MAIN_PURPLE,
  },

  qrCard: {
    backgroundColor: 'white',
    borderRadius: 15,
    padding: 20,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 4,
    elevation: 3,
  },

  qrImage: {
    width: 190,
    height: 190,
    marginBottom: 20,
    resizeMode: 'contain',
    marginTop: -20,
  },

  qrInstructions: {
    fontSize: 14,
    color: '#666',
    textAlign: 'left',
    lineHeight: 22,
    alignSelf: 'stretch',
    marginTop: -45,
  },

  uploadButton: {
    backgroundColor: 'white',
    borderRadius: 15,
    borderWidth: 2,
    borderStyle: 'dashed',
    borderColor: MAIN_PURPLE,
    paddingVertical: 10,
    alignItems: 'center',
    justifyContent: 'center',
  },

  uploadText: {
    fontSize: 16,
    fontWeight: '600',
    color: DARK_TEXT,
    marginTop: 10,
  },

  uploadSubtext: {
    fontSize: 13,
    color: '#999',
    marginTop: 4,
  },

  proofContainer: {
    alignItems: 'center',
  },

  proofImage: {
    width: 220,
    height: 220,
    borderRadius: 15,
    marginBottom: 15,
    resizeMode: 'cover',
  },

  changeProofButton: {
    flexDirection: 'row',
    backgroundColor: MAIN_PURPLE,
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 25,
    alignItems: 'center',
  },

  changeProofText: {
    color: 'white',
    marginLeft: 6,
    fontWeight: 'bold',
    fontSize: 14,
  },

  infoBox: {
    flexDirection: 'row',
    backgroundColor: INFO_BG,
    padding: 15,
    borderRadius: 12,
    alignItems: 'flex-start',
    marginBottom: 30,
  },

  infoText: {
    marginLeft: 10,
    fontSize: 13,
    color: DARK_TEXT,
    flex: 1,
    lineHeight: 19,
  },

  bottomContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    paddingHorizontal: 20,
    paddingBottom: Platform.OS === 'ios' ? 30 : 20,
    paddingTop: 15,
    backgroundColor: LIGHT_GRAY,
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
  },

  confirmButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 16,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 8,
    elevation: 8,
  },

  confirmButtonDisabled: {
    opacity: 0.6,
  },

  confirmButtonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginLeft: 8,
  },

  qrCard: {
  backgroundColor: 'white',
  borderRadius: 15,
  padding: 12,
  flexDirection: 'row',      // ⬅️ Aquí hacemos fila
  alignItems: 'center',      // Centra verticalmente
  justifyContent: 'flex-start',
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.08,
  shadowRadius: 4,
  elevation: 3,
},

qrImage: {
  width: 166,                // ⬅️ Ajusta según quieras
  height: 166,
  resizeMode: 'contain',
  marginRight: 10,           // ⬅️ Espacio entre imagen y texto
  marginTop: 0,              // ⬅️ quitar margenes negativos
},

qrInstructions: {
  fontSize: 14,
  color: '#666',
  textAlign: 'left',
  lineHeight: 22,
  flex: 1,                   // ⬅️ Que tome el resto del espacio
  marginTop: 0,
},

});
</file>

<file path="frontend/styles/petProfileScreenStyles.js">
// frontend/styles/petProfileScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

export const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const LIGHT_BACKGROUND = '#F9F9F9';

export const styles = StyleSheet.create({
  // === CONTENEDOR PRINCIPAL ===
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  backgroundImage: {
    position: 'absolute',
    width: '100%',
    height: '100%',
  },

  // === HEADER ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },

  logo: {
    width: 160,
    height: 120,
    resizeMode: 'contain',
  },

  // === CONTENEDOR BLANCO ===
  container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
  },

  // === ESTADOS DE CARGA Y VACÍO ===
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },

  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 40,
  },

  emptyTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 10,
    textAlign: 'center',
  },

  emptySubtitle: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginBottom: 30,
    lineHeight: 24,
  },

  addButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 30,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },

  addButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 10,
  },
  
  // === VISTA DE PERFIL ===
  profileContainer: {
    flex: 1,
  },

  petSelectorContainer: {
    paddingVertical: 20,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#EEE',
  },

  petSelectorItem: {
    alignItems: 'center',
    marginRight: 20,
  },

  petImageWrapper: {
    width: 70,
    height: 70,
    borderRadius: 35,
    borderWidth: 3,
    borderColor: '#CCC',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 3,
  },

  petImageWrapperSelected: {
    borderColor: MAIN_PURPLE,
  },

  petImage: {
    width: '100%',
    height: '100%',
    borderRadius: 32,
  },

  petSelectorName: {
    marginTop: 8,
    fontSize: 14,
    fontWeight: '600',
    color: '#888',
  },

  petSelectorNameSelected: {
    color: MAIN_PURPLE,
  },

  // --- Detalles del Perfil ---
  detailCard: {
    margin: 20,
    backgroundColor: 'white',
    borderRadius: 20,
    padding: 20,
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },

  mainPetImage: {
    width: 140,
    height: 140,
    borderRadius: 70,
    borderWidth: 4,
    borderColor: 'white',
    marginTop: -80, // Para que flote sobre la tarjeta
    marginBottom: 15,
  },

  petName: {
    fontSize: 26,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
    marginBottom: 15,
  },

  detailGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
    width: '100%',
    marginBottom: 20,
  },

  detailItem: {
    alignItems: 'center',
    width: '45%',
    marginVertical: 10,
  },

  detailLabel: {
    fontSize: 14,
    color: '#888',
  },

  detailValue: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 4,
  },

  actionButtonsContainer: {
    flexDirection: 'row',
    marginTop: 10,
    width: '100%',
    justifyContent: 'space-around',
  },

  editButton: {
    backgroundColor: MAIN_PURPLE,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25,
    flexDirection: 'row',
    alignItems: 'center',
  },
  
  buttonText: {
    color: 'white',
    fontSize: 15,
    fontWeight: 'bold',
    marginLeft: 8,
  }
});
</file>

<file path="frontend/styles/productCardStyles.js">
// Archivo: styles/productCardStyles.js

import { StyleSheet } from 'react-native';

const MAIN_PURPLE = '#875686';
const ORANGE = '#FF8C42';
const YELLOW = '#FFD100';

export const styles = StyleSheet.create({
  cardContainer: {
    backgroundColor: 'white',
    borderRadius: 20,
    width: 250,
    marginRight: 20,
    padding: 15,
    paddingTop: 160,
    paddingBottom: 35,
    height: 420,
    justifyContent: 'space-between',
     //   Espacio para que la imagen sobresalga
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
    marginTop: 60, 
    overflow: 'visible',
  },

  spacer: {
    flex: 0.0001, 
    width: '100%',
  },

  infoContainer: {
    alignItems: 'center',
    justifyContent: 'flex-start',
    width: '100%',
  },
  // === TARJETA DEL CENTRO DESTACADA ===
  centerCard: {
    borderWidth: 3,
    borderColor: YELLOW,
    shadowColor: YELLOW,
    shadowOpacity: 0.3,
    shadowRadius: 15,
    elevation: 15,
  },
  // === BADGE "DESTACADO" ===
  highlightBadge: {
    position: 'absolute',
    top: 45,
    right: 15,
    backgroundColor: YELLOW,
    paddingHorizontal: 15,
    paddingVertical: 6,
    borderRadius: 20,
    zIndex: 10,
    shadowColor: YELLOW,
    shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.4,
    shadowRadius: 6,
    elevation: 8,
  },
  highlightText: {
    fontSize: 12,
    fontWeight: 'bold',
    color: MAIN_PURPLE,
  },
  image: {
    width: 230, // 🔥 Imagen más grande
    height: 200,
    borderRadius: 100,
    position: 'absolute', // 🔥 Posición absoluta
    top: -60, // 🔥 Sobresale hacia arriba
    resizeMode: 'cover',
    borderWidth: 4,
    borderColor: 'white',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 10,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginTop: 10,
  },
  subtitle: {
  fontSize: 14,
  color: '#996698',
  textAlign: 'center',
  marginBottom: 10,
  marginTop: 5,
  paddingHorizontal: 5,
  fontWeight: 'bold', // o 'OpenSans-Regular' si no quieres tan grueso
},
  price: {
    fontSize: 20,
    fontWeight: 'bold',
    color:  '#60395F',
    marginBottom: 15,
    marginTop: 0,
  },
  footer: {
  width: '100%',
  alignItems: 'center',
  marginBottom: 25, // 
  },

addToCartButton: {
  backgroundColor: '#FF8C00',
  flexDirection: 'row',
  alignItems: 'center',
  justifyContent: 'center',
  paddingVertical: 8,
  paddingHorizontal: 20,
  borderRadius: 15,
  marginBottom: 6,
},

addToCartText: {
  color: '#fff',
  fontWeight: 'bold',
  fontSize: 14,
  marginLeft: 6,
},

seeMoreText: {
  color: MAIN_PURPLE,
  fontWeight: 'bold',
  fontSize: 14,
  textAlign: 'center',
},

});
</file>

<file path="frontend/styles/productDetailScreenStyles.js">
// frontend/styles/productDetailScreenStyles.js

import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const ORANGE = '#FF8C42';
const YELLOW = '#FFD100';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },

  // === HEADER MORADO (igual que HomeScreen) ===
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },
  logo: {
    width: 160,
    height: 120,
    resizeMode: 'contain',
  },

  // === CONTENEDOR PRINCIPAL ===
  scrollContent: {
    flexGrow: 1,
    paddingTop: 20, // Espacio después de la imagen
  },

  container: {
    flex: 1,
    backgroundColor: '#F9F9F9',
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
    paddingTop: 180, // 🔥 AUMENTADO de 140 a 160 para dar más espacio a la imagen
    overflow: 'visible', // 🔥 CAMBIADO de 'hidden' a 'visible' para que la imagen no se corte
  },

  // === IMAGEN FLOTANTE ===
  imageContainer: {
    position: 'absolute',
    top: -18, // 🔥 AJUSTADO de -70 a -90 para que sobresalga más
    alignSelf: 'center',
    zIndex: 100, // 🔥 AUMENTADO de 10 a 100 para que esté sobre TODO
  },
  productImage: {
    width: 240,
    height: 250,
    borderRadius: 120,
    borderWidth: 0,
    borderColor: 'white',
    resizeMode: 'cover',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.50,
    shadowRadius: 10,
    elevation: 15,
  },

  // === BOTONES FLOTANTES ===
  backButton: {
    position: 'absolute',
    top: 10, // Ajustado
    left: 20,
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: MAIN_PURPLE,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  favoriteButton: {
    position: 'absolute',
    top: 10, // Ajustado
    right: 20,
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: 'white',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
    elevation: 5,
  },

  // === CONTENIDO ===
  contentContainer: {
    paddingHorizontal: 25, // Reducido de 30
    paddingBottom: 40,
    paddingTop: 20, // Aumentado para la barra de navegación
  },

  // === TÍTULO Y PRECIO ===
  productName: {
    fontSize: 28, // Reducido de 32
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 8, // Reducido
    paddingHorizontal: 10,
  },
  priceRow: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 15, // Reducido
  },
  productPrice: {
    fontSize: 26, // Reducido de 28
    fontWeight: 'bold',
    color: SECOND_PURPLE,
    marginHorizontal: 10,
  },

  // === ETIQUETAS ===
  tagsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    flexWrap: 'wrap',
    marginBottom: 20, // Reducido
    paddingHorizontal: 10,
  },
  tag: {
    backgroundColor: 'white',
    borderWidth: 2,
    borderColor: MAIN_PURPLE,
    borderRadius: 20,
    paddingVertical: 4, // Reducido
    paddingHorizontal: 14, // Reducido
    marginHorizontal: 4,
    marginVertical: 0.5,
  },
  tagText: {
    color: MAIN_PURPLE,
    fontWeight: '600',
    fontSize: 13, // Reducido
  },

  // === SECCIÓN DE INGREDIENTES ===
  section: {
    marginBottom: 7, // Reducido
  },
  sectionTitle: {
    fontSize: 20, // Reducido de 22
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 8, // Reducido
  },
  sectionText: {
    fontSize: 15, // Reducido
    color: '#666',
    lineHeight: 22, // Reducido
  },

  // === CONTADOR DE CANTIDAD ===
  quantityContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginVertical: 15, // Reducido
  },
  quantityButton: {
    width: 35, // Igual que antes
    height: 35,
    borderRadius: 25,
    backgroundColor: MAIN_PURPLE,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  quantityText: {
    fontSize: 22, // Reducido de 24
    fontWeight: 'bold',
    color: '#333',
    marginHorizontal: 25, // Reducido
    minWidth: 40,
    textAlign: 'center',
  },

  // === BOTÓN AGREGAR AL CARRITO ===
  addToCartButton: {
    backgroundColor: ORANGE,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 16, // Reducido
    borderRadius: 30,
    marginHorizontal: 15, // Reducido
    marginBottom: 25, // Reducido
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 8,
    elevation: 8,
  },
  addToCartText: {
    color: 'white',
    fontSize: 17, // Reducido
    fontWeight: 'bold',
    marginLeft: 8,
  },

  // === BARRA DE NAVEGACIÓN INFERIOR (igual que HomeScreen) ===
  bottomNavigation: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    flexDirection: 'row',
    backgroundColor: MAIN_PURPLE,
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    justifyContent: 'space-around',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 10,
  },
  navButton: {
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  navIconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 4,
  },
  activeNavButton: {
    backgroundColor: ORANGE,
    shadowColor: ORANGE,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.4,
    shadowRadius: 8,
    elevation: 6,
  },
  navText: {
    fontSize: 12,
    color: 'white',
    fontWeight: '500',
  },
  activeNavText: {
    fontWeight: 'bold',
    color: 'white',
  },

  // === LOADING ===
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F9F9F9',
  },

  // === ERROR ===
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingHorizontal: 40,
  },
  errorText: {
    fontSize: 18,
    color: '#666',
    textAlign: 'center',
    marginBottom: 20,
  },
  errorButton: {
    backgroundColor: MAIN_PURPLE,
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 25,
  },
  errorButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
</file>

<file path="frontend/styles/registerScreenStyles.js">
import { StyleSheet } from 'react-native';

const PRIMARY_PURPLE = '#732C71';
const DISABLED_GREY = '#cccccc';
const SECONDARY_LAVENDER = '#E6E6FA';

export const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    width: '100%',
    padding: 30,
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    alignItems: 'center',
    paddingTop: 40,
  },
  // --- FORMULARIO ---
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    alignSelf: 'flex-start',
    marginBottom: 20,
    color: '#333',
  },
  input: {
    width: '100%',
    height: 50,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    marginBottom: 20,
    fontSize: 16,
  },
  // --- BOTONES ---
  button: {
    width: '100%',
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 10,
  },
  buttonPrimary: {
    backgroundColor: PRIMARY_PURPLE,
  },
  buttonDisabled: {
    backgroundColor: DISABLED_GREY,
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  buttonRow: {
    flexDirection: 'row',
    width: '100%',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  buttonFlex: {
    flex: 1,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonSecondary: {
    backgroundColor: SECONDARY_LAVENDER,
    marginRight: 10,
  },
  buttonSecondaryText: {
    color: PRIMARY_PURPLE,
    fontSize: 18,
    fontWeight: 'bold',
  },
  // --- PICKERS (SELECTORES) ---
  pickerContainer: {
    width: '100%',
    marginBottom: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
  },
  pickerLabel: {
    color: '#888',
    fontSize: 16,
    paddingTop: 10,
  },
  picker: {
    width: '100%',
    height: 40,
    color: '#000',
  },
  // --- PAGINACIÓN ---
  progressContainer: {
    flexDirection: 'row',
    marginTop: 30,
  },
  progressDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    backgroundColor: '#ccc',
    marginHorizontal: 5,
  },
  progressDotActive: {
    backgroundColor: PRIMARY_PURPLE,
  },
});
</file>

<file path="frontend/styles/splashScreenStyles.js">
// frontend/styles/splashScreenStyles.js
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  background: {
    flex: 1,
    backgroundColor: '#875686', // Color morado principal
  },
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    overflow: 'hidden',
  },
  logo: {
    width: 280,
    height: 280,
    resizeMode: 'contain',
    zIndex: 10,
  },
  
  // ===== CÍRCULOS DECORATIVOS =====
  
  // Círculo superior izquierdo (morado oscuro)
  circleTopLeft: {
    position: 'absolute',
    top: -80,
    left: -80,
    width: 220,
    height: 220,
    borderRadius: 110,
    backgroundColor: 'rgba(96, 57, 95, 0.6)',
  },
  
  // Círculo superior derecho (amarillo)
  circleTopRight: {
    position: 'absolute',
    top: -50,
    right: -100,
    width: 280,
    height: 280,
    borderRadius: 140,
    backgroundColor: '#FFD100',
  },
  
  // Círculo inferior izquierdo (amarillo)
  circleBottomLeft: {
    position: 'absolute',
    bottom: -120,
    left: -100,
    width: 300,
    height: 300,
    borderRadius: 150,
    backgroundColor: '#FFD100',
  },
  
  // Círculo inferior derecho (morado oscuro)
  circleBottomRight: {
    position: 'absolute',
    bottom: -80,
    right: -50,
    width: 250,
    height: 250,
    borderRadius: 125,
    backgroundColor: 'rgba(96, 57, 95, 0.7)',
  },
  
  // Agregar estos estilos si usas imágenes:

  // ===== HUESITOS CON IMÁGENES =====
boneImage1: {
  position: 'absolute',
  top: 90,
  left: 150,
  width: 100,
  height: 100,
  opacity: 0.25,
  transform: [{ rotate: '0deg' }],
  resizeMode: 'contain',
},

boneImage2: {
  position: 'absolute',
  bottom: 420,
  top: 290,
  right: 15,
  width: 90,
  height: 90,
  opacity: 0.25,
  transform: [{ rotate: '200deg' }],
  resizeMode: 'contain',
},
  // ===== PATITAS CON IMÁGENES =====
  pawImage1: {
    position: 'absolute',
    top: 260,
    left: -20,
    width: 140,
    height: 140,
    opacity: 0.35,
    resizeMode: 'contain',
  },
  
  pawImage2: {
    position: 'absolute',
    bottom: 200,
    right: 60,
    width: 90,
    height: 90,
    opacity: 0.35,
    transform: [{ rotate: '-60deg' }],
    resizeMode: 'contain',
  },
  
  pawImage3: {
    position: 'absolute',
    bottom: 280,
    left: 30,
    width: 60,
    height: 60,
    opacity: 0.4,
    resizeMode: 'contain',
  },
});
</file>

<file path="frontend/styles/successScreenStyles.js">
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  card: {
    backgroundColor: 'white',
    width: '100%',
    padding: 25,
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
    alignItems: 'center',
  },
  iconContainer: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#E6E6FA', // Morado claro
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#888',
    textAlign: 'center',
    marginBottom: 30,
  },
  buttonPrimary: {
    width: '100%',
    height: 50,
    backgroundColor: '#732C71',
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 10,
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
});
</file>

<file path="frontend/styles/userProfileScreenStyles.js">
// frontend/styles/userProfileScreenStyles.js
import { StyleSheet, Platform } from 'react-native';

const MAIN_PURPLE = '#875686';
const SECOND_PURPLE = '#732C71';
const YELLOW = '#FFD100';
const LIGHT_BACKGROUND = '#F9F9F9';

export const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: MAIN_PURPLE,
  },
  backgroundImage: {
    position: 'absolute',
    width: '100%',
    height: '100%',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: Platform.OS === 'android' ? 25 : 10,
    paddingBottom: 15,
  },
  logo: {
    width: 120,
    height: 60,
    resizeMode: 'contain',
  },
  container: {
    flex: 1,
    backgroundColor: LIGHT_BACKGROUND,
    borderTopLeftRadius: 40,
    borderTopRightRadius: 40,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scrollView: {
    paddingBottom: 40,
  },

  // --- Profile Header ---
  profileHeader: {
    paddingHorizontal: 25,
    paddingTop: 20,
    paddingBottom: 30,
    alignItems: 'center',
  },
  headerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    width: '100%',
    marginBottom: 20,
  },
  backButton: {
    backgroundColor: SECOND_PURPLE,
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginLeft: 20,
  },
  profilePic: {
    width: 100,
    height: 100,
    borderRadius: 50,
    borderWidth: 3,
    borderColor: 'white',
    marginBottom: 10,
  },
  profileInfo: {
    marginLeft: 20,
    flex: 1,
  },
  profileName: {
    fontSize: 22,
    fontWeight: 'bold',
    color: SECOND_PURPLE,
  },
  profileContact: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  editButton: {
    backgroundColor: YELLOW,
    paddingVertical: 8,
    paddingHorizontal: 20,
    borderRadius: 20,
    marginTop: 10,
    alignSelf: 'flex-start',
  },
  editButtonText: {
    color: SECOND_PURPLE,
    fontWeight: 'bold',
    fontSize: 14,
  },
  profileSection: {
    flexDirection: 'row',
    alignItems: 'center',
  },

  // --- Mascotas Section ---
  petsSection: {
    backgroundColor: 'white',
    marginHorizontal: 20,
    borderRadius: 20,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 5,
  },
  petsSectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 20,
  },
  petsList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 15,
  },
  petCard: {
    backgroundColor: LIGHT_BACKGROUND,
    borderRadius: 15,
    padding: 15,
    width: '48%', // Aprox para 2 por fila
    alignItems: 'center',
  },
  petImage: {
    width: 80,
    height: 80,
    borderRadius: 40,
    marginBottom: 10,
  },
  petName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  petInfo: {
    fontSize: 13,
    color: '#777',
  },
  petDetails: {
    fontSize: 12,
    color: '#999',
    marginTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#EEE',
    paddingTop: 8,
    textAlign: 'center',
  },
  addPetCard: {
    backgroundColor: 'transparent',
    borderRadius: 15,
    width: '48%',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderStyle: 'dashed',
    borderColor: '#DDD',
    paddingVertical: 30, // Ajusta para que tenga altura similar
  },
  addPetCircle: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: SECOND_PURPLE,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  addPetText: {
    fontSize: 14,
    fontWeight: '600',
    color: SECOND_PURPLE,
    textAlign: 'center'
  },
});
</file>

<file path="frontend/styles/welcomeScreenStyles.js">
import { StyleSheet } from 'react-native';

export const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
  },
  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0,0,0,0.6)',
  },
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 80,
    paddingHorizontal: 20,
  },
  logo: {
    width: 300,
    height: 250,
    resizeMode: 'contain',
    marginTop: 2,
  },
  bottomContainer: {
    width: '100%',
    alignItems: 'center',
  },
  loginButton: {
    backgroundColor: '#FFD100',
    paddingVertical: 15,
    paddingHorizontal: 30,
    borderRadius: 30,
    width: '100%',
    alignItems: 'center',
    marginBottom: 20,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.30,
    shadowRadius: 4.65,
    elevation: 8,
  },
  loginButtonText: {
    fontSize: 25,
    color: '#60395F',
    fontWeight: 'bold',
    textShadowColor: '#ffffff',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 1,
  },
  registerText: {
    color: 'white',
    fontSize: 20,
  },
  registerLink: {
    fontWeight: 'bold',
    color: '#FFD100',
  },
  overlay2: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(39, 36, 36, 0.3)',
  },
});
</file>

<file path="package.json">
{
  "dependencies": {
    "@react-navigation/bottom-tabs": "^7.8.12"
  }
}
</file>

</files>
